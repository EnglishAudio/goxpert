{"meta":{"title":"GoXpert.ru","subtitle":"GoXpert.ru для тех, кто хочет стать экспертом в GO разработке","description":"Секреты Golang. Архитектура и дизайн приложений на GO. Всё о GO изнутри","author":"авторы проекта GoXpert","url":"https://goxpert.ru","root":"/"},"pages":[{"title":"","date":"2021-11-27T21:16:20.121Z","updated":"2021-11-27T21:16:20.076Z","comments":true,"path":"search.html","permalink":"https://goxpert.ru/search.html","excerpt":"","text":"(function(w,d,c){var s=d.createElement('script'),h=d.getElementsByTagName('script')[0];s.type='text/javascript';s.async=true;s.charset='utf-8';s.src=(d.location.protocol==='https:'?'https:':'http:')+'//site.yandex.net/v2.0/js/all.js';h.parentNode.insertBefore(s,h);(w[c]||(w[c]=[])).push(function(){Ya.Site.Results.init();})})(window,document,'yandex_site_callbacks');"}],"posts":[{"title":"Планировщик ОS","slug":"os/os_scheduler","date":"2024-06-02T15:32:20.263Z","updated":"2024-06-02T16:06:43.594Z","comments":true,"path":"2024/06/02/os/os_scheduler/","link":"","permalink":"https://goxpert.ru/2024/06/02/os/os_scheduler/","excerpt":"","text":"Планировщик операционной системыКраткий пересказ перевода: Многопоточность в программировании требует учета различных факторов, таких как переключение контекста и планирование работы. Переключение контекста может снизить производительность, особенно при работе с привязкой к процессору. Ограничение минимального временного интервала помогает сбалансировать количество потоков и производительность. Пулы потоков могут быть полезны для управления количеством потоков и достижения наилучшей пропускной способности приложения. Системы кэширования играют важную роль в производительности многопоточных приложений, и необходимо учитывать их механику. При написании многопоточных приложений необходимо учитывать системы кэширования и принимать решения о планировании. ВведениеДизайн и поведение планировщика Go позволяет вашим многопоточным программам Go быть более эффективными. Это происходит благодаря механическим симпатиям планировщика Go к планировщику операционной системы (OS). Однако, если дизайн и поведение вашего многопоточного программного обеспечения Go механически не соответствуют тому, как работают планировщики, ничто из этого не будет иметь значения. Важно иметь общее представление о том, как работают планировщики операционной системы и Go, чтобы правильно спроектировать ваше многопоточное программное обеспечение. Эта статья, состоящая из нескольких частей, будет посвящена высокоуровневой механике и семантике планировщиков. Я предоставлю достаточно подробностей, чтобы вы могли наглядно представить, как все работает, и принимать более эффективные инженерные решения. Несмотря на то, что многое зависит от инженерных решений, которые вам необходимо принять для многопоточных приложений, механика и семантика составляют важнейшую часть необходимых вам базовых знаний. Планировщик операционной системыПланировщики операционной системы - это сложные программные продукты. Они должны учитывать компоновку и настройку оборудования, на котором они работают. Это включает, но не ограничивается наличием нескольких процессоров и ядер, кэшей процессора и NUMA. Без этих знаний планировщик не может быть максимально эффективным. Замечательно то, что вы все еще можете разработать хорошую мысленную модель того, как работает планировщик операционной системы, не углубляясь в эти темы. Ваша программа - это просто серия машинных инструкций, которые необходимо выполнять последовательно одну за другой. Чтобы это произошло, операционная система использует концепцию потока. Задача Потока состоит в том, чтобы учитывать и последовательно выполнять набор назначенных ему инструкций. Выполнение продолжается до тех пор, пока у потока больше не останется инструкций для выполнения. Вот почему я называю поток “путем выполнения”. Каждая запускаемая вами программа создает процесс, и каждому процессу присваивается начальный поток. Потоки имеют возможность создавать новые потоки. Все эти разные потоки выполняются независимо друг от друга, и решения о планировании принимаются на уровне потока, а не на уровне процесса. Потоки могут выполняться одновременно (каждый по очереди на отдельном ядре) или параллельно (каждый выполняется одновременно на разных ядрах). Потоки также поддерживают свое собственное состояние, чтобы обеспечить безопасное, локальное и независимое выполнение своих инструкций. Планировщик операционной системы отвечает за то, чтобы ядра не простаивали, если есть потоки, которые могут выполняться. Он также должен создавать иллюзию, что все потоки, которые могут выполняться, выполняются одновременно. В процессе создания этой иллюзии планировщику необходимо запускать потоки с более высоким приоритетом по сравнению с потоками с более низким приоритетом. Однако потоки с более низким приоритетом нельзя ограничивать во времени выполнения. Планировщику также необходимо максимально минимизировать задержки при планировании, принимая быстрые и разумные решения. Для этого многое зависит от алгоритмов, но, к счастью, отрасль может использовать десятилетия работы и опыта. Чтобы лучше понять все это, полезно описать и определить несколько важных концепций. Выполнение инструкцийСчетчик программ (PC), который иногда называют указателем команд (IP), - это то, что позволяет потоку отслеживать следующую команду для выполнения. В большинстве процессоров ПК указывает на следующую инструкцию, а не на текущую.","categories":[{"name":"ОС","slug":"ОС","permalink":"https://goxpert.ru/categories/%D0%9E%D0%A1/"},{"name":"Планировщик ОS","slug":"ОС/Планировщик-ОS","permalink":"https://goxpert.ru/categories/%D0%9E%D0%A1/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA-%D0%9ES/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Сеть","slug":"os/network","date":"2024-06-01T09:16:00.000Z","updated":"2024-06-02T19:47:14.277Z","comments":true,"path":"2024/06/01/os/network/","link":"","permalink":"https://goxpert.ru/2024/06/01/os/network/","excerpt":"","text":"Основные отличия TCP и UDP:Надёжность. TCP использует тайм-ауты, требует подтверждения получения данных и повторно отправляет данные при необходимости. У протокола UDP такого нет, а данные нередко теряются на этапе доставки к хосту-получателю. Упорядоченность. TCP гарантированно передаёт пакеты данных в той последовательности, которая была задана изначально. В UDP такие возможности не реализованы. Скорость. UDP значительно быстрее TCP. Метод передачи данных. TCP предполагает потоковую передачу данных, границы фрагментов данных не обозначены. UDP использует метод датаграмм, когда получатель проверяет целостность пакетов лишь при получении сообщения. TCP больше подходит для длительных сеансов, а UDP — для коротких. статья TCP vs UDP Современный мир завязан на системах связи, когда различные устройства «общаются» между собой посредством «правил», или протоколов модели OSI (Open Systems Interconnection model), определяющей методы взаимодействия. В тексте рассмотрим два самых популярных протокола транспортного уровня — TCP и UDP — и сравним их. Прежде всего напомним, что такое сетевые протоколы. Сетевые протоколы — это правила взаимодействия устройств в сети, благодаря которым различные девайсы могут работать друг с другом, несмотря на конструктивные различия. На транспортном уровне происходит прием данных с сетевого уровня и передача их на сеансовый уровень. TCP — протокол транспортного уровняПервым из рассматриваемых протоколов будет TCP, или Transmission Control Protocol, который используется для транспортировки сообщений между устройствами в сети. В сети файлы не передаются целиком, а дробятся и передаются в виде относительно небольших сообщений. Далее они передаются другому устройству — получателю, где повторно собираются в файл. Например, человек хочет скачать картинку. Сервер обрабатывает запрос и высылает в ответ требуемое изображение. Ему, в свою очередь, необходим путь или канал, по которому он будет передавать информацию. Поэтому сервер обращается к сетевому сокету для установки требуемого соединения и отправки картинки. Сервер дробит данные, инкапсулирует их в блоки, которые передаются на уровень TCP получателя при помощи IP-протокола. Далее получатель подтверждает факт передачи. У протокола TCP есть несколько особенностей: Система нумерации сегментов. TCP отслеживает передаваемые и принимаемые сегменты, присваивая номера каждому из них. Байтам данных, которые должны быть переданы, присваивается определенный номер байта, в то время как сегментам присваиваются порядковые номера. Управление потоком. Функция ограничивает скорость, с которой отправитель передает данные. Это делается для обеспечения надежности доставки, в том числе чтобы компьютер не генерировал пакетов больше, чем может принять другое устройство. Если говорить простым языком, то получатель постоянно сообщает отправителю о том, какой объем данных может быть получен. Контроль ошибок. Функция реализуется для повышения надежности путем проверки байтов на целостность. Контроль перегрузки сети. Протокол TCP учитывает уровень перегрузки в сети, определяемый объемом данных, отправленных узлом Примеры применения сетевого протокола TCPПротокол TCP гарантирует доставку, а также обеспечивает целостность данных, передаваемых в сети. Поэтому он применяется для передачи данных, которые чувствительны к нарушению целостности, — например, текстов, файлов и т.п. Вот несколько протоколов, которые работают по TCP: SSH, FTP, Telnet: в данных протоколах TCP используется для обмена файлами. SMTP, POP, IMAP: протоколы, где TCP отвечает за передачу сообщений электронной почты. HTTP/HTTPS: протоколы, где TCP отвечает за загрузку страниц из интернета.Эти примеры работают на уровне приложений стека TCP/IP и передают данные вниз к TCP, на транспортный уровень Строение протокола TCP В каждый пакет данных TCP добавляет заголовок общим объемом в 20 байт (или октетов), в котором содержатся 10 обязательных полей: Порт источника — порт устройства-отправителя. Порт назначения — порт принимающего устройства. Порядковый номер. Устройство, инициирующее TCP-соединение, должно выбрать случайный начальный порядковый номер, который затем увеличивается в соответствии с количеством переданных байтов. Номер подтверждения. Принимающее устройство увеличивает этот номер с нуля в соответствии с количеством полученных байтов. Сдвиг данных TCP. Данный параметр определяет размер заголовка, чтобы система могла понять, где начинаются данные. Зарезервированные данные — зарезервированное поле, значение которого всегда равно нулю. Флаги управления. TCP использует девять флагов для управления потоком данных в определенных ситуациях — например, при инициировании сброса сессии. Размер окна — самая важная часть заголовка TCP. Это поле используется получателем для указания отправителю объема данных, которые он может принять. Контрольная сумма. Отправитель генерирует контрольную сумму и передает ее в заголовке каждого пакета. Принимающее устройство может использовать контрольную сумму для проверки ошибок в полученном файле. Срочный указатель — это предлагаемая протоколом возможность помечать некоторые байты данных тегом «Срочно» для их пересылки и обработки вне очереди. Поле опции. Может использоваться для расширения протокола или его тестирования. Ускоряем работу протокола TCP при хорошем соединении или выжимаем максимумTCP используется при передаче данных в таких протоколах, как HTTP, Telnet, FTP, SMTP. При использовании протокола нужно учесть, что при увеличении потери пакетов время, затрачиваемое на доставку файла, увеличивается. Чтобы достичь максимальной пропускной способности TCP-соединения, можно выполнить следующие шаги: Увеличить размер окна. Размер окна, или TCP Window Size, — это количество данных, которое может быть передано в данный момент без подтверждения. Это значение устанавливается в начале соединения между устройствами. Однако это значение можно изменить заранее, введя команду regedit в поиске и перейдя по следующему пути: 1HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\AFD\\Parameters\\DefaultSendWindow Увеличение параметра приведет к тому, что уменьшится количество проверок полученных данных и увеличится эффективность использования полосы пропускания. Также, перейдя по пути: 1HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters можно добавить значение Tcp1323Opts, которое отвечает за изменение размера окна и управление временной меткой. Изменение значения SackOpts. SACK, или селективное подтверждение, крайне важно для подключений с большим размером окна. Без этой функции проверка полученных данных выполняется только по последнему номеру последовательности полученных данных. Но с включением этой функции появляется возможность подтверждать получение отдельных блоков. Чтобы изменить данный параметр, можно перейти по пути: 1HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters и выбрать параметр SackOpts. Изменение значения TcpMaxDupAcks. Данный параметр отвечает за количество полученных подтверждений о передаче. Стандартное значение состоит из одного подтверждения и двух дубликатов. Параметр можно изменить, перейдя по пути: 1HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters и выбрав TcpMaxDupAcks. Это позволит вам назначать количество требуемых подтверждений для запуска быстрой повторной передачи, что в результате скажется на скорости передачи данных. Стоит отметить, что данными манипуляциями выигрываются доли секунд, поэтому сильно прироста скорости вы не увидите. UDP — протокол транспортного уровняЕсли нам очень важна скорость передачи, а вот потеря пакетов не так критична (как, например, в голосовом или видеотрафике), то лучше использовать UDP, или User Datagram Protocol. В отличие от TCP он обеспечивает передачу данных без получения подтверждения от пользователя. Проще говоря, просто отправляет пакеты и не ждет ничего в ответ. Из-за этого достигается высокая скорость в ущерб надежности. Чаще всего UDP применяется в чувствительных ко времени службах, где потерять пакеты лучше, чем ждать. Звонки в Skype или Google Meet, стриминг видео, онлайн-трансляции используют этот протокол из-за того, что они чувствительны ко времени и рассчитаны на определенный уровень потерь. Вся голосовая связь через интернет работает по протоколу UDP. Также UDP очень часто используется в онлайн-играх. Аналогичная история с DNS-серверами, поскольку они должны быть быстрыми и эффективными. Примеры использования протокола UDPПримерами протоколов, использующих UDP-протокол, являются: DNS — протокол, преобразующий домены в IP-адреса, чтобы сделать возможной загрузку интернет-ресурса через браузер. SNMP — протокол, позволяющий системному администратору проводить мониторинг, контролировать производительность сети и изменять конфигурацию подключенных устройств. DHCP — протокол, отвечающий за автоматическое назначение IP-адреса клиенту. Разница между TCP и UDPКлючевым различием между TCP и UDP является скорость, поскольку TCP сравнительно медленнее UDP. В целом, UDP является быстрым, простым и эффективным протоколом, однако повторная передача потерянных пакетов данных возможна только в TCP. Еще одно заметное различие между TCP и UDP заключается в том, что первый обеспечивает упорядоченную доставку данных от пользователя к серверу (и наоборот). UDP, в свою очередь, не проверяет готовность получателя и может доставлять пакеты вразнобой. TCP vs UDPРассмотрим разницу характеристик протоколов TCP и UDP. TCP UDP Состояние соединения Требуется установленное соединение для передачи данных (соединение должно быть закрыто после завершения передачи) Протокол без соединения, без требований к открытию, поддержанию или прерыванию соединения Гарантия доставки Может гарантировать доставку данных получателю Не гарантирует доставку данных получателю Повторная передача данных Повторная передача нескольких кадров в случае потери одного из них Отсутствие повторной передачи потерянных пакетов Проверка ошибок Полная проверка ошибок Базовый механизм проверки ошибок. Использует вышестоящие протоколы для проверки целостности Метод передачи Данные считываются как поток байтов; сообщения передаются по границам сегментов UDP-пакеты с определенными границами; отправляются по отдельности и проверяются на целостность по прибытии Сферы применения Используется для передачи сообщений электронной почты, HTML-страниц браузеров Видеоконференции, потоковое вещание, DNS, VoIP, IPTV Отличия TCP и UDP при использовании в VPNТакже нередко возникает вопрос, касающийся использования данных протоколов при VPN-соединениях. К примеру, в OpenVPN существует возможность выбора между TCP- и UDP-протоколами. Условимся, что VPN заворачивает передаваемые данные в еще один протокол (на самом деле все намного сложнее). Если ваш VPN-туннель использует в качестве транспортного протокола TCP, то передача данных по UDP-протоколу теряет свои преимущества. Как минимум на определенном участке пути. Поэтому для VPN-туннеля советуют использовать UDP-протокол, ведь TCP будет штатно работать внутри UDP-туннеля. Итог сравнения протоколов TCP и UDPКаждый протокол хорош под свои задачи, недаром они являются одними из самых распространенных в интернете. В завершение сравнения TCP и UDP можно выделить, что TCP применяется там, где важно доставить все данные в определенном порядке. Зона применения UDP, в свою очередь, — это голосовой и видеотрафик, где доставка всех пакетов не является обязательной. Также серьезным отличием TCP от UDP является размер заголовков. У TCP он составляет 20-60 байт, а у UDP — всего 8 байт. Это показывает, насколько сложнее устроен протокол TCP, ведь он приоритизирует трафик и проверяет блоки данных на наличие ошибок.","categories":[{"name":"ОС","slug":"ОС","permalink":"https://goxpert.ru/categories/%D0%9E%D0%A1/"},{"name":"Cеть","slug":"ОС/Cеть","permalink":"https://goxpert.ru/categories/%D0%9E%D0%A1/C%D0%B5%D1%82%D1%8C/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"SOLID","slug":"common/solid","date":"2024-06-01T07:21:00.000Z","updated":"2024-06-04T07:11:53.955Z","comments":true,"path":"2024/06/01/common/solid/","link":"","permalink":"https://goxpert.ru/2024/06/01/common/solid/","excerpt":"","text":"Автор оригинала: Ugonna ThelmaСпециально для сына Георгия. Он только начинает свой путь в программировании и мне хочется на простых примерах донести ему суть происходящего. Если вы знакомы с объектно-ориентированным программированием, то наверняка слышали и о принципах SOLID. Эти пять правил разработки ПО задают траекторию, по которой нужно следовать, когда пишешь программы, чтобы их проще было масштабировать и поддерживать. Они получили известность благодаря программисту Роберту Мартину. В Сети множество отличных статей, где рассказывается о принципах SOLID, но иллюстрированных среди них мне практически не попадалось. Из-за этого таким людям со склонностью к визуальному восприятию информации – таким, как я – бывает сложно схватывать суть и не отвлекаться. Основная цель этой статьи – лучше усвоить принципы SOLID через отрисовку иллюстраций, а также определить назначение каждого принципа. Дело в том, что некоторые из принципов кажутся похожими, но функции выполняют разные. Может получиться так, что одному принципу следуешь, а другой при этом нарушаешь, хотя с виду особой разницы между ними нет. Чтобы проще читалось, я упоминаю здесь только классы, однако всё сказанное в статье применимо также к функциям, методам и модулям, так что имейте это в виду. Принципы SOLIDS – Single Responsibility (Принцип единственной ответственности) Каждый класс должен отвечать только за одну операцию. Если класс отвечает за несколько операций сразу, вероятность возникновения багов возрастает – внося изменения, касающиеся одной из операций вы, сами того не подозревая, можете затронуть и другие. НазначениеПринцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы. O — Open-Closed (Принцип открытости-закрытости) Классы должны быть открыты для расширения, но закрыты для модификации. Когда вы меняете текущее поведение класса, эти изменения сказываются на всех системах, работающих с данным классом. Если хотите, чтобы класс выполнял больше операций, то идеальный вариант – не заменять старые на новые, а добавлять новые к уже существующим. НазначениеПринцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс. L — Liskov Substitution (Принцип подстановки Барбары Лисков) Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, возникает риск появления ошибок. Если у вас имеется класс и вы создаете на его базе другой класс, исходный класс становится родителем, а новый – его потомком. Класс-потомок должен производить такие же операции, как и класс-родитель. Это называется наследственностью. Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. Или же результат может отличаться, но при этом относиться к тому же типу. На картинке это показано так: класс-родитель подаёт кофе (в любых видах), значит, для класса-потомка приемлемо подавать капучино (разновидность кофе), но неприемлемо подавать воду. Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от родителя и нарушает принцип. НазначениеПринцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы. I — Interface Segregation (Принцип разделения интерфейсов) Не следует ставить клиент в зависимость от методов, которые он не использует Когда классу приходится производить действия, не несущие никакой реальной пользы, это выливается в пустую трату ресурса, а в случае, если класс выполнять эти действия не способен, ведёт к возникновению багов. Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем. НазначениеПринцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше. D — Dependency Inversion (Принцип инверсии зависимостей) Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. Для начала объясню термины, которые здесь применяются, простыми словами. Модули (или классы) верхнего уровня = классы, которые выполняют операцию при помощи инструментаМодули (или классы) нижнего уровня = инструменты, которые нужны для выполнения операцийАбстракции – представляют интерфейс, соединяющий два классаДетали = специфические характеристики работы инструмента Согласно данному принципу, класс не должен соединяться с инструментом, который применяет для выполнения операции. Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом. Кроме того, принцип гласит, что ни интерфейс, ни класс, не обязаны вникать в специфику работы инструмента. Напротив, это инструмент должен подходить под требования интерфейса. Назначение Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов. Обобщая сказанное Мы разобрали все пять принципов и сформулировали для каждого назначение. Всё это призвано помочь вам писать код, который можно модифицировать, расширять и тестировать с минимумом проблем. Спасибо, что прочитали; надеюсь, вы получили не меньше удовольствия, чем я в процессе работы над статьёй.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"SOLID","slug":"Вопрос-Ответ/SOLID","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/SOLID/"},{"name":"SOLID","slug":"Golang/Старт/SOLID","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/SOLID/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Планировщик","slug":"concurrency/scheduler","date":"2024-06-01T07:19:00.000Z","updated":"2024-06-02T18:11:35.674Z","comments":true,"path":"2024/06/01/concurrency/scheduler/","link":"","permalink":"https://goxpert.ru/2024/06/01/concurrency/scheduler/","excerpt":"","text":"Как работает планировщик в Golang?Планировщик в Golang - это механизм, который отвечает за распределение и выполнение горутин (G) на логических процессорах (P), которые в свою очередь работают на физических потоках (M) операционной системы. Планировщик в Golang использует модель M:N, то есть может запускать произвольное количество горутин на произвольном количестве потоков. Горутина (G) - это легковесный поток выполнения, который может быть создан, переключен и уничтожен планировщиком Go без взаимодействия с операционной системой. Горутины занимают мало памяти и могут быть заспавнены в большом количестве. Горутины не привязаны к конкретному потоку или процессору, а могут динамически менять свой контекст выполнения. Логический процессор (P) - это абстракция, которая представляет собой ресурс, необходимый для выполнения горутин. Каждый P имеет свою локальную очередь (LRQ), в которой хранятся горутины, ожидающие запуска. Количество P обычно равно количеству ядер в системе, чтобы максимально использовать параллелизм. P не может выполнять горутину самостоятельно, а нуждается в M для этого. Физический поток (M) - это поток операционной системы, который может быть связан с P и выполнять горутину из LRQ. M может переключаться между разными P в зависимости от ситуации. Например, если M блокируется на системном вызове или операции ввода-вывода, он может быть отсоединен от P и заменен другим M. Также M может участвовать в процессе work stealing, когда он пытается украсть горутину из LRQ или глобальной очереди (GRQ) другого P. Планировщик Go использует алгоритм work stealing для балансировки нагрузки между P. Если LRQ одного P пуста, он может попытаться украсть горутину из LRQ или GRQ другого P. Это позволяет эффективно использовать ресурсы и избегать простоя. Источники: Habr Habr Backend Interview В чем разница между вытесняющим и кооперативным планировщиком?Вытесняющий планировщик - это такой планировщик, который может прервать выполнение текущей задачи в любой момент и передать управление другой задаче, если он посчитает это необходимым. Вытесняющий планировщик обычно использует таймер или другие прерывания, чтобы определить, когда нужно сменить задачу. Вытесняющий планировщик позволяет более эффективно распределять ресурсы между задачами и обеспечивать более высокую отзывчивость системы. Кооперативный планировщик - это такой планировщик, который не может прервать выполнение текущей задачи, пока она сама не отдаст управление. Кооперативный планировщик полагается на то, что задачи будут добровольно освобождать процессор, когда они закончат свою работу или будут ждать ввода-вывода. Кооперативный планировщик проще в реализации и потребляет меньше ресурсов, но он может привести к проблемам с производительностью и справедливостью, если одна из задач будет занимать процессор слишком долго. Если вы хотите узнать больше о том, в чем разница между вытесняющим и кооперативным планировщиком, вы можете посмотреть следующие источники: Планирование в Go: Часть II — Планировщик Go Разница между вытесняющим и невытесняющим планированием в операционных системах Упреждающее и невытесняющее планирование Какой тип планировщика в Golang?Планировщик в Golang - это вытесняющий планировщик с кооперативными элементами. Это означает, что он может прервать выполнение текущей горутины в любой момент и передать управление другой горутине, если он посчитает это необходимым, но он также полагается на то, что горутины будут добровольно освобождать процессор, когда они будут ждать ввода-вывода или блокироваться на каналах. Планировщик в Golang использует таймер или другие прерывания, чтобы определить, когда нужно сменить горутину, а также учитывает приоритеты и аффинность горутин к процессорам. Источники: Планирование в Go: Часть II — Планировщик Go Планирование в Go: Часть I — Планировщик ОС В планировщике до версии 1.15 какие операции приводят к переключению контекста горутин?В планировщике Golang до версии 1.15 переключение контекста горутин происходило только при выполнении следующих операций: Ожидание ввода-вывода (I/O), такого как чтение или запись в файл, сеть, канал или таймер. Блокировка на мьютексе (mutex) или другом примитиве синхронизации. Вызов функции runtime.Gosched, которая явно передает управление другой горутине. Вызов функции runtime.GC, которая запускает сборку мусора и приостанавливает все горутины. Вызов функции runtime.LockOSThread, которая привязывает горутину к одному системному потоку и не позволяет ей переключаться на другой. В версии 1.15 планировщик Golang стал вытесняющим, то есть он может прервать выполнение любой горутины, которая работает слишком долго, и передать управление другой горутине, если он посчитает это необходимым. Это улучшило отзывчивость и справедливость системы, а также уменьшило вероятность возникновения состояний гонки и взаимных блокировок. Можно ли руками переключить контекст горутины?В общем случае, нет, нельзя руками переключить контекст горутины, так как это делает планировщик Golang автоматически, когда он посчитает это необходимым. Однако, в некоторых редких случаях, можно руками переключить контекст горутины, используя низкоуровневые функции из пакета runtime, такие как runtime.Gopark и runtime.Goready, которые позволяют приостановить и возобновить горутину по собственному условию. Эти функции не рекомендуются для обычного использования, так как они могут привести к ошибкам и несовместимостям с планировщиком Golang. Источники: Планирование в Go: Часть II — Планировщик Go Планирование в Go: Часть I — Планировщик ОС Сколько потоков операционной системы мы можем создать?Количество потоков операционной системы, которые мы можем создать в Golang, зависит от нескольких факторов, таких как: Количество горутин (goroutines), которые мы запускаем в нашей программе. Количество процессоров или ядер на компьютере. По умолчанию Golang создает столько системных потоков, сколько доступно логических процессоров на компьютере, но это можно изменить с помощью переменной окружения GOMAXPROCS. Размер стека для каждого системного потока. Стек - это область памяти, которая используется для хранения локальных переменных, параметров и адресов возврата функций. Размер стека ограничивает количество системных потоков, которые могут быть созданы, так как память не бесконечна. Расскажи про глобальную и локальную очередиГлобальная и локальная очереди в Golang - это структуры данных, которые используются планировщиком Go для распределения горутин между логическими процессорами (P). Горутина - это легковесный поток выполнения, который может быть переключен планировщиком без блокировки операционной системы. Глобальная очередь выполнения (GRQ) содержит горутины, которые еще не были назначены ни одному логическому процессору. Когда логический процессор создается или освобождается, он может взять горутину из GRQ и поместить ее в свою локальную очередь выполнения (LRQ). LRQ содержит горутины, которые принадлежат конкретному логическому процессору и ожидают своего запуска. Планировщик Go использует алгоритм work stealing для балансировки нагрузки между логическими процессорами. Если LRQ одного логического процессора пуста, он может попытаться украсть горутину из LRQ другого логического процессора или из GRQ. Это позволяет эффективно использовать ресурсы и избегать простоя. Источники: Habr Habr Может ли горутина начать работу на одном P, приостановиться и продолжить работу на другом P?Да, горутина может переключаться между разными логическими процессорами (P) во время своей работы. Это может произойти по нескольким причинам, например: Горутина блокируется на операции ввода-вывода или системном вызове, и планировщик Go переназначает ее P другой горутине. Горутина добровольно отступает от своего P, вызывая функцию yield или resume, которые позволяют использовать корутины в Go. Горутина истекает свой квант времени, и планировщик Go прерывает ее выполнение и переводит ее в конец своей локальной очереди (LRQ). Горутина становится жертвой work stealing, когда другой P, у которого пустая LRQ, пытается украсть горутину из LRQ или глобальной очереди (GRQ) другого P. Таким образом, горутины в Go не привязаны к конкретному P на всю свою жизнь, а могут динамически менять свой контекст выполнения в зависимости от ситуации. Это повышает эффективность и отзывчивость приложений, написанных на Go. Источники: Habr Habr Habr Может ли одна очередь украсть горутины у другой?Да, одна очередь может украсть горутины у другой в процессе work stealing. Это алгоритм, который позволяет планировщику Go балансировать нагрузку между логическими процессорами (P). Когда один P имеет пустую локальную очередь (LRQ), он может попытаться украсть горутину из LRQ или глобальной очереди (GRQ) другого P. Это увеличивает вероятность того, что каждый P будет иметь работу, и избегает простоя. В чем профит горутин, если мы можем заспавнить миллион потоков в процессе, и почему упадет процесс с таким количеством потоков, или нет?Профит горутин в том, что они легковеснее и эффективнее обычных потоков. Горутины занимают меньше памяти (порядка килобайтов), чем потоки (порядка мегабайтов), и могут динамически расти и уменьшаться в зависимости от потребностей. Горутины также имеют меньший оверхед на создание, переключение и уничтожение, чем потоки, которые требуют взаимодействия с операционной системой. Если мы попытаемся заспавнить миллион потоков в процессе, то скорее всего процесс упадет из-за нехватки памяти или ресурсов. Каждый поток требует выделения стека, регистров, дескрипторов и других ресурсов, которые ограничены операционной системой. Кроме того, большое количество потоков приводит к частому переключению контекста, которое снижает производительность и увеличивает задержки. В отличие от потоков, горутины могут быть заспавнены в большом количестве без существенных потерь производительности и памяти. Планировщик Go оптимально распределяет горутины между логическими процессорами (P), используя глобальную и локальные очереди, а также алгоритм work stealing. Таким образом, горутины позволяют писать высокопроизводительные и масштабируемые приложения на Go.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Планировщик","slug":"Вопрос-Ответ/Планировщик","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"},{"name":"Планировщик","slug":"Golang/Старт/Планировщик","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Контекст","slug":"concurrency/context","date":"2024-06-01T07:18:00.000Z","updated":"2024-06-02T18:08:23.259Z","comments":true,"path":"2024/06/01/concurrency/context/","link":"","permalink":"https://goxpert.ru/2024/06/01/concurrency/context/","excerpt":"","text":"Что такое контекст?В Go, контекст (context) используется для передачи сигналов относительно отмены операций, таймаутов и передачи метаданных между API. Это особенно полезно в ситуациях, когда у вас есть множество горутин и вы хотите контролировать их выполнение. В Go есть пакет context, который предоставляет функции и типы для работы с контекстами. Вы можете создать контекст с помощью функций context.Background() или context.TODO(). Затем вы можете создать дочерний контекст с помощью функций context.WithCancel(), context.WithDeadline(), context.WithTimeout(), или context.WithValue(). Когда контекст отменяется, все горутины, которые получают этот контекст, получают сигнал об отмене, и они должны прекратить свою работу. Для чего используется контекст?Контекст в Go используется для нескольких целей: Отмена операций: Контекст может быть использован для отмены операций. Это особенно полезно, когда у вас есть долгосрочная операция, которая может быть отменена в любой момент. Когда контекст отменяется, все горутины, которые получают этот контекст, получают сигнал об отмене. Таймауты: Контекст также может быть использован для установки таймаутов на операции. Это может быть полезно, когда вы хотите ограничить время выполнения операции. Передача метаданных: Контекст может быть использован для передачи метаданных между API. Это может быть полезно, когда у вас есть информация, которую нужно передать между различными частями вашего приложения, например, информация о трассировке. Контроль над горутинами: Контекст позволяет контролировать выполнение горутин, особенно когда у вас есть множество горутин и вы хотите контролировать их выполнение. Какие есть виды контекстов? Background: Это базовый контекст, который обычно используется, когда другой контекст не доступен. Это обычно используется в main функции, в тестах и в пакетах, которые не знают, в каком контексте они будут использоваться. Создается с помощью функции context.Background(). TODO: Этот контекст также используется, когда контекст не доступен. Он обычно используется, когда не ясно, какой контекст использовать, или когда контекст будет доступен в будущем. Создается с помощью функции context.TODO(). WithCancel: Этот контекст предоставляет возможность отмены. Когда функция cancel вызывается, все горутины, которые слушают этот контекст, получают сигнал об отмене. Создается с помощью функции context.WithCancel(parentContext). WithDeadline и WithTimeout: Эти контексты предоставляют возможность установить время, после которого контекст будет автоматически отменен. WithDeadline принимает конкретное время, после которого контекст будет отменен, а WithTimeout принимает продолжительность времени, после которой контекст будет отменен. Создаются с помощью функций context.WithDeadline(parentContext, deadline) и context.WithTimeout(parentContext, timeout) соответственно. WithValue: Этот контекст предоставляет возможность связать значения с контекстом, которые затем могут быть извлечены в другом месте в коде. Создается с помощью функции context.WithValue(parentContext, key, value). Как устроен контекст?Контекст в Go устроен как древовидная структура, где каждый контекст может иметь одного родителя и множество дочерних элементов. Когда создается новый контекст с помощью функций WithCancel, WithDeadline, WithTimeout или WithValue, он наследует все свойства своего родительского контекста. Внутри, контекст представляет собой интерфейс с несколькими методами: Deadline() (deadline time.Time, ok bool): Возвращает время, когда работа должна быть завершена. Второе возвращаемое значение ok показывает, был ли установлен крайний срок. Done() &lt;-chan struct&#123;&#125;: Возвращает канал, который будет закрыт, когда работа должна быть отменена. Если канал закрыт, то Err() вернет не nil. Err() error: Возвращает ошибку, которая описывает причину завершения контекста. Это может быть context.Canceled или context.DeadlineExceeded. Value(key interface&#123;&#125;) interface&#123;&#125;: Возвращает значение, связанное с ключом. Если ключа нет, возвращается nil. Когда контекст отменяется, все его дочерние контексты также отменяются. Это позволяет управлять группами горутин, которые выполняют связанные задачи. Если одна задача отменяется, все связанные задачи также отменяются Как работает WithCancel?Функция WithCancel из пакета context в Go создает новый контекст из существующего (родительского) контекста, который может быть отменен. Эта функция возвращает новый контекст и функцию cancel, которую можно вызвать, чтобы отменить контекст. Вот как это работает: 1ctx, cancel := context.WithCancel(parentCtx) Здесь ctx - это новый контекст, который наследует все свойства от parentCtx, и cancel - это функция, которую можно вызвать, чтобы отменить ctx и все контексты, производные от ctx. Когда функция cancel вызывается, канал Done контекста ctx закрывается. Все горутины, которые слушают канал Done, могут проверить его закрытие, чтобы узнать, был ли контекст отменен. Важно всегда вызывать cancel в defer (или когда контекст больше не нужен), чтобы освободить ресурсы, связанные с контекстом. Если cancel не вызывается, то может произойти утечка ресурсов. 1defer cancel() // Make sure to cancel when done with context Перекидывали логгер в контексте?Передача логгера через контекст - это тема, которая вызывает много дискуссий в сообществе Go. Вот некоторые аргументы “за” и “против”: За: Простота: Передача логгера через контекст может упростить API, так как вам не нужно передавать логгер в каждую функцию. Передача метаданных: Если вы используете структурированное логирование, вы можете добавить метаданные (например, ID запроса) в логгер, который затем передается через контекст. Это позволяет автоматически включать эти метаданные во все сообщения лога. Против: Неявность: Передача логгера через контекст делает его неявным. Это может затруднить понимание того, откуда идут сообщения лога. Неправильное использование контекста: Документация Go говорит, что контекст должен использоваться для передачи данных, которые должны быть доступны в течение жизненного цикла запроса, а не для передачи опциональных параметров функции. Некоторые люди считают, что передача логгера через контекст - это злоупотребление контекстом. Проблемы с производительностью: Создание нового контекста для каждого запроса с логгером может привести к увеличению накладных расходов и использованию памяти. В конечном итоге, решение о том, передавать ли логгер через контекст, зависит от конкретных требований вашего приложения и вашего стиля программирования.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Контекст","slug":"Вопрос-Ответ/Контекст","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82/"},{"name":"Контекст","slug":"Golang/Старт/Контекст","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Путь от кооператива до вытеснения","slug":"concurrency/stw","date":"2024-06-01T07:18:00.000Z","updated":"2024-06-03T11:05:45.760Z","comments":true,"path":"2024/06/01/concurrency/stw/","link":"","permalink":"https://goxpert.ru/2024/06/01/concurrency/stw/","excerpt":"","text":"Для начала “терминология”: Stop The World (STW) — это пауза в выполнении программы в Golang, необходимая для корректной работы сборщика мусора. STW может негативно влиять на производительность приложений. Для уменьшения его влияния в языке используется алгоритм трёхцветной маркировки, который окрашивает объекты в чёрный, серый или белый цвет в стадии разметки. 12345678910111213141516SA:Добрый день, Дмитрийвсе еще интереснеедо версии 1.14 у Го была чисто кооперативная многозадачностьа с версии 1.14 она стала гибридная: кооперативная с элементом вытесняющейDmitry Sigaev:Ясно, спасибоSA:и тут интересно соотношение кооперативности и вытестнения.В каких условиях начинает проявляться вытесняющий механизм, сколько он стоит, и насколько хорошо распределяет процессор между горутинамии особенно интересное: в каких условиях вытестняющий механизм НЕ применяетсяDmitry Sigaev:Хорошо, разберусь и расскажу Что нужно изучитьProposal: Non-cooperative goroutine preemption(Некооперативное вытеснение для goroutine) Статья обсуждает проблемы с небезопасными точками в Go и предлагает альтернативы для их решения. Небезопасные точки могут вызывать проблемы с выживаемостью, перемещением стека и сложными альтернативами. Предлагается отказаться от небезопасных точек и повторить попытку позже, когда программа будет готова. Обсуждаются общие последствия использования сигналов для вытеснения запущенной программы. Предлагаются альтернативы для сигнализируемого вытеснения, включая нацеливание на определенные потоки и возобновление выполнения. Обсуждаются проблемы, связанные с одноступенчатыми переходами и переписыванием кода для перехода в безопасную точку. Предлагаются альтернативные подходы, такие как использование аппаратной одноступенчатой поддержки и переписывание следующей инструкции по прыжку в безопасную точку. Устранение недостатков асинхронного вытеснения В Go 1.14 введено асинхронное вытеснение, чтобы можно было вытеснять узкие циклы (# 10958). Однако все еще есть несколько незаконченных концов, которые нужно связать. Это общая ошибка для отслеживания оставшейся работы: Длительные паузы STW (завершение этапа “подметания” sweep) при выделении массивного блока long pauses STW (sweep termination) on massive block allocation Аннотация (Abstract)В настоящее время Go использует вставленные компилятором точки вытеснения сотрудничества в прологах функций. В большинстве случаев этого достаточно, чтобы позволить разработчикам Go игнорировать preemption и сосредоточиться на написании четкого параллельного кода, но у него есть острые углы, которые, как мы видели, снова и снова ухудшают опыт разработчиков. Когда что-то идет не так, все идет совершенно неправильно, что приводит к загадочным проблемам с задержкой в системе, а иногда и к полному зависанию. И поскольку это проблема языковой реализации, которая существует вне языковой семантики Go, эти сбои неожиданны и их очень трудно отладить. @dr2chase приложил значительные усилия для создания прототипов точек вытеснения кооперативов в циклах, что является одним из способов решения этой проблемы. Однако даже сложные подходы к этому приводили к неприемлемым замедлениям в узких циклах (где замедления, как правило, наименее приемлемы). Я предлагаю, чтобы реализация Go переключилась на вытеснение без сотрудничества, что позволило бы вытеснять программы практически в любой момент без необходимости явных проверок вытеснения. Такой подход решит проблему отложенного вытеснения и сделает это с нулевыми затратами времени выполнения. Некооперативное упреждение - это общая концепция с целым классом методов реализации. В этом документе описывается и мотивируется переход на некооперативное преимущественное использование и обсуждаются общие проблемы любого некооперативного подхода к преимущественному использованию в Go. Конкретные подходы к реализации подробно описаны во вложенных предложениях, связанных с этим документом. Справочная информация (Background)До Go 1.10 включительно Go использовала совместное вытеснение с безопасными точками только при вызовах функций (и даже тогда, если функция маленькая или встроена). Это означает, что Go может переключаться между программами, выполняющимися одновременно, только в определенных точках. Основное преимущество этого заключается в том, что компилятор может гарантировать полезные инварианты в этих безопасных точках. В частности, компилятор гарантирует, что все локальные корни сборки мусора известны во всех безопасных точках, что критически важно для точной сборки мусора. Он также может гарантировать, что никакие регистры не будут активированы в безопасных точках, что означает, что среда выполнения Go может переключать подпрограммы без необходимости сохранять и восстанавливать большой набор регистров. Однако это может привести к нечастым безопасным точкам, что приводит ко многим проблемам: Наиболее распространенным в производственном коде является то, что это может задерживать операции STW, такие как запуск и завершение цикла GC. Это увеличивает задержку STW и при большом количестве ядер может существенно повлиять на пропускную способность (если, например, большинство потоков остановлено, пока среда выполнения ожидает отставшего в течение длительного времени). (#17831, #19241) Это может задержать планирование, не позволяя конкурирующим программам выполняться своевременно. Это может задержать сканирование стека, которое потребляет центральный процессор, пока среда выполнения ожидает точки вытеснения, и в конечном итоге может задержать завершение GC, что приводит к эффективному STW, когда в системе заканчивается куча и никакие программы не могут ее выделить. В действительно экстремальных случаях это может привести к остановке программы, например, когда подпрограмма, работающая на атомной нагрузке, истощает подпрограмму, ответственную за настройку этой атомной нагрузки. Это часто указывает на плохой или глючный код, но, тем не менее, удивительно и явно отняло у разработчика много времени на отладку. (#543, #12553, #13546, #14561, #15442, #17174, #20793, #21053) Эти проблемы снижают производительность разработчиков и эффективность производства и знакомят пользователей Go с деталями реализации, о которых им не следует беспокоиться. Преимущественное использование кооперативного цикла (Cooperative loop preemption)@dr2chase приложил значительные усилия, пытаясь решить эти проблемы с помощью кооперативного вытеснения цикла (# 10958). Это стандартный подход для сред выполнения, использующих совместное вытеснение, при котором компилятор вставляет проверки вытеснения и безопасные точки на задних ребрах графа потока. Это значительно улучшает качество вытеснения, поскольку код почти никогда не выполняется без поддержки в течение какого-либо нетривиального периода времени. Наш самый последний подход к вытеснению циклов, который мы называем вытеснение на основе сбоев, добавляет единую инструкцию, без ветвей и давления регистра на циклы на платформах x86 и UNIX (CL 43050). Несмотря на это, геометрическое замедление по большому набору тестов составляет 7,8%, с несколькими значительно худшими выбросами. Даже по сравнению с Go 1.9, где замедление составляет всего 1% благодаря другим улучшениям, в большинстве тестов наблюдается некоторое замедление, и все еще наблюдаются значительные отклонения. Вытеснение на основе ошибок также имеет несколько недостатков реализации. Оно не может быть нацелено на определенные потоки или подпрограммы, поэтому плохо подходит для сканирования стека, неровных барьеров или вытеснения обычного планировщика. Это также “залипание” в том смысле, что мы не можем возобновить какие-либо циклы, пока не возобновим все циклы, поэтому безопасная точка не может просто возобновиться, если это происходит в небезопасном состоянии (например, когда удерживаются блокировки во время выполнения). Требуется больше инструкций (и больше накладных расходов) на платформах, отличных от x86 и UNIX. Наконец, это мешает работе отладчиков, которые предполагают, что плохие ссылки на память являются веской причиной для остановки программы. Неясно, может ли оно вообще работать во многих отладчиках OS X из-за ошибки ядра. Некооперативное вытеснение (Non-cooperative preemption)Некооперативное вытеснение переключается между контекстами параллельного выполнения без явных проверок вытеснения или помощи со стороны этих контекстов. Это используется всеми современными настольными и серверными операционными системами для переключения между потоками. Без этого одно приложение с плохим поведением может заклинить всю систему, подобно тому, как одна программа с плохим поведением в настоящее время может заклинить приложение Go. Это также удобная абстракция: она позволяет нам программировать так, как будто доступно бесконечное количество процессоров, скрывая тот факт, что ОС выполняет временное мультиплексирование конечного числа процессоров. Планировщики операционной системы используют поддержку аппаратных прерываний для переключения запущенного потока в планировщик ОС, который может сохранять состояние этого потока, например, его регистры процессора, чтобы его можно было возобновить позже. В Go мы бы использовали поддержку операционной системы, чтобы сделать то же самое. В UNIX-подобных операционных системах это можно сделать с помощью сигналов. Однако из-за сборщика мусора у Go есть требования, которых нет у операционной системы: Go должен иметь возможность находить текущие указатели в стеке goroutine, где бы он ее ни останавливал. Большая часть сложности отказа от сотрудничества в Go проистекает из этого требования. ПредложениеВ статье предлагается в Go реализовать вытеснение некооперативной подпрограммы, отправив сигнал POSIX (или используя эквивалентный механизм операционной системы), чтобы остановить запущенную программу goroutine и зафиксировать состояние ее процессора. Если подпрограмма прерывается в точке, которая должна быть GC atomic, как подробно описано в разделе “Обработка небезопасных точек”, среда выполнения может просто возобновить работу подпрограммы и повторить попытку позже. Основная сложность реализации вытеснения без сотрудничества для Go заключается в поиске активных указателей в стеке вытесняемой подпрограммы. Существует множество возможных способов сделать это, которые подробно описаны в этих подпредложениях: В предложении с безопасными точками везде описывается реализация, в которой компилятор записывает карты стека и регистра практически для каждой инструкции. Это позволяет среде выполнения останавливать goroutine в любом месте и находить ее корни GC. В предложении по консервативному сканированию внутреннего фрейма описывается реализация, которая использует консервативные методы GC для поиска указателей в самом внутреннем фрейме стека вытесняемой подпрограммы goroutine. Это можно сделать без каких-либо дополнительных метаданных безопасной точки. Обработка небезопасных точек (Handling unsafe-points)Любой некооперативный подход вытеснения в Go должен иметь дело с кодовыми последовательностями, которые должны быть атомарными по отношению к сборщику мусора. Мы называем их “небезопасными точками”, в отличие от безопасных точек GC. Несколько известных ситуаций: Выражения, включающие unsafe.Pointer, могут временно представлять единственный указатель на объект как uintptr. Следовательно, не должно быть безопасных точек, пока a uintptr производный от an unsafe.Pointer активен. Аналогично, мы должны распознавать преобразования reflect.Value.Pointer, reflect.Value.UnsafeAddr и reflect.Value.InterfaceData как unsafe.Pointerвuintptr. В качестве альтернативы, если компилятор может надежно обнаружить такие uintptrы, он может пометить их как указатели, но есть опасность, что промежуточное значение может не представлять допустимое значение указателя. В барьере записи(write barrier) не должно быть безопасной точки между проверкой с включенным барьером записи и прямой записью. Например, предположим, что goroutine записывает указатель на B в объект A. Если проверка произойдет, то GC запустится и просканирует A, затем goroutine запишет B в A и удалит все ссылки на B из своего стека, сборщик мусора может не отметить B. Есть места, где компилятор генерирует временные указатели, которые могут находиться за пределами конца выделения, например, в циклах диапазона над фрагментами и массивами. Этих действий следует либо избегать, либо запретить использование безопасных точек, пока они действуют. Во всех этих случаях уже должно быть исключено существенное изменение порядка, чтобы избежать разделения по вызову. Внутренне это достигается с помощью псевдозначения “mem”, которое должно последовательно передаваться через все значения SSA, которые манипулируют памятью. Mem также передается через значения, которые нельзя изменять, даже если они не затрагивают память. Например, преобразование между unsafe.Pointer и uintptr выполняется с помощью специальной операции “Преобразовать”, которая использует mem исключительно для ограничения изменения порядка. Существует несколько возможных решений этой проблемы, некоторые из которых можно комбинировать: Мы могли бы отметить базовые блоки, которые не должны содержать точек вытеснения. Для unsafe.Pointer преобразований мы бы отказались от базового блока, содержащего преобразование. Для кода, соответствующего unsafe.Pointer правилам, этого должно быть достаточно, но это может привести к поломке кода, который является некорректным, но, как оказалось, работает сегодня способами, которые очень трудно отлаживать. Для барьеров записи этого также достаточно. Для циклов это слишком широко и потребует разделения некоторых базовых блоков. Для unsafe.Pointer преобразований мы могли бы просто отказаться от целых функций, которые преобразуют из unsafe.Pointer в uintptr. Это было бы легко реализовать, и даже неисправный небезопасный код продолжал бы работать так же хорошо, как сегодня, но может иметь широкое влияние, особенно при наличии встраивания. Простой комбинацией 1 и 2 было бы отказаться от любого базового блока, который достижим от преобразования unsafe.Pointer в uintptr, вплоть до вызова функции (что сегодня является безопасной точкой). Для циклов диапазона компилятор мог бы скомпилировать их по-другому, чтобы он никогда не создавал указатель, выходящий за пределы (см. Ниже). Гораздо более точным и общим подходом (благодаря @cherrymui) было бы создание новых операций SSA, которые “загрязняют” и “не загрязняют” память. Операция заражения возьмет mem и вернет новый поврежденный mem. Это заражение будет распространяться на любые значения, которые сами принимают поврежденное значение. Незапятнанная операция примет значение и mem и вернет незапятнанное значение и незапятнанный mem. Во время анализа жизнеспособности безопасные точки будут запрещены везде, где действовало испорченное значение. Это, вероятно, наиболее точное решение, которое, вероятно, сохранит даже неправильное использование unsafe working, но требует сложной реализации. В более широком смысле, стоит подумать о том, чтобы заставить компилятор проверять код, использующий unsafe.Pointer, и активно отклонять код, который не соответствует разрешенным шаблонам. Это можно было бы реализовать как простую систему типов, которая отличает указатель uintptr от числового uintptr. Но это выходит за рамки данного предложения. Циклы диапазона (Range loops)Начиная с версии 1.10, циклы диапазона составляются примерно так: 123456789101112for i, x := range s &#123; b &#125; ⇓for i, _n, _p := 0, len(s), &amp;s[0]; i &lt; _n; i, _p = i+1, _p + unsafe.Sizeof(s[0]) &#123; b &#125; ⇓i, _n, _p := 0, len(s), &amp;s[0]goto condbody:&#123; b &#125;i, _p = i+1, _p + unsafe.Sizeof(s[0])cond:if i &lt; _n &#123; goto body &#125; else &#123; goto end &#125;end: Проблема с этим понижением заключается в том, что _p может временно превышать конец распределения за момент до завершения цикла. В настоящее время это безопасно, потому что никогда не существует безопасной точки, пока это значение _p действует. Это уменьшение требует, чтобы компилятор пометил блоки increment и condition как небезопасные точки. Однако, если тело короткое, это может привести к нечастым безопасным точкам. Это также требует создания отдельного блока для приращения, который в настоящее время обычно добавляется в конец основного текста. Разделение этих блоков ограничило бы возможности изменения порядка. При подготовке к вытеснению без сотрудничества в Go 1.11 была начата компиляция циклов диапазона следующим образом, чтобы избежать создания указателя, переходящего в конец: 123456789i, _n, _p := 0, len(s), &amp;s[0]if i &gt;= _n &#123; goto end &#125; else &#123; goto body &#125;top:_p += unsafe.Sizeof(s[0])body:&#123; b &#125;i++if i &gt;= _n &#123; goto end &#125; else &#123; goto top &#125;end: Это позволяет использовать безопасные точки повсюду в цикле. По сравнению с исходной компиляцией цикла, он генерирует немного больше кода, но выполняет то же количество инструкций условного перехода (n + 1) и приводит к тому же количеству базовых блоков SSA (3). Это снижение усложняет устранение проверки границ. В Go 1.10 устранение проверки границ знало об этом i &lt; _n в теле, потому что в блоке body доминирует блок cond. Однако в новом понижении для получения этого факта потребовалось определить, что i &lt; _n на обоих путях в тело и, следовательно, верно в теле. Безопасные точки выполнения (Runtime safe-points)Помимо сгенерированного кода, среда выполнения в целом не предназначена для произвольного вытеснения, и есть много мест, которые не должны вытесняться. Следовательно, мы, вероятно, отключили бы безопасные точки по умолчанию во время выполнения, за исключением вызовов (где они происходят сейчас). Хотя это имело бы небольшие недостатки для большей части среды выполнения, есть некоторые части среды выполнения, которые могли бы существенно выиграть от вытеснения без сотрудничества, например, функции памяти, такие как memmove. Вытеснение без сотрудничества - отличный способ сделать их вытесняемыми без замедления общего случая, поскольку нам нужно было бы только пометить их карты регистров (которые часто были бы пустыми для функций типа memmove, поскольку все указатели уже были бы защищены аргументами). Со временем мы можем использовать больше времени выполнения. Небезопасный код стандартной библиотеки (Unsafe standard library code)Пакет системного вызова Windows содержит множество unsafe.Pointer преобразований, которые не соответствуют unsafe.Pointer правилам. В целом он делает шаткие предположения о поведении безопасной точки, жизнеспособности и о том, когда может произойти перемещение стека. Вероятно, потребуется тщательный аудит или от него придется отказаться, как от среды выполнения. Возможно, более тревожным является то, что некоторые типы пакетов системного вызова Windows имеют поля uintptr, которые на самом деле являются указателями, следовательно, вынуждая вызывающих выполнять небезопасные преобразования указателей. Например, смотрите Выпуск #21376 . Обеспечение прогресса с небезопасными точками (Ensuring progress with unsafe-points)Мы предлагаем просто сдаться и повторить попытку позже, когда подпрограмма прерывается в небезопасной точке. Одна из опасностей этого заключается в том, что безопасные точки могут быть редкими в узких циклах. Однако во многих случаях существуют более сложные альтернативы этому подходу. При прерываниях во время выполнения или в функциях без каких-либо безопасных точек (таких как сборка) обработчик сигналов может размотать стек и вставить возвратный трамплин при следующем возврате к функции с метаданными безопасных точек. В этом случае среда выполнения могла бы позволить goroutine продолжить работу, и trampoline приостановил бы ее как можно скорее. Для барьеров записи и unsafe.Pointer последовательностей компилятор мог бы вставить дешевую, явную проверку вытеснения в конце последовательности. Например, среда выполнения может изменить некоторый регистр, который будет проверяться в конце последовательности, и позволить потоку продолжить выполнение. В последовательности с барьером записи это может быть даже регистр, в который был загружен флаг с барьером записи, и компилятор может вставить простой тестовый регистр и условную ветвь в конце последовательности. Чтобы еще больше сократить последовательность, среда выполнения могла бы поместить адрес функции stop в этот регистр, чтобы последовательность stop была просто вызовом регистра и переходом. Альтернативы этой проверке включают прямое и обратное моделирование. Прямое моделирование сложно, потому что компилятор должен быть осторожен, чтобы генерировать только операции, которые среда выполнения знает, как имитировать. Обратное моделирование легко, если компилятор всегда может сгенерировать перезапускаемую последовательность (просто верните компьютер к проверке флага ограничения записи), но быстро усложняется, если в последовательности выполняется несколько операций записи или более сложные операции записи, такие как DUFFCOPY. Другие соображения (Other considerations)Все предлагаемые подходы к вытеснению без сотрудничества включают остановку запущенной подпрограммы путем отправки ее потоку сигнала операционной системы. В этом разделе обсуждаются общие последствия этого. Поддержка Windows. В отличие от вытеснения цикла на основе сбоя, сигнальное вытеснение довольно легко поддерживать в Windows, потому что оно предоставляет SuspendThread и GetThreadContext, которые упрощают получение набора регистров потока. Выбор сигнала. Мы должны выбрать сигнал, который вряд ли будет мешать существующему использованию сигналов или отладчикам. Идеального выбора не существует, но есть некоторые эвристические приемы. Это должен быть сигнал, который по умолчанию передается отладчиками. В Linux это SIGALRM, SIGURG, SIGCHLD, SIGIO, SIGVTALRM, SIGPROF и SIGWINCH, плюс некоторые сигналы glibc-internal. Он не должен использоваться libc внутри в смешанных двоичных файлах Go / C, потому что libc может предположить, что это единственное, что может обрабатывать эти сигналы. Например, SIGCANCEL или SIGSETXID . Это должен быть сигнал, который может произойти непреднамеренно без последствий. Например, SIGALRM - плохой выбор, потому что обработчик сигнала не может определить, было ли это вызвано реальным сигналом тревоги процесса или нет (возможно, это означает, что сигнал нарушен, но я отвлекся). SIGUSR1 и SIGUSR2 также плохи, потому что они часто используются приложениями значимыми способами. Нам нужно иметь дело с платформами без сигналов реального времени (например, macOS), поэтому они исключены.Мы используем SIGURG, потому что он соответствует всем этим критериям, крайне маловероятно, что он будет использоваться приложением в его “реальном” значении (как потому, что внеполосные данные в основном не используются, так и потому, что SIGURG не сообщает, у какого сокета есть условие, что делает его довольно бесполезным), и даже если это так, приложение должно быть готово к ложному SIGURG. SIGIO тоже был бы неплохим выбором, но, скорее всего, его будут использовать по-настоящему. Преимущественное использование планировщика. Этот механизм хорошо подходит для временных вытеснений, когда одна и та же подпрограмма возобновляется после вытеснения, потому что нам не нужно сохранять полное состояние регистра и мы можем полагаться на существующий путь возврата сигнала для восстановления полного состояния регистра. Это применимо ко всем вытеснениям, связанным с GC, но не так хорошо подходит для постоянного вытеснения, выполняемого планировщиком. Тем не менее, мы все равно могли бы использовать этот механизм. Например, поскольку большую часть времени goroutines самостоятельно вытесняют сигнал, нам нужно сохранить полное состояние сигнала только в необычном случае, поэтому g может содержать указатель на его полное сохраненное состояние, которое используется только после принудительного вытеснения. Восстановление полного состояния сигнала может быть выполнено либо путем написания зависящего от архитектуры кода для восстановления полного набора регистров (усиленного runtime.gogo), либо путем самосигнализации, замены в желаемом контексте и предоставления ОС возможности восстановить полный набор регистров. Нацеливание и возобновление. В отличие от прерывания цикла на основе сбоя, сигнальное прерывание может быть нацелено на определенный поток и может немедленно возобновиться. Нацеливание на потоки немного отличается от совместного вытеснения, которое ориентировано на горутины. Однако во многих случаях это на самом деле лучше, поскольку нацеливание программ на вытеснение является пикантным и, следовательно, требует циклов повторных попыток, которые могут значительно увеличить время STW. Использование этого для сканирования стека потребует некоторой реструктуризации того, как мы отслеживаем корни GC, но результат должен устранить блокирующий цикл повторных попыток, который мы используем в настоящее время. Указатели без указателей. Это может привести к некорректному использованию unsafe.Pointer для временного хранения указателей без указателей. Такое использование является явным нарушением unsafe.Pointer правил, но оно может иметь место (особенно, например, в коде, использующем cgo). Альтернативы (Alternatives)Одноступенчатый (Single-stepping)Вместо того, чтобы прилагать усилия для остановки на любой инструкции, компилятор мог бы выдавать метаданные для безопасных точек только на обратных фронтах, а среда выполнения могла бы использовать аппаратную поддержку одношагового перехода для продвижения потока к безопасной точке (или точке, где компилятор предоставил ответвление для достижения безопасной точки, как в текущем подходе с вытеснением цикла). Это работает (несколько неожиданно), но полностью сбивает с толку отладчики, поскольку и отладчик, и операционная система предполагают, что отладчик владеет single-stepping , а не самим процессом. Это также потребовало бы от компилятора предоставления заглушек для очистки регистров для этих безопасных точек, что увеличивает размер кода (и, следовательно, объем кэша инструкций), а также размер стека, во многом подобно вытеснению кооперативного цикла. Однако, в отличие от вытеснения кооперативного цикла, этот подход никак не повлияет на размер или производительность основного кода. Быстрое переписывание (Jump rewriting)Мы можем решить проблемы одношагового выполнения, вместо этого переписав следующую инструкцию перехода к безопасной точке после точки прерывания, чтобы перейти к пути упреждающего выполнения и возобновить выполнение как обычно. Чтобы упростить это, компилятор мог бы оставить достаточно места (с помощью NOPS заполнения), поэтому необходимо изменить только цель перехода. Этот подход имеет обычные недостатки изменяемого кода. Это угроза безопасности, он нарушает совместное использование текстовых страниц и просто не разрешен в iOS. Он также не может быть нацелен на отдельную подпрограмму (поскольку другая подпрограмма может выполнять тот же код) и может иметь странные взаимодействия с параллельным выполнением на других ядрах. Нестандартное исполнение (Out-of-line execution)Еще одна альтернатива в том же духе, но не требующая изменения существующего текста, - это выполнение вне строки. При таком подходе обработчик сигналов перемещает поток команд из точки прерывания в следующую безопасную точку перехода во временный буфер, исправляет его для перехода во время выполнения в конце и возобновляет выполнение в этой перемещенной последовательности. Это решает большинство проблем с одношаговым и скачкообразным перезаписыванием, но довольно сложно реализовать и требует значительных усилий по внедрению для каждой платформы. Это также запрещено в iOS. Прецедент такого подхода уже есть. Например, когда Linux uprobes вводит INT3, он перемещает перезаписанные инструкции в область “выполнить вне очереди”, чтобы избежать обычных проблем с возобновлением работы с инструкцией INT3. Реализация на удивление проста, учитывая сложность кодирования инструкций x86, но все еще довольно сложна.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Планировщик","slug":"Вопрос-Ответ/Планировщик","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"},{"name":"Планировщик","slug":"Golang/Старт/Планировщик","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Горутины","slug":"concurrency/goroutines","date":"2024-06-01T07:17:00.000Z","updated":"2024-06-02T18:00:11.741Z","comments":true,"path":"2024/06/01/concurrency/goroutines/","link":"","permalink":"https://goxpert.ru/2024/06/01/concurrency/goroutines/","excerpt":"","text":"Что такое горутина?Горутина - это функция, которая может выполняться параллельно с другими функциями в одном адресном пространстве. Горутины - это особенность языка программирования Go, который позволяет создавать легковесные потоки исполнения. Горутины могут обмениваться данными с помощью каналов, которые являются потокобезопасными структурами данных. Источники: Habr Habr Metanit Чем горутина отличается от треда?Горутина отличается от треда несколькими способами: Горутина имеет меньший размер стека, чем тред, и может динамически его расширять при необходимости. Горутина не связана с конкретным системным потоком, а управляется планировщиком Go, который может переключать горутины между разными потоками. Горутина может быть запущена с помощью ключевого слова go, в то время как тред требует вызова специальной функции или библиотеки. Горутина может общаться с другими горутинами через каналы, которые обеспечивают синхронизацию и безопасность данных. Треды же обычно используют разделяемую память и механизмы блокировки. Источники: Habr Medium В чем преимущества горутин над тредами?Некоторые преимущества горутин над тредами включают: Более высокую производительность и меньшее потребление ресурсов, так как горутины занимают меньше памяти и переключаются быстрее. Более простую и элегантную модель конкурентности, основанную на каналах, которые избегают проблем с блокировками и гонками данных. Что есть в Golang для многопоточности?В Golang для многопоточности есть горутины и каналы. Горутины - это легковесные потоки, которые можно запускать с помощью ключевого слова go. Каналы - это потокобезопасные структуры данных, которые позволяют обмениваться данными между горутинами. GOMAXPROCS - это параметр, который определяет, сколько ядер ЦП используется для одновременного выполнения горутин. Как можно остановить горутину?Остановить горутину можно с помощью контекста, канала или таймаута. Контекст позволяет передавать сигналы о завершении работы между горутинами. Канал позволяет отправлять и получать значения между горутинами, в том числе команды на остановку. Таймаут позволяет ограничить время работы горутины и прервать ее, если она не успела выполниться. Вот некоторые примеры использования этих механизмов: С помощью контекста: 1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;time&quot;)func main() &#123; // создаем контекст с отменой ctx, cancel := context.WithCancel(context.Background()) // запускаем горутину с этим контекстом go worker(ctx) // ждем 3 секунды time.Sleep(3 * time.Second) // отменяем контекст cancel() // ждем еще 2 секунды time.Sleep(2 * time.Second)&#125;func worker(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): // контекст отменен, выходим из горутины fmt.Println(&quot;worker stopped&quot;) return default: // продолжаем работать fmt.Println(&quot;worker working&quot;) time.Sleep(time.Second) &#125; &#125;&#125; С помощью канала: 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; // создаем канал для передачи сигнала остановки stop := make(chan bool) // запускаем горутину с этим каналом go worker(stop) // ждем 3 секунды time.Sleep(3 * time.Second) // отправляем сигнал остановки в канал stop &lt;- true // ждем еще 2 секунды time.Sleep(2 * time.Second)&#125;func worker(stop chan bool) &#123; for &#123; select &#123; case &lt;-stop: // получили сигнал остановки, выходим из горутины fmt.Println(&quot;worker stopped&quot;) return default: // продолжаем работать fmt.Println(&quot;worker working&quot;) time.Sleep(time.Second) &#125; &#125;&#125; С помощью таймаута: 123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; // создаем канал для получения результата работы result := make(chan string) // запускаем горутину с этим каналом go worker(result) // устанавливаем таймаут в 3 секунды timeout := time.After(3 * time.Second) select &#123; case res := &lt;-result: // получили результат работы до таймаута fmt.Println(&quot;worker finished:&quot;, res) case &lt;-timeout: // время вышло, прерываем горутину fmt.Println(&quot;worker timeout&quot;) &#125;&#125;func worker(result chan string) &#123; // имитируем долгую работу time.Sleep(5 * time.Second) // отправляем результат в канал result &lt;- &quot;success&quot;&#125; Когда возникает утечка горутины?Утечка горутины возникает, когда горутина продолжает существовать и занимать ресурсы, хотя ее работа уже завершена или не требуется. Это может привести к замедлению работы системы или даже сбою. Некоторые причины утечки горутин могут быть: Неправильное использование каналов, например, отправка или получение из закрытого или неполного канала, или блокировка канала без возможности выхода. Неэффективное управление контекстами, например, отсутствие отмены или таймаута для контекстов, передаваемых в горутины. Неожиданные ошибки или паники, которые прерывают работу горутины, не освобождая ресурсы. Неоптимальный дизайн программы, например, создание избыточного количества горутин или недостаточный контроль над их жизненным циклом.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Горутины","slug":"Вопрос-Ответ/Горутины","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/"},{"name":"Горутины","slug":"Golang/Старт/Горутины","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Гонка данных","slug":"concurrency/race-condition","date":"2024-06-01T07:16:00.000Z","updated":"2024-06-02T18:00:17.483Z","comments":true,"path":"2024/06/01/concurrency/race-condition/","link":"","permalink":"https://goxpert.ru/2024/06/01/concurrency/race-condition/","excerpt":"","text":"Что такое race condition?Состояние гонки (англ. race condition), также известное как конкуренция, - это ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода. Это может произойти, когда две или более операций должны выполняться в последовательности, но из-за неконтролируемых событий они выполняются в непредсказуемом порядке. В результате система или приложение может вести себя непредсказуемо или даже вызывать сбои. Состояние гонки - это “плавающая” ошибка (гейзенбаг), проявляющаяся в случайные моменты времени и “пропадающая” при попытке её локализовать. Из-за неконтролируемого доступа к общей памяти состояние гонки может приводить к совершенно различным ошибкам, которые могут проявляться в непредсказуемые моменты времени, а попытка повторения ошибки в целях отладки со схожими условиями работы может оказаться безуспешной. Основными последствиями могут быть: утечки памяти, ошибки сегментирования, порча данных, уязвимости, взаимные блокировки, утечки других ресурсов, например файловых дескрипторов. Источники: Habr Как обнаружить race condition?В Go есть встроенный инструмент для обнаружения состояний гонки, который можно использовать при запуске или сборке вашего приложения. Вы можете использовать флаг -race для обнаружения состояний гонки. Например, если ваш файл называется write.go, команда будет выглядеть так: go run -race write.go или go build -race write.go. При запуске этой команды Go выводит на стандартный вывод, который сообщает нам о наличии состояния гонки. Это очень полезный инструмент для обнаружения и исправления состояний гонки в ваших программах на Go. Также стоит отметить, что состояния гонки могут быть сложными для обнаружения и воспроизведения, поскольку они могут проявляться только при определенных условиях выполнения и могут не проявляться при повторном запуске того же кода. Поэтому использование инструментов, таких как детектор состояний гонки в Go, может быть очень полезным. Какие есть способы устранения race condition? Использование Mutex: (RW)Mutex предоставляет взаимоисключающую блокировку, которая позволяет только одной горутине в любой момент времени иметь доступ к защищенным данным. Использование каналов: Каналы в Go обеспечивают синхронизацию между горутинами и могут быть использованы для предотвращения состояний гонки. Использование атомарных операций: Пакет sync/atomic в Go предоставляет функции для атомарных операций, которые могут быть использованы для безопасного доступа к данным из нескольких горутин. Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?Да, будет состояние гонки. Функция append не является потокобезопасной, и если вы пытаетесь одновременно добавить элементы в слайс из разных горутин, это может привести к состоянию гонки. В Go, когда вы вызываете append, он может изменить размер слайса. Если размер нового слайса больше текущей вместимости, Go создаст новый массив в памяти и скопирует в него все элементы. Если две горутины одновременно пытаются добавить элементы, они могут получить разные копии массива, что приведет к непредсказуемым результатам. Чтобы избежать состояния гонки, вы можете использовать мьютекс (sync.Mutex или sync.RWMutex) для синхронизации доступа к слайсу. Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?Да, будет гонка данных. В Go, горутины выполняются параллельно, и если они обе пытаются изменить одну и ту же переменную (в данном случае, глобальный слайс), это может привести к неопределенному поведению. Это известно как гонка данных. Чтобы избежать этого, вы можете использовать мьютексы или каналы для синхронизации доступа к общим ресурсам.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Гонка данных","slug":"Вопрос-Ответ/Гонка-данных","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D0%BD%D0%BA%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/"},{"name":"Гонка данных","slug":"Golang/Старт/Гонка-данных","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%93%D0%BE%D0%BD%D0%BA%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Примитивы синхронизации","slug":"concurrency/sync-primitives","date":"2024-06-01T07:15:00.000Z","updated":"2024-06-02T18:00:31.397Z","comments":true,"path":"2024/06/01/concurrency/sync-primitives/","link":"","permalink":"https://goxpert.ru/2024/06/01/concurrency/sync-primitives/","excerpt":"","text":"Какие примитивы синхронизации есть в Golang?Примитивы синхронизации - это специальные конструкции, которые позволяют координировать и контролировать доступ к общим ресурсам в многопоточных или конкурентных программах. В Golang есть несколько пакетов, которые предоставляют различные примитивы синхронизации, такие как: sync - содержит базовые примитивы, такие как мьютексы (mutexes), блокировки чтения-записи (read-write locks), группы ожидания (wait groups), однократные исполнители (once), условные переменные (condition variables) и другие.sync/atomic - содержит функции для атомарных операций с примитивными типами данных, такими как целые числа, указатели, булевы значения и т.д.context - содержит примитивы для управления жизненным циклом и отменой горутин (goroutines), а также для передачи метаданных между ними.chan - является встроенным типом данных, который представляет собой канал для обмена данными между горутинами, который может быть использован как примитив синхронизации или коммуникации. Источники: Medium Medium Чем мьютекс отличается от семафора?Мьютекс и семафор - это два способа синхронизации доступа к общим ресурсам в многопоточных программах. Они имеют разные преимущества и недостатки, и их выбор зависит от конкретной задачи. Вот некоторые основные различия между мьютексом и семафором: Мьютекс - это объект, который позволяет блокировать и разблокировать доступ к одному ресурсу, тогда как семафор - это переменная, которая позволяет контролировать доступ к нескольким ресурсам.Мьютекс может быть захвачен или освобожден только тем потоком, который его заблокировал, тогда как семафор может быть изменен любым потоком.Мьютекс обычно используется для взаимного исключения, т.е. для предотвращения состояний гонки, тогда как семафор обычно используется для координации, т.е. для синхронизации действий между потоками.Мьютекс имеет только два состояния: заблокирован или разблокирован, тогда как семафор имеет целочисленное значение, которое может быть больше нуля. Источники: Guru99 Что такое atomic и чем отличается от мьютекса?Атомики (atomics) - это функции, которые позволяют выполнять простые операции с общим ресурсом, такие как чтение, запись, инкремент, декремент, обмен или сравнение и присваивание. Атомики гарантируют, что эти операции будут выполнены атомарно, то есть без вмешательства других горутин. Атомики реализованы в пакете sync/atomic, и для их использования нужно вызывать соответствующие функции с указателем на ресурс. Атомики подходят для ситуаций, когда требуется выполнить быстрые и простые операции с ресурсом, такие как увеличение или уменьшение счетчика, установка или сброс флага, или проверка или изменение состояния.Все атомики реализованы через спецальные регистры процессора и в коде го они написаны на ассемблереАтомики являются примитивами низкого уровня реализующими атомарные операции с памятью. Атомики в Go: особенности внутренней реализации В общем, мьютексы и атомики имеют следующие отличия: Мьютексы работают с любыми типами данных, а атомики - только с примитивными типами, такими как int, uint, bool, pointer и т.д. Мьютексы требуют явной блокировки и разблокировки, а атомики - нет. Мьютексы позволяют выполнять любые операции с ресурсом, а атомики - только ограниченный набор операций. Мьютексы могут быть более медленными и затратными, чем атомики, из-за переключения контекста и ожидания блокировки. Мьютексы могут приводить к взаимным блокировкам (deadlocks), если не использовать их правильно, а атомики - нет. Источники: Golangify Metanit Что можно использовать для ожидания выполнения N горутин?Один из способов сделать это - использовать встроенную конструкцию WaitGroup из пакета sync. WaitGroup позволяет организовать синхронизацию между несколькими горутинами, которые выполняют параллельные или конкурентные задачи. WaitGroup имеет счетчик, который увеличивается при добавлении новой горутины и уменьшается при ее завершении. Основная горутина может вызвать метод Wait, который блокирует ее до тех пор, пока счетчик не станет равным нулю, то есть пока все горутины не закончат свою работу. Например, вы можете написать следующий код, который запускает N горутин, каждая из которых печатает свой номер и засыпает на случайное время, а затем ожидает их завершения с помощью WaitGroup: title12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;sync&quot; &quot;time&quot;)const N = 5 // количество горутинfunc main() &#123; var wg sync.WaitGroup // создаем WaitGroup wg.Add(N) // устанавливаем счетчик на N for i := 1; i &lt;= N; i++ &#123; go func(n int) &#123; // запускаем горутину с номером n // при выходе из горутины уменьшаем счетчик на 1 defer wg.Done() fmt.Println(&quot;Горутина&quot;, n, &quot;начала работу&quot;) // засыпаем на случайное время от 0 до 10 секунд time.Sleep(time.Duration(rand.Intn(10)) * time.Second) fmt.Println(&quot;Горутина&quot;, n, &quot;закончила работу&quot;) &#125;(i) &#125; fmt.Println(&quot;Ожидаем завершения горутин&quot;) // блокируем основную горутину, пока счетчик не станет равным нулю wg.Wait() fmt.Println(&quot;Все горутины завершились&quot;)&#125; Есть общий ресурс. Хотим, чтобы к нему одновременно обращались только N горутин. Как это сделать?Один из способов сделать это - использовать семафор (semaphore), который представляет собой переменную, которая хранит количество доступных ресурсов. Семафор может быть реализован с помощью канала (channel) с буфером размера N, который будет заполнен пустыми значениями. Каждая горутина, которая хочет получить доступ к ресурсу, должна сначала получить значение из канала, а затем вернуть его обратно после завершения работы. Таким образом, канал будет выступать в роли блокировки, которая разрешает доступ только N горутинам одновременно. Например, вы можете написать следующий код, который запускает M горутин, каждая из которых печатает свой номер и засыпает на случайное время, а затем ожидает их завершения с помощью семафора: title123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)const N = 3 // количество доступных ресурсовconst M = 10 // количество горутинfunc main() &#123; sem := make(chan struct&#123;&#125;, N) // создаем канал с буфером размера N for i := 1; i &lt;= N; i++ &#123; sem &lt;- struct&#123;&#125;&#123;&#125; // заполняем канал пустыми значениями &#125; for i := 1; i &lt;= M; i++ &#123; go work(i, sem) // запускаем горутину с номером i и каналом sem &#125; time.Sleep(20 * time.Second) // ждем 20 секунд, пока все горутины закончат работу fmt.Println(&quot;The End&quot;)&#125;func work(number int, sem chan struct&#123;&#125;) &#123; // получаем значение из канала, блокируя доступ к ресурсу &lt;-sem fmt.Println(&quot;Горутина&quot;, number, &quot;начала работу&quot;) // засыпаем на случайное время от 0 до 10 секунд time.Sleep(time.Duration(rand.Intn(10)) * time.Second) fmt.Println(&quot;Горутина&quot;, number, &quot;закончила работу&quot;) // возвращаем значение в канал, разблокируя доступ к ресурсу sem &lt;- struct&#123;&#125;&#123;&#125;&#125; Запустим 1000 горутин с инкрементом инта. Получим в конце тысячу? Что делать, чтобы получить тысячу?Если вы запустите 1000 горутин с инкрементом инта, то скорее всего вы не получите в конце тысячу. Это потому, что инкремент не является атомарной операцией, то есть он состоит из трех шагов: чтения, изменения и записи значения. Если несколько горутин одновременно пытаются выполнить инкремент, то может возникнуть состояние гонки (race condition), когда одна горутина перезаписывает значение, измененное другой горутиной, и тем самым теряет часть инкрементов. Чтобы получить тысячу в конце, нужно синхронизировать доступ к общей переменной, которая хранит инт. Для этого можно использовать один из следующих способов: Использовать мьютекс (mutex) из пакета sync, который позволяет блокировать и разблокировать доступ к переменной. Каждая горутина должна вызвать метод Lock перед инкрементом и метод Unlock после него, чтобы гарантировать, что только одна горутина может работать с переменной в один момент времени. Использовать атомик (atomic) из пакета sync/atomic, который позволяет выполнять атомарные операции с примитивными типами данных. Вместо обычного инкремента можно использовать функцию AddInt32 или AddInt64, которая атомарно увеличивает значение переменной на заданное число и возвращает новое значение. Есть глобальная мапа, глобальный мьютекс. Две функции. Одна блочит мьютекс, а вторая нет. Что произойдет?Если одна функция блокирует мьютекс перед работой с глобальной мапой, а другая нет, то может возникнуть ситуация, когда две функции одновременно пытаются изменить мапу, что может привести к состоянию гонки (race condition) и неопределенному поведению программы. Состояние гонки означает, что результат работы программы зависит от случайного порядка выполнения операций, и может быть непредсказуемым или некорректным. Например, если одна функция пытается добавить элемент в мапу, а другая пытается удалить элемент из мапы, то может случиться, что элемент будет удален до того, как он будет добавлен, или наоборот, или что элемент будет добавлен или удален дважды, или что мапа будет повреждена. Сколько нужно ядер, чтобы начать использовать sync.Map?sync.Map может быть полезен, если у вас высоконагруженная система с большим количеством ядер процессора (32+), и вы сталкиваетесь с проблемой ложной разделяемости (false sharing), когда разные горутины конкурируют за доступ к одному и тому же кеш-линии (cache line). В этом случае sync.Map может снизить количество конфликтов и повысить скорость работы с картой. Однако, если у вас небольшое количество ядер (меньше 8), и вы часто записываете в карту, то sync.Map может быть неэффективнее, чем обычная карта с мьютексом, так как он использует сложную внутреннюю структуру, которая требует дополнительных вычислений и памяти. Таким образом, нет однозначного ответа на вопрос, сколько нужно ядер, чтобы начать использовать sync.Map. Это зависит от конкретной задачи, характера операций с картой, нагрузки на систему и других факторов. Ложная разделяемость - это проблема, которая может возникнуть в многопроцессорных системах,когда разные процессоры или ядра конкурируют за доступ к одному и тому же кеш-линии (cache line), то есть блоку памяти,который загружается в кеш процессора для ускорения работы с данными.Если один процессор изменяет данные в кеш-линии, то другие процессорыдолжны обновить свои копии этой кеш-линии, что приводит к дополнительным задержкам и снижению производительности.Ложная разделяемость может возникать, когда разные процессоры работают с разными данными, которые случайно попадают в одну кеш-линию, или когда разные процессоры работают с одними и теми же данными, но не синхронизируют свой доступ к ним.Ложная разделяемость может быть устранена с помощью различных методов, таких как: Изменение размера или выравнивания структур данных, чтобы избежать перекрытия кеш-линий. Использование атомарных (atomic) операций, которые не требуют блокировки кеш-линии. Использование специальных инструкций, которые позволяют указать процессору, что данные в кеш-линии не будут изменяться. Использование разных уровней кеша для разных типов данных. Источники: Habr Blogspot Как устроена WaitGroup под капотом и как ее можно реализовать самому?Под капотом WaitGroup реализован с помощью атомарных операций, которые обеспечивают потокобезопасность и высокую производительность. WaitGroup использует 64-битное целое число, которое разделено на две части: старшие 32 бита хранят счетчик горутин, а младшие 32 бита хранят счетчик ожидающих горутин. Каждый раз, когда вызывается метод Add, WaitGroup атомарно увеличивает счетчик горутин на заданное значение. Каждый раз, когда вызывается метод Done, WaitGroup атомарно уменьшает счетчик горутин на единицу и проверяет, не стал ли он равным нулю. Если да, то WaitGroup атомарно увеличивает счетчик ожидающих горутин на единицу и разблокирует одну из ожидающих горутин с помощью сигнальной переменной (signal variable). Каждый раз, когда вызывается метод Wait, WaitGroup атомарно уменьшает счетчик ожидающих горутин на единицу и проверяет, не стал ли он отрицательным. Если да, то WaitGroup атомарно возвращает счетчик ожидающих горутин в исходное состояние и блокирует текущую горутину с помощью сигнальной переменной. title1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;sync/atomic&quot; &quot;time&quot;)// MyWaitGroup - собственная реализация WaitGrouptype MyWaitGroup struct &#123; counter int64 // счетчик горутин waiter int64 // счетчик ожидающих горутин signal sync.Cond // сигнальная переменная&#125;// Add - добавляет n горутин в группуfunc (wg *MyWaitGroup) Add(n int) &#123; atomic.AddInt64(&amp;wg.counter, int64(n)) // атомарно увеличиваем счетчик горутин на n&#125;// Done - уменьшает счетчик горутин на 1 и разблокирует одну ожидающую горутину, если счетчик стал равным 0func (wg *MyWaitGroup) Done() &#123; if atomic.AddInt64(&amp;wg.counter, -1) == 0 &#123; // атомарно уменьшаем счетчик горутин на 1 и проверяем, не стал ли он равным 0 wg.signal.L.Lock() // блокируем сигнальную переменную atomic.AddInt64(&amp;wg.waiter, 1) // атомарно увеличиваем счетчик ожидающих горутин на 1 wg.signal.Broadcast() // разблокируем все ожидающие горутины wg.signal.L.Unlock() // разблокируем сигнальную переменную &#125;&#125;// Wait - блокирует текущую горутину, пока счетчик горутин не станет равным 0func (wg *MyWaitGroup) Wait() &#123; wg.signal.L.Lock() // блокируем сигнальную переменную if atomic.AddInt64(&amp;wg.waiter, -1) &lt; 0 &#123; // атомарно уменьшаем счетчик ожидающих горутин на 1 и проверяем, не стал ли он отрицательным atomic.StoreInt64(&amp;wg.waiter, 0) // атомарно возвращаем счетчик ожидающих горутин в исходное состояние wg.signal.Wait() // блокируем текущую горутину &#125; wg.signal.L.Unlock() // разблокируем сигнальную переменную&#125;func main() &#123; var wg MyWaitGroup // создаем экземпляр MyWaitGroup wg.Add(2) // добавляем две горутины в группу work := func(id int) &#123; defer wg.Done() // при выходе из горутины вызываем метод Done fmt.Printf(&quot;Горутина %d начала работу\\n&quot;, id) time.Sleep(2 * time.Second) // имитируем работу горутины fmt.Printf(&quot;Горутина %d завершила работу\\n&quot;, id) &#125; // запускаем две горутины go work(1) go work(2) wg.Wait() // ожидаем завершения всех горутин в группе fmt.Println(&quot;Горутины завершились&quot;)&#125; Источники: Habr Metanit Medium В чем разница между Mutex и RWMutex?Mutex и RWMutex в Go оба используются для синхронизации доступа к данным в многопоточной среде, но они работают немного по-разному: Mutex: Mutex предоставляет взаимоисключающую блокировку, которая позволяет только одной горутине в любой момент времени иметь доступ к защищенным данным. Если другая горутина пытается получить доступ к данным, когда Mutex заблокирован, она будет заблокирована до тех пор, пока Mutex не будет разблокирован. RWMutex: RWMutex (Reader-Writer Mutex) предоставляет более гибкую семантику блокировки. RWMutex позволяет множеству горутин получить параллельный доступ для чтения (блокировка чтения), но только одной горутине получить эксклюзивный доступ на запись (блокировка записи).Это означает, что несколько горутин могут одновременно читать данные, но запись данных может производить только одна горутина. Когда нужно использовать Mutex, а когда RWMutex?Использование Mutex: Mutex следует использовать, когда у вас есть данные, которые могут быть изменены одновременно несколькими горутинами. Mutex обеспечивает взаимоисключающую блокировку, что позволяет только одной горутине в любой момент времени иметь доступ к защищенным данным. Использование RWMutex: RWMutex следует использовать, когда у вас есть данные, которые часто читаются, но редко обновляются. RWMutex позволяет множеству горутин получить параллельный доступ для чтения, но только одной горутине получить эксклюзивный доступ на запись.Это может улучшить производительность, если у вас есть данные, которые часто читаются, так как несколько горутин могут одновременно читать данные. Источники: Habr Stackoverflow","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Примитивы синхронизации","slug":"Вопрос-Ответ/Примитивы-синхронизации","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/"},{"name":"Примитивы синхронизации","slug":"Golang/Старт/Примитивы-синхронизации","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Пример sync и async worker","slug":"concurrency/sync-worker","date":"2024-06-01T07:15:00.000Z","updated":"2024-06-03T07:14:40.271Z","comments":true,"path":"2024/06/01/concurrency/sync-worker/","link":"","permalink":"https://goxpert.ru/2024/06/01/concurrency/sync-worker/","excerpt":"","text":"В этом примере мы собираемся создать рабочий пакет, который будет использоваться для синхронной и асинхронной обработки заданий. Упаковка Хотя этот пакет делает то, что обещает, ему нужны еще три бонусные функции. Возможность завершать длительные задания. Возможность закрытия каналов. Возможность убить всех рабочих. В этом примере для заданий используются «небуферизованные» каналы. Однако, если вы хотите ограничить количество заданий одновременно, вы можете обновить NewWorker()функцию, чтобы использовать «буферизованные» каналы, как показано ниже. 1234567func NewWorker(workerTotal, jobTotal int) Worker &#123; return Worker&#123; total: workerTotal, jobChan: make(chan Job, jobTotal), resultChan: make(chan interface&#123;&#125;, jobTotal), &#125;&#125; код 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package worker import ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;) // ----------------------------------------------------------------------------- type Job struct &#123; // id represents the job identifier. // id представляет идентификатор задания. id interface&#123;&#125;&#125; // NewJob returns a `Job` instance.// NewJob возвращает экземпляр Job.func NewJob(id interface&#123;&#125;) Job &#123; return Job&#123; id: id, &#125;&#125; // ----------------------------------------------------------------------------- type Worker struct &#123; // total represents the amount of workers to be run at startup. // total представляет количество воркеров, которые будут запущены при запуске. total int // jobChan represents a two-way &quot;unbuffered&quot; channel that has unlimited // capacity for the jobs. // jobChan представляет собой двусторонний «небуферизованный» канал с неограниченной // пропускной способностью для заданий. jobChan chan Job // resultChan represents a two-way &quot;unbuffered&quot; channel that has unlimited // capacity for the job results. // resultChan представляет собой двусторонний «небуферизованный» канал, который имеет неограниченную // емкость для результатов задания. resultChan chan interface&#123;&#125;&#125; // NewWorker returns a `Worker` instance.// NewWorker возвращает экземпляр Worker.func NewWorker(workerTotal int) Worker &#123; return Worker&#123; total: workerTotal, jobChan: make(chan Job), resultChan: make(chan interface&#123;&#125;), &#125;&#125; // Start brings up certain amount of worker(s) so that they can pick up and work// on the job(s).// Start вызывает определенное количество рабочих(воркеров), чтобы они могли взять и работать // на задании (джобе(ах)).func (w Worker) Start() &#123; for i := 1; i &lt;= w.total; i++ &#123; go w.run(i) &#125;&#125; // Add adds a job to a channel so that it could be picked up and worked on by// the running worker(s).// Add добавляет задание(джоб) в канал, чтобы его мог взять и обработать // работающий работник(и)(воркер(ы)). func (w Worker) Add(job Job) &#123; w.jobChan &lt;- job&#125; // Result returns a channel so that it could be ranged over in order to fetch// job results from the running worker(s).// Result возвращает канал, чтобы его можно было ранжировать для получения // результатов задания от работающего работника(ов)(воркера).func (w Worker) Result() &lt;-chan interface&#123;&#125; &#123; return w.resultChan&#125; // run runs a worker and works on the job(s).// run запускает работника и работает над заданием(ями) джобами.func (w Worker) run(id int) &#123; fmt.Println(id, &quot;running...&quot;) for &#123; select &#123; case job := &lt;- w.jobChan: fmt.Printf(&quot;%d выбрал задание %v @ %s\\n&quot;, id, job.id, time.Now().UTC()) //fmt.Printf(&quot;%d picked up job %v @ %s\\n&quot;, id, job.id, time.Now().UTC()) // Pretend like doing something. // Делаем вид, будто что-то делаем. rand.Seed(time.Now().UnixNano()) time.Sleep(time.Duration(rand.Intn(len([]int&#123;0, 1, 2, 3, 4&#125;))) * time.Second) // Done. (сделано) fmt.Printf(&quot;%d завершил задание %v @ %s\\n&quot;, id, job.id, time.Now().UTC()) //fmt.Printf(&quot;%d completed job %v @ %s\\n&quot;, id, job.id, time.Now().UTC()) w.resultChan &lt;- job.id default: time.Sleep(1 * time.Second) //fmt.Println(id, &quot;waiting...&quot;) fmt.Println(id, &quot;ожидание...&quot;) &#125; &#125;&#125; ПрименениеАсинхронныйЭто асинхронный (неблокирующий) пример, поэтому задания обрабатываются случайным образом и в произвольном порядке. Программа никогда не выходит. Результаты заданий печатаются независимо друг от друга. Важно иметь несколько работников. 12345678910111213141516171819202122232425262728package main import ( &quot;fmt&quot; &quot;internal/worker&quot;) func main() &#123; // Create new worker(s) and start. // Создаем новых рабочих и запускаем. w := worker.NewWorker(3) w.Start() go func() &#123; // Add jobs. // Добовляем задания for i := 1; i &lt;= 5; i++ &#123; w.Add(worker.NewJob(i)) &#125; &#125;() // Print results. // Печать результатов. for v := range w.Result() &#123; fmt.Println(&quot;Result:&quot;, v) &#125;&#125; синхронныйЭто синхронный (блокирующий) пример, поэтому задания обрабатываются одно за другим по порядку. Программа завершает работу после завершения заданий. Результаты заданий печатаются один за другим по порядку. Иметь несколько работников бессмысленно, поскольку одновременно обрабатывается одно задание. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package main import ( &quot;fmt&quot; &quot;internal/worker&quot;) func main() &#123; // Create new worker(s) and start. // Создаем новых рабочих и запускаем. w := worker.NewWorker(3) w.Start() // Add jobs. // Добавляем задания. w.Add(worker.NewJob(1)) // Print results. // Распечатываем результаты. v := &lt;- w.Result() //fmt.Println(&quot;Result:&quot;, v) fmt.Println(&quot;Результат:&quot;, v) // Add jobs. // Добавляем задания. w.Add(worker.NewJob(2)) // Print results. v = &lt;- w.Result() fmt.Println(&quot;Result:&quot;, v) // Add jobs. w.Add(worker.NewJob(3)) // Print results. v = &lt;- w.Result() fmt.Println(&quot;Result:&quot;, v) // Add jobs. w.Add(worker.NewJob(4)) // Print results. v = &lt;- w.Result() fmt.Println(&quot;Result:&quot;, v) // Add jobs. w.Add(worker.NewJob(5)) // Print results. v = &lt;- w.Result() fmt.Println(&quot;Result:&quot;, v)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Примитивы синхронизации","slug":"Вопрос-Ответ/Примитивы-синхронизации","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/"},{"name":"Примитивы синхронизации","slug":"Golang/Старт/Примитивы-синхронизации","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Типы данных","slug":"types/types-common","date":"2024-06-01T07:14:00.000Z","updated":"2024-06-02T11:10:01.396Z","comments":true,"path":"2024/06/01/types/types-common/","link":"","permalink":"https://goxpert.ru/2024/06/01/types/types-common/","excerpt":"","text":"Что такое type switch? Type switch в Go - это способ проверить, какого типа является значение, хранящееся в интерфейсе. Это похоже на обычный switch, но вместо значений в кейсах указываются типы. 1234567891011121314151617181920package mainimport &quot;fmt&quot;func do(i interface&#123;&#125;) &#123; switch v := i.(type) &#123; case int: fmt.Printf(&quot;Twice %v is %v\\n&quot;, v, v*2) case string: fmt.Printf(&quot;%q is %v bytes long\\n&quot;, v, len(v)) default: fmt.Printf(&quot;I don&#x27;t know about type %T!\\n&quot;, v) &#125;&#125;func main() &#123; do(21) do(&quot;hello&quot;) do(true)&#125; Какие типы данных есть в Golang? Целочисленные типы: int8, int16, int32, int64, uint8, uint16, uint32, uint64, byte (синоним для uint8), rune (синоним для int32), int и uint. Числа с плавающей точкой: float32 и float64. Строки: string. Булев тип: bool. Составные типы: Массивы, срезы, структуры, ассоциативные массивы Какой длины руна?rune - это алиас для int32. Это означает, что rune занимает 4 байта или 32 бита. Каждая rune представляет собой один Юникод символ. Например, строка может быть преобразована в срез rune ([]rune), и каждый элемент этого среза будет представлять собой один Юникод символ. Как реализовать Enum в Golang?В Go нет встроенной поддержки перечислений (enum), но их можно эмулировать с помощью констант. Вот пример реализации enum в Go: title123456789101112131415161718192021package mainimport &quot;fmt&quot;type Season intconst ( Summer Season = iota Autumn Winter Spring)func (s Season) String() string &#123; return [...]string&#123;&quot;Лето&quot;, &quot;Осень&quot;, &quot;Зима&quot;, &quot;Весна&quot;&#125;[s]&#125;func main() &#123; s := Winter fmt.Println(s)&#125; Что если во время компиляции переполним тип? В int8 запишем 256?Если вы попытаетесь записать значение, превышающее максимально допустимое для данного типа, в Go, то произойдет переполнение типа. Например, int8 может хранить значения от -128 до 127. Если вы попытаетесь записать 256 в переменную типа int8, то произойдет переполнение. В результате, вместо 256 будет записано значение, которое соответствует остатку от деления 256 на 256 (количество возможных значений для int8), то есть 01. Важно отметить, что такое поведение может привести к неожиданным результатам, поэтому всегда следует убедиться, что значения, которые вы записываете в переменные, не превышают максимально допустимые для их типа Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?Если вы попытаетесь записать значение, превышающее максимально допустимое для данного типа, в Go, то произойдет переполнение типа. Например, uint8 может хранить значения от 0 до 255. Если вы попытаетесь записать 256 в переменную типа uint8, то произойдет переполнение. В результате, вместо 256 будет записано значение, которое соответствует остатку от деления 256 на 256 (количество возможных значений для uint8), то есть 0. Важно отметить, что такое поведение может привести к неожиданным результатам, поэтому всегда следует убедиться, что значения, которые вы записываете в переменные, не превышают максимально допустимые для их типа.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Типы","slug":"Вопрос-Ответ/Типы","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A2%D0%B8%D0%BF%D1%8B/"},{"name":"Типы","slug":"Golang/Старт/Типы","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A2%D0%B8%D0%BF%D1%8B/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Хеш-мапы (map)","slug":"types/map","date":"2024-06-01T07:13:00.000Z","updated":"2024-06-02T10:55:48.970Z","comments":true,"path":"2024/06/01/types/map/","link":"","permalink":"https://goxpert.ru/2024/06/01/types/map/","excerpt":"","text":"Что такое мапа (map)??Мапа в Go - это тип данных, который предназначен для хранения пар “ключ-значение”. Это структура данных, также известная как хэш-таблица, словарь или ассоциативный массив. Мапа позволяет получить значение по ключу. Ключами в мапе могут быть любые сравниваемые типы — все сравнимые типы. title12345678910package mainimport &quot;fmt&quot;func main() &#123; m := make(map[string]int) m[&quot;apple&quot;] = 1 m[&quot;banana&quot;] = 2 fmt.Println(m)&#125; Что произойдет при конкурентной записи в мапу?Мапы в Go не являются потокобезопасными. Это означает, что если вы попытаетесь записать данные в мапу из нескольких горутин одновременно, это может привести к состоянию гонки. Если вам нужно работать с мапой из нескольких горутин, вы должны использовать механизмы синхронизации, такие как sync.Mutex или sync.RWMutex, чтобы гарантировать, что в любой момент времени только одна горутина может изменять мапу. Вот пример использования sync.Mutex для безопасной записи в мапу из нескольких горутин: title12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot; &quot;sync&quot;)func main() &#123; var wg sync.WaitGroup var mu sync.Mutex m := make(map[int]int) for i := 0; i &lt; 10; i++ &#123; wg.Add(1) go func(i int) &#123; defer wg.Done() mu.Lock() m[i] = i * 2 mu.Unlock() &#125;(i) &#125; wg.Wait() fmt.Println(m)&#125; Как устроена мапа под капотом?Мапа в Go - это структура данных, которая хранит пары “ключ-значение”. Внутри мапы ключи и значения хранятся в выделенном участке памяти, последовательно. Для получения адресов ячеек конкретных ключей и значений используется хэширующая функция. Вот некоторые детали о том, как устроена мапа в Go: Мапа разбивается на бакеты для более эффективного поиска. Хэш-функция используется для равномерного распределения ключей по бакетам. При переполнении бакета происходит рост мапы. Эвакуация данных происходит при заполнении мапы. Порядок обхода мапы является случайным. Какие ключи могут быть у мапы?Ключами в мапе могут быть любые сравниваемые типы — все простые скалярные типы, массивы. Несравниваемые типы — срезы, мапы, функции. Ключи и значения мапы будут храниться в выделенном участке памяти, последовательно. Какая сложность работы с мапой?Операции вставки, удаления и поиска в мапе в Go обычно имеют сложность O(1), то есть они выполняются за постоянное время. Это достигается за счет использования хэш-таблицы внутри мапы. Однако в худшем случае, когда все ключи попадают в один и тот же бакет, эти операции могут иметь сложность O(n), где n - количество элементов в мапе Можно ли взять адрес элемента мапы и почему?Нет, нельзя взять адрес элемента мапы в Go. Это связано с тем, как устроена мапа внутри. Мапа разбита на бакеты, и при росте мапы элементы могут переходить из одного бакета в другой. Это означает, что адрес элемента в памяти может меняться, и поэтому Go не позволяет взять адрес элемента мапы. Если вы попытаетесь это сделать, компилятор выдаст ошибку. Как работает эвакуация данных?Эвакуация данных в мапе Go происходит при переполнении мапы. Когда количество элементов в мапе достигает определенного порога, мапа “растет” - создается новая, большая мапа, и все элементы из старой мапы копируются в новую. Этот процесс называется “эвакуацией”. Важно отметить, что в Go рост мапы происходит асинхронно. Это означает, что во время роста мапы могут возникать ситуации, когда при попытке доступа к данным часть бакетов уже переехала в новую мапу, а часть еще нет. Благодаря этому не происходит просадок во время роста большой мапы. Как разрешаются коллизии в мапе?В мапе Go коллизии разрешаются с помощью бакетов. Каждый бакет может содержать до восьми элементов. Если все ячейки в бакете заняты, то происходит переполнение и мапа “растет” - создается новая, большая мапа, и все элементы из старой мапы копируются в новую. Этот процесс называется “эвакуацией”. При этом, благодаря использованию хэш-функции, ключи равномерно распределяются по бакетам. Это позволяет минимизировать количество коллизий и обеспечивает быстрый доступ к данным. В функции make для мапы мы указываем число. Что оно дает?Число, указываемое в функции make для мапы в Go, определяет начальную вместимость мапы. Это число элементов, которые мапа сможет хранить без необходимости расширения. Если вы заранее знаете, сколько элементов будет в мапе, вы можете использовать это число при создании мапы, чтобы уменьшить количество операций реаллокации памяти, что может улучшить производительность. Вот пример создания мапы с начальной вместимостью 10: title1m := make(map[string]int, 10) Стало слишком много коллизий в мапе, как решить проблему?Если в мапе Go стало слишком много коллизий, вы можете использовать следующие подходы для решения проблемы: Изменить размер мапы: Если мапа слишком мала, она может быстро заполняться, что приводит к большому количеству коллизий. В этом случае вы можете увеличить размер мапы, чтобы уменьшить вероятность коллизий. Использовать метод раздельного связывания: Это метод, при котором внутри хеш-таблицы хранится массив фиксированного размера, элементы которого - связанные списки. По хешу ключа определяется элемент массива (bucket - корзину) и потом смотрится в списке, нет ли такого элемента и действуется соответствующее (добавляется/удаляется/модифицируется). Чем мапа отличается от sync.Map?sync.Map и обычная мапа в Go имеют различия в использовании и производительности Потокобезопасность: Обычная мапа в Go не является потокобезопасной, что означает, что одновременная запись в мапу из нескольких горутин может привести к состоянию гонки. В то время как sync.Map разработана для использования в многопоточных ситуациях и обеспечивает потокобезопасность. Производительность sync.Map обычно близка по скорости к обычной мапе с sync.RWMutex, но может быть лучше в случае чтения. Когда происходит чтение и обновление, sync.Map будет иметь элементы и в чтении, и в “грязном” состоянии. Использование sync.Map - это структура с методами, предоставляющими обычные операции с мапой. Вы не можете использовать синтаксис a_map[&quot;key&quot;] с sync.Map, вместо этого нужно использовать методы, такие как Load, Store и Delete. Структура sync.Map - это сложная структура, обычно состоящая из двух мап - одной для чтения и одной для новых элементов. Важно отметить, что sync.Map следует использовать только в тех случаях, когда большинство операций с мапой - это чтение, и когда ключи мапы меняются динамически. Какая функция используется при хешировании ключа в мапе?При хешировании ключа в мапе golang используется функция runtime.mapaccess1_faststr, которая принимает тип мапы, саму мапу и ключ в виде строки. Функция ищет ключ в мапе и возвращает указатель на соответствующее значение. Функция runtime.mapaccess1_faststr является специализированной версией функции runtime.mapaccess1, которая работает с любым типом ключа. Хеширование ключа в мапе golang основано на алгоритме MurmurHash, который быстро и равномерно распределяет ключи по хеш-таблице. Хеш-таблица в golang состоит из массива корзин (buckets), каждая из которых содержит до восьми пар ключ-значение. Кроме того, каждая корзина имеет указатель на переполненную корзину, которая создается при коллизии хешей. Если вы хотите узнать больше о реализации мапы в golang, вы можете почитать эту статью или эту статью на Хабре. Они объясняют детали работы мапы в golang с примерами кода и иллюстрациями. 😊 Источники: Habr Habr GolangForAll title1234567891011121314151617181920package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m map[string]Vertexfunc main() &#123; m = make(map[string]Vertex) // иначе паника m[&quot;Bell Labs&quot;] = Vertex&#123;40.68433, -74.39967,&#125; m[&quot;A2&quot;] = Vertex&#123;42, -24,&#125; fmt.Println(m) // реализовано так, что детерменированный вывод for _, val := range m &#123; // произвольный обход fmt.Println(val) &#125;&#125; Хорошая статья Pro Map","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Хеш-мапы","slug":"Вопрос-Ответ/Хеш-мапы","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A5%D0%B5%D1%88-%D0%BC%D0%B0%D0%BF%D1%8B/"},{"name":"Хеш-мапы","slug":"Golang/Старт/Хеш-мапы","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A5%D0%B5%D1%88-%D0%BC%D0%B0%D0%BF%D1%8B/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Интерфейсы","slug":"types/interface","date":"2024-06-01T07:12:00.000Z","updated":"2024-06-02T09:51:46.105Z","comments":true,"path":"2024/06/01/types/interface/","link":"","permalink":"https://goxpert.ru/2024/06/01/types/interface/","excerpt":"","text":"Что такое интерфейс (interface)?Интерфейс в golang - это тип, который определяет набор сигнатур методов. Интерфейс позволяет абстрагироваться от конкретной реализации и работать с разными типами данных, которые реализуют один и тот же интерфейс. Например, интерфейс Printer определяет метод Print(), который может быть реализован разными структурами, такими как User или Document. Для того, чтобы тип реализовывал интерфейс, он должен предоставить определения всех методов интерфейса. В Go реализация интерфейса происходит неявно, то есть не требуется указывать, что тип реализует интерфейса. Для чего используется интерфейс?Интерфейс в golang используется для определения набора методов, которые должен реализовывать какой-либо тип данных. Интерфейсы позволяют абстрагироваться от конкретных реализаций и работать с разными типами, имеющими общее поведение. Интерфейсы также способствуют модульности, гибкости и переиспользованию кода. Например, интерфейс fmt.Stringer определяет метод String(), который возвращает строковое представление любого типа, реализующего этот интерфейс. Как в строго типизированным языке сделать функцию, которая работает с разными типами?Один из способов сделать это - использовать обобщения (generics), которые появились в Go 1.18. Обобщения позволяют объявлять и использовать функции или типы, которые написаны для работы с любым из набора типов, предоставляемых вызывающим кодом. Для этого в Go введены три новых элемента языка: Параметры типов для функций и типов. Это означает, что вы можете задать переменную типа T, которая может принимать разные конкретные типы при вызове функции или создании типа. Определение интерфейсных типов как множеств типов, включая типы, не имеющие методов. Это означает, что вы можете задать ограничение (constraint) на параметр типа, указав, какие свойства должен иметь тип, чтобы его можно было использовать в обобщенной функции или типе. Вывод типов, который позволяет опускать аргументы типов во многих случаях при вызове функции. Это означает, что вы можете не указывать конкретный тип при вызове обобщенной функции, если компилятор может сам его определить из контекста. Есть интерфейс, а есть указатель на структуру, который nil. Кладем указатель в интерфейс. Что если сравнить интерфейс с nil?Интерфейс в Go является типом, который может хранить любые типы, удовлетворяющие ему. Интерфейс, в котором лежит указатель на структуру, и nil интерфейс сравнимы между собой. Если вы сравните интерфейс, в котором лежит указатель на структуру, с nil, результат будет “false”, потому что интерфейс не пустой. Однако, если вы сравните интерфейс с интерфейсом, содержащим nil указатель, результат будет “false”. title12345678910111213141516type SomeInterface interface &#123; SomeMethod()&#125;type SomeStruct struct&#123;&#125;func (s *SomeStruct) SomeMethod() &#123;&#125;func main() &#123; var s SomeStruct var i1 SomeInterface = &amp;s var i2 SomeInterface fmt.Println(i1 == nil) // false fmt.Println(i2 == nil) // true&#125; В примере выше мы создаем интерфейс SomeInterface с методом SomeMethod. Внутри интерфейса i1 лежит указатель на структуру SomeStruct, а интерфейс i2 является пустым интерфейсом. Сравнивая i1 с nil, мы получаем “false”, так как интерфейс i1 не пустой. Сравнивая i2 с nil, мы получаем “true”, так как интерфейс i2 является пустым интерфейсом. Чем any отличается от пустого интерфейса?Пустой интерфейс в Go (nil интерфейс) не хранит значение. Если интерфейс пустой, то его сравнение с nil будет всегда возвращать true. Тип any (тоже известный как интерфейс interface&#123;&#125;) в Go - это специальный тип интерфейса, который может хранить значение любого типа. Тип any является универсальным типом и может быть использован, когда нужно написать обобщенный код, который будет работать с различными типами. title1234567func main() &#123; var i1 interface&#123;&#125; var i2 interface&#123;&#125; = (*SomeStruct)(nil) fmt.Println(i1 == nil) // true fmt.Println(i2 == nil) // false&#125; Чем пустой интерфейс отличается от пустой структуры?Пустой интерфейс (interface{}) и пустая структура (struct{}) являются двумя различными понятиями в Go. Пустая структура (struct{}) не содержит никаких полей и не реализует никаких методов. Она используется в основном для создания переменных, которые не содержат никаких данных. Например: title1var emptyStruct struct&#123;&#125; Пустой интерфейс (interface{}), с другой стороны, может указывать на любое значение любого типа. Он не имеет никаких методов и не содержит никаких данных. Он используется в основном для передачи значений различных типов в функции или методы. Например: title1234var emptyInterface interface&#123;&#125;emptyInterface = 10emptyInterface = &quot;hello&quot;emptyInterface = struct&#123;&#125;&#123;&#125; Таким образом, основное отличие заключается в том, что пустая структура не может указывать на значения различных типов, в то время как пустой интерфейс может. title123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Abser interface &#123; Abs() float64&#125;func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat implements Abser a = &amp;v // a *Vertex implements Abser реализует интерфейс a = v // Ошибка! v - это Vertex (а не *Vertex) и НЕ реализует интерфейс fmt.Println(a.Abs())&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Интерфейсы","slug":"Вопрос-Ответ/Интерфейсы","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B/"},{"name":"Интерфейсы","slug":"Golang/Старт/Интерфейсы","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Указатели","slug":"types/pointers","date":"2024-06-01T07:11:00.000Z","updated":"2024-06-02T09:11:50.145Z","comments":true,"path":"2024/06/01/types/pointers/","link":"","permalink":"https://goxpert.ru/2024/06/01/types/pointers/","excerpt":"","text":"Что такое указатель (pointer)?Указатель в программировании - это переменная, которая хранит адрес другой переменной в памяти. В Go, указатели используются для того, чтобы иметь возможность изменять значение переменной напрямую или для оптимизации производительности при работе с большими структурами данных. Вы можете получить адрес переменной с помощью оператора &amp;, а затем этот адрес можно сохранить в указателе. Для доступа к значению, на которое указывает указатель, используется оператор *. Вот пример: 1234567891011package mainimport &quot;fmt&quot;func main() &#123; var x int = 10 var p *int p = &amp;x // Получаем адрес переменной x и сохраняем его в p fmt.Println(*p) // Выводим значение переменной, на которую указывает p&#125; В этом примере p является указателем на x, и *p дает нам доступ к значению x. Что такое ссылка на значение?В Go, ссылка на значение обычно означает использование указателей. Указатель - это переменная, которая хранит адрес другой переменной. Вы можете получить адрес переменной с помощью оператора &amp;, а затем этот адрес можно сохранить в указателе. Для доступа к значению, на которое указывает указатель, используется оператор *. Вот пример: 1234567891011package mainimport &quot;fmt&quot;func main() &#123; var x int = 10 var p *int p = &amp;x // Получаем адрес переменной x и сохраняем его в p fmt.Println(*p) // Выводим значение переменной, на которую указывает p&#125; В этом примере p является указателем на x, и *p дает нам доступ к значению x. Чем отличается ссылка от указателя?В Go, термины “ссылка” и “указатель” часто используются взаимозаменяемо, но они имеют некоторые различия. Указатель - это переменная, которая хранит адрес другой переменной. Указатели могут быть нулевыми, что означает, что они не указывают ни на одну переменную. Ссылка - это альтернативное имя для уже существующей переменной. В Go, ссылки как таковые не существуют, но аналогом являются указатели. Основное различие между ними заключается в том, что указатели могут быть переназначены для указания на разные переменные во время выполнения, в то время как ссылки, как правило, не могут быть изменены после их инициализации (хотя в Go это не применимо, так как нет ссылок в традиционном понимании этого термина). Чем чревато передавать структуру по ссылке?Передача структуры по ссылке в Go означает передачу указателя на структуру. Это может иметь следующие последствия: Изменение оригинальной структуры: Поскольку вы передаете указатель, любые изменения, которые вы вносите в структуру внутри функции, будут отражаться на оригинальной структуре. Это может быть как полезным, так и опасным, в зависимости от того, ожидаете ли вы эти изменения. Производительность: Передача структуры по ссылке обычно быстрее, чем передача по значению, особенно для больших структур, поскольку не требуется копирование всей структуры. Nullability: Указатели могут быть nil, в то время как структуры - нет. Это значит, что если вы передаете структуру по ссылке, вам нужно быть уверенным, что она не nil, прежде чем обращаться к ее полям, иначе вы получите панику во время выполнения. В общем, передача структуры по ссылке может быть полезной для оптимизации производительности и для изменения оригинальной структуры, но требует более внимательного обращения, чтобы избежать ошибок во время выполнения. Для чего используются указатели?Указатели в Go используются по нескольким причинам: Изменение значения в функции: Если вы хотите, чтобы функция изменяла значение переменной, вы можете передать указатель на эту переменную в функцию. Это позволяет функции напрямую изменять значение переменной, а не ее копию. Оптимизация производительности: Для больших структур данных передача указателей может быть более эффективной, чем передача значений, поскольку передача значений включает в себя копирование всей структуры данных. Работа с динамическими структурами данных: Указатели необходимы для создания сложных структур данных, таких как связанные списки, деревья, графы и т.д. Интерфейсы и полиморфизм: Указатели используются для реализации интерфейсов и полиморфизма. Если методы определены для указателя на тип, то только указатели этого типа могут использоваться для вызова этих методов. Вот пример использования указателей для изменения значения в функции: 12345678910111213package mainimport &quot;fmt&quot;func increment(x *int) &#123; *x = *x + 1&#125;func main() &#123; var x int = 1 increment(&amp;x) fmt.Println(x) // Выводит 2&#125; В этом примере функция increment принимает указатель на int и увеличивает значение, на которое указывает этот указатель. Для чего в практике используешь указатели?В практическом программировании на Go указатели используются в следующих ситуациях: Изменение значения переменной в функции: Если вы хотите изменить значение переменной внутри функции, вы передаете указатель на эту переменную в функцию. Это позволяет функции напрямую изменять значение переменной, а не ее копию. Оптимизация производительности: Для больших структур данных передача указателей может быть более эффективной, чем передача значений, поскольку передача значений включает в себя копирование всей структуры данных. Работа с динамическими структурами данных: Указатели необходимы для создания сложных структур данных, таких как связанные списки, деревья, графы и т.д. Интерфейсы и полиморфизм: Указатели используются для реализации интерфейсов и полиморфизма. Если методы определены для указателя на тип, то только указатели этого типа могут использоваться для вызова этих методов. Опциональные поля в структурах: В Go, указатели могут быть nil, что позволяет им использоваться для представления опциональных полей в структурах. Работа с внешними ресурсами: Указатели часто используются при работе с внешними ресурсами, такими как файлы или сетевые соединения. Это позволяет функциям и методам изменять состояние этих ресурсов. Какие есть средства для работы с указателями?В Go есть несколько ключевых средств для работы с указателями: Оператор &amp;: Этот оператор используется для получения адреса переменной. Например, если x - это переменная, то &amp;x - это адрес этой переменной. Оператор *: Этот оператор используется для доступа к значению, на которое указывает указатель. Например, если p - это указатель на int, то *p - это int, на который указывает p. Функция new: Эта функция создает новую переменную заданного типа, инициализирует ее нулем и возвращает указатель на нее. Вот пример использования этих средств: 123456789101112package mainimport &quot;fmt&quot;func main() &#123; x := 1 p := &amp;x // Получаем адрес переменной x fmt.Println(*p) // Выводим значение, на которое указывает p y := new(int) // Создаем новую переменную типа int и получаем указатель на нее fmt.Println(*y) // Выводит 0, так как новые переменные инициализируются нулем&#125; В этом примере p - это указатель на x, и *p дает нам доступ к значению x. y - это указатель на новую переменную int, инициализированную нулем. Когда лучше использовать/не использовать указатели?Указатели в Go могут быть полезными, но их использование зависит от конкретной ситуации. Вот несколько рекомендаций: Используйте указатели, когда: Вы хотите изменить значение переменной внутри функции. Если вы передаете переменную по значению, функция получит копию этой переменной, и любые изменения, которые вы внесете, не повлияют на исходную переменную. Если вы передаете переменную по ссылке (т.е. передаете указатель на нее), функция сможет изменить исходную переменную. Вы работаете с большими структурами данных. Передача больших структур данных по значению может быть накладной с точки зрения производительности, поскольку это требует копирования всей структуры. Передача указателя на структуру вместо этого может быть более эффективной. Вы хотите иметь возможность присвоить переменной значение nil. В Go, только указатели могут иметь значение nil. Избегайте использования указателей, когда: Вы работаете с небольшими структурами данных или простыми типами. Для небольших структур данных или простых типов, таких как int или bool, передача по значению обычно быстрее и безопаснее. Вы не хотите, чтобы функция изменяла исходную переменную. Если вы передаете переменную по значению, функция не сможет изменить исходную переменную, что может быть полезно для предотвращения неожиданных побочных эффектов. Вы хотите избежать ошибок во время выполнения, связанных с nil. Если вы используете указатель, вам нужно быть уверенным, что он не nil, прежде чем обращаться к его значению, иначе вы получите панику во время выполнения.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Указатели","slug":"Вопрос-Ответ/Указатели","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8/"},{"name":"Указатели","slug":"Golang/Старт/Указатели","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Структуры","slug":"types/structs","date":"2024-06-01T07:10:00.000Z","updated":"2024-06-01T18:44:23.938Z","comments":true,"path":"2024/06/01/types/structs/","link":"","permalink":"https://goxpert.ru/2024/06/01/types/structs/","excerpt":"","text":"Имеет ли значение порядок полей в структуре?Да, порядок полей в структуре Go может иметь значение в некоторых случаях. Выравнивание памяти: Go размещает поля структур в соответствии с гарантиями выравнивания для типов полей. Это может влиять на общий размер структуры и использование памяти. Источники: Stackoverflow От чего зависит размер выравнивания в структуре?Размер выравнивания в структуре в Go зависит от нескольких факторов: Тип данных: Размер выравнивания обычно зависит от типа данных. Например, int32 требует выравнивания по 4 байтам. Порядок полей: Порядок полей в структуре может влиять на размер выравнивания. Если поля структуры переставить, размер структуры может измениться. Архитектура системы: Размер выравнивания также может зависеть от архитектуры системы. Например, на 32-битной архитектуре структуры выравниваются под 4 байта. Важно отметить, что выравнивание влияет на производительность и использование памяти, поэтому его следует учитывать при проектировании структур.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Структуры","slug":"Вопрос-Ответ/Структуры","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B/"},{"name":"Структуры","slug":"Golang/Старт/Структуры","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Строки","slug":"types/strings","date":"2024-06-01T07:09:00.000Z","updated":"2024-06-03T07:27:11.751Z","comments":true,"path":"2024/06/01/types/strings/","link":"","permalink":"https://goxpert.ru/2024/06/01/types/strings/","excerpt":"","text":"Что такое string или строки?Строка в golang - это последовательность символов, которая представляет собой текстовые данные.Строки в golang объявляются с типом string и заключаются в двойные кавычки, например: 123var s string = &quot;hello&quot;// или сокращенная записьs := &quot;hey&quot; Строки в golang являются неизменяемыми(immutable), то есть их нельзя модифицировать после создания. Однако, можно создавать новые строки из существующих, используя различные операции и функции. Например, можно склеивать строки с помощью оператора +, сравнивать строки с помощью оператора ==, или применять функции из пакета strings для поиска, замены, преобразования и других манипуляций со строками. Строки в golang хранят символы в кодировке UTF-8, которая поддерживает множество языков и специальных символов. Каждый символ в строке называется руной (rune), которая является псевдонимом для типа int32. Руны можно получать из строк с помощью цикла for-range или функции range, а также преобразовывать в строки с помощью функции string. Источники: Programiz DigitalOcean Какие особенности есть у string?Строка в golang - это неизменяемая последовательность символов в кодировке UTF-8, которая представляет собой текстовые данные. Строки в golang имеют тип string и заключаются в двойные кавычки или обратные апострофы. Строки в golang поддерживают множество языков и специальных символов, включая русские буквы и эмодзи. Строки в golang можно объединять, сравнивать, искать, заменять, преобразовывать и выполнять другие манипуляции с помощью различных функций из пакета strings. Строки в golang также можно преобразовывать в руны (кодовые значения символов) и байты (единицы хранения данных) для более низкоуровневой работы с текстом Golangify Как устроена строка внутри, а точнее reflect.String и reflect.StringHeader?reflect.String - это псевдоним для типа string, который является неизменяемой последовательностью символов в кодировке UTF-8. reflect.StringHeader - это структура, которая содержит два поля: Data и Len. Data - это указатель на первый байт строки, а Len - это длина строки в байтах. Структура reflect.StringHeader может быть получена из строки с помощью функции unsafe.Pointer, которая преобразует любое значение в указатель безопасного типа. Например, можно использовать такой код: 123s := &quot;hello&quot;sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))fmt.Println(sh.Data, sh.Len) // выводит адрес и длину строки Структура reflect.StringHeader может быть также использована для создания новой строки из существующей, изменяя ее указатель или длину. Например, можно использовать такой код: 12345s := &quot;hello, world!&quot;sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))sh.Data += 7 // сдвигаем указатель на 7 байтовsh.Len -= 7 // уменьшаем длину на 7 байтовfmt.Println(s) // выводит &quot;world!&quot; Однако, такое использование reflect.StringHeader может быть опасным, так как оно нарушает неизменяемость строк и может привести к непредвиденным ошибкам или поведению. Например, если мы изменим длину строки больше, чем ее емкость, то мы можем получить доступ к памяти, которая не принадлежит строке, и вызвать панику или нарушение сегментации. Также, если мы изменим указатель на данные, то мы можем потерять ссылку на оригинальную строку и вызвать утечку памяти или сборку мусора. Поэтому, reflect.String и reflect.StringHeader следует использовать с осторожностью и только в тех случаях, когда это необходимо для решения конкретной задачи. В большинстве случаев, можно обойтись стандартными функциями и методами для работы со строками в golang. 123456789var s string = &quot;Let&#x27;s&quot;fmt.Println(s)t += &quot; Go&quot; // выделяется новая память на стекеfmt.Println(s)smile := &quot;This is smile 😊&quot;fmt.Printf(&quot;len %v, rune %v\\n&quot;, len(smile), utf8.RuneCountInString(smile))fmt.Println(smile) Напиши быструю инверсию строки(abc -&gt; cba) 1234567891011// Package reverse can reverse things, particularly strings.package reverse// String returns its argument string reversed rune-wise left to right.func String(s string) string &#123; r := []rune(s) for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 &#123; r[i], r[j] = r[j], r[i] &#125; return string(r)&#125; Для общего развития можно посмотреть и на Ускорение конкатенации строк в Go своими руками","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Строки","slug":"Вопрос-Ответ/Строки","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8/"},{"name":"Строки","slug":"Golang/Старт/Строки","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Массивы и слайсы","slug":"types/array-slice","date":"2024-06-01T07:08:00.000Z","updated":"2024-06-01T17:43:41.332Z","comments":true,"path":"2024/06/01/types/array-slice/","link":"","permalink":"https://goxpert.ru/2024/06/01/types/array-slice/","excerpt":"","text":"Что такое слайс?Слайс в golang - это динамический массив, который может хранить элементы одного типа. Слайс имеет нефиксированную длину, которая может изменяться в процессе работы с ним. Слайс также имеет вместимость, которая определяет, сколько элементов может поместиться в слайс без выделения новой памяти. Слайс можно создавать из массивов, с помощью функции make или литералов слайсов. 12345type slice struct &#123; array unsafe.Pointer len int cap int&#125; Слайс можно считать как ссылку на массив, который содержит элементы слайса.Слайс состоит из трех полей: указателя на первый элемент массива, длины слайса и вместимости слайса.Слайс можно передавать в функции по значению, но при этом изменение элементов слайса в функции отразится на исходном слайсе, так как они ссылаются на один и тот же массив. Слайсом можно манипулировать с помощью различных операций и функций. Например, можно получать подслайсы с помощью оператора [:], добавлять элементы в конец слайса с помощью функции append, копировать элементы из одного слайса в другой с помощью функции copy, сортировать элементы слайса с помощью функции sort, и так далее. Чем массив отличается от слайса?Массив и слайс в golang - это структуры данных, которые могут хранить элементы одного типа. Однако, между ними есть несколько отличий: Массив имеет фиксированный размер, который определяется при его создании. Слайс имеет переменную длину, которая может изменяться в процессе работы с ним. Массив является значением, а слайс - ссылкой. При передаче массива в функцию или присваивании его другой переменной, происходит копирование всех его элементов. При передаче слайса в функцию или присваивании его другой переменной, происходит копирование только его заголовка, а не элементов. Массив можно сравнивать с другим массивом того же размера и типа с помощью оператора ==. Слайс нельзя сравнивать с другим слайсом с помощью оператора ==, только с nil. Массив можно инициализировать с помощью литерала массива, указав его размер и элементы в фигурных скобках. Слайс можно инициализировать с помощью литерала слайса, не указывая его размер, или с помощью функции make, указав его длину и вместимость Как работает append?Функция append в golang позволяет добавлять элементы в конец слайса, увеличивая его длину и вместимость при необходимости. Функция append принимает слайс и один или несколько элементов того же типа, что и слайс, и возвращает новый слайс, содержащий все элементы исходного слайса и добавленные элементы. Например: 123s := []int&#123;1, 2, 3&#125; // создаем слайс из трех элементовs = append(s, 4, 5) // добавляем два элемента в конец слайсаfmt.Println(s) // выводит [1 2 3 4 5] Функция append может также принимать другой слайс в качестве аргумента, если он заключен в оператор … Это позволяет объединять два слайса в один. Например: 1234s1 := []int&#123;1, 2, 3&#125; // создаем первый слайсs2 := []int&#123;4, 5, 6&#125; // создаем второй слайсs3 := append(s1, s2...) // добавляем второй слайс в конец первого слайсаfmt.Println(s3) // выводит [1 2 3 4 5 6] Функция append работает таким образом, что если вместимость исходного слайса достаточна для добавления новых элементов, то она просто копирует их в свободное пространство массива, на который ссылается слайс. Если же вместимость исходного слайса недостаточна, то функция append выделяет новый массив большего размера, копирует в него все элементы исходного слайса и добавляет новые элементы. Затем функция append возвращает новый слайс, который ссылается на новый массив. До какого размера можно увеличивать слайс?Размер слайса в golang ограничен только доступной памятью в системе. Однако, при увеличении размера слайса с помощью функции append, может происходить перевыделение памяти, если вместимость исходного слайса недостаточна для добавления новых элементов. При этом, функция append выделяет новый массив большего размера, копирует в него все элементы исходного слайса и добавляет новые элементы. Затем функция append возвращает новый слайс, который ссылается на новый массив. При перевыделении памяти, функция append следует определенной стратегии, чтобы избежать частого копирования и минимизировать оверхед. При текущем размере слайса менее 256 элементов, размер памяти увеличивается вдвое (вне зависимости от запрашиваемой cap). При размере слайса больше 256 элементов, слайс увеличивается на четверть текущего размера. Например: 12345678910s := make([]int, 0, 5) // создаем слайс с длиной 0 и вместимостью 5fmt.Println(len(s), cap(s)) // выводит 0 5s = append(s, 1, 2, 3, 4, 5) // добавляем 5 элементов в слайсfmt.Println(len(s), cap(s)) // выводит 5 5s = append(s, 6) // добавляем еще один элемент в слайсfmt.Println(len(s), cap(s)) // выводит 6 10 - вместимость увеличилась вдвоеs = append(s, 7, 8, 9, 10) // добавляем еще 4 элемента в слайсfmt.Println(len(s), cap(s)) // выводит 10 10s = append(s, 11) // добавляем еще один элемент в слайсfmt.Println(len(s), cap(s)) // выводит 11 20 - вместимость увеличилась вдвое Берем от слайса слайс, куда будет указывать его указатель?Если мы берем от слайса слайс, то его указатель будет указывать на тот же массив, что и указатель исходного слайса, но с другим смещением. Например, если мы имеем слайс s, который ссылается на массив [1, 2, 3, 4, 5], и мы берем от него подслайс s[1:3], то его указатель будет указывать на тот же массив, но с элемента 2. То есть, подслайс будет содержать элементы [2, 3] из исходного массива. Это означает, что если мы изменим элементы подслайса, то это отразится на исходном слайсе и наоборот, так как они ссылаются на один и тот же массив. Однако, если мы добавим элементы в подслайс с помощью функции append, то это может привести к перевыделению памяти и созданию нового массива, если вместимость подслайса недостаточна. В этом случае, подслайс будет ссылаться на новый массив, а исходный слайс - на старый. В чем разница между слайсом указателей и слайсом значений с точки зрения вызова функции?Разница между слайсом указателей и слайсом значений с точки зрения вызова функции заключается в том, как они передаются и изменяются внутри функции. Слайс указателей - это слайс, который содержит указатели на элементы другого типа, например: 1var sp []*int // слайс указателей на int Слайс значений - это слайс, который содержит элементы другого типа, например: 1var sv []int // слайс значений int Когда мы передаем слайс указателей в функцию, мы копируем только заголовок слайса, который содержит указатель на первый элемент, длину и вместимость. Однако, сами элементы слайса, на которые указывают указатели, не копируются. Это означает, что если мы изменяем элементы слайса в функции, то это отразится на исходном слайсе, так как они ссылаются на одни и те же значения. Например: 123456789101112131415func main() &#123; x := 1 y := 2 z := 3 sp := []*int&#123;&amp;x, &amp;y, &amp;z&#125; // создаем слайс указателей fmt.Println(*sp[0], *sp[1], *sp[2]) // выводит 1 2 3 modifySlicePointers(sp) // передаем слайс в функцию fmt.Println(*sp[0], *sp[1], *sp[2]) // выводит 10 20 30&#125;func modifySlicePointers(sp []*int) &#123; *sp[0] = 10 // изменяем значение, на которое указывает первый элемент слайса *sp[1] = 20 // изменяем значение, на которое указывает второй элемент слайса *sp[2] = 30 // изменяем значение, на которое указывает третий элемент слайса&#125; Когда мы передаем слайс значений в функцию, мы также копируем только заголовок слайса, который содержит указатель на первый элемент, длину и вместимость. Однако, сами элементы слайса, на которые указывает указатель, также не копируются. Это означает, что если мы изменяем элементы слайса в функции, то это также отразится на исходном слайсе, так как они ссылаются на одни и те же значения. Например: 123456789101112func main() &#123; sv := []int&#123;1, 2, 3&#125; // создаем слайс значений fmt.Println(sv[0], sv[1], sv[2]) // выводит 1 2 3 modifySliceValues(sv) // передаем слайс в функцию fmt.Println(sv[0], sv[1], sv[2]) // выводит 10 20 30&#125;func modifySliceValues(sv []int) &#123; sv[0] = 10 // изменяем значение первого элемента слайса sv[1] = 20 // изменяем значение второго элемента слайса sv[2] = 30 // изменяем значение третьего элемента слайса&#125; Стоит быть внимательным при добавлении элементов в слайс в функции с помощью append, так как мы изменяем копию структуры слайса. В этом случае, слайс в функции будет иметь другие значния len, cap и, возможно, ссылки на массив. Это означает, что добавленные элементы не будут видны в исходном слайсе. Например: 12345678910func main() &#123; sv := []int&#123;1, 2, 3&#125; // создаем слайс значений appendSliceValues(sv) // передаем слайс в функцию fmt.Println(sv) // выводит [1 2 3]&#125;func appendSliceValues(sv []int) &#123; sv = append(sv, 4) // добавляем элемент в слайс fmt.Println(sv) // выводит [1 2 3 4]&#125; Если мы хотим, чтобы добавленные элементы сохранялись в исходном слайсе, мы должны возвращать слайс из функции и присваивать его исходному слайсу. Например: 12345678910func main() &#123; sv := []int&#123;1, 2, 3&#125; // создаем слайс значений sv = appendSliceValues(sv) // передаем слайс в функцию и присваиваем его исходному слайсу fmt.Println(sv) // выводит [1 2 3 4]&#125;func appendSliceValues(sv []int) []int &#123; sv = append(sv, 4) // добавляем элемент в слайс return sv // возвращаем слайс из функции&#125; Какие есть ограничения при работе со слайсом?При работе со слайсом есть некоторые ограничения, которые нужно учитывать: Слайс не может содержать элементы разных типов, только одного. Для хранения элементов разных типов нужно использовать структуры, интерфейсы или пустые интерфейсы (interface{}). Слайс не может быть сравнен с другим слайсом с помощью оператора ==, только с nil. Для сравнения двух слайсов нужно использовать цикл или функцию reflect.DeepEqual. Слайс не может быть использован в качестве ключа мапы, так как он не является хешируемым типом. Для использования слайса в качестве ключа мапы нужно преобразовать его в строку или другой хешируемый тип. Слайс не может быть константой, так как он является ссылочным типом. Для объявления слайса нужно использовать var, := или make. Слайс не может быть безопасно передан в функцию или возвращен из функции, так как он ссылается на массив, который может быть изменен в другом месте. Для безопасной передачи или возврата слайса нужно копировать его элементы в новый слайс с помощью функции copy или среза [:]. С какой скоростью идет поиск в массиве и почему?Самый простой алгоритм поиска в массиве - это линейный поиск, который перебирает все элементы массива по порядку, пока не найдет искомый элемент или не дойдет до конца массива. Скорость линейного поиска пропорциональна длине массива, то есть чем больше элементов в массиве, тем дольше будет идти поиск. Сложность линейного поиска в худшем случае составляет O(n), где n - это количество элементов в массиве. Какая есть функции для создания слайса с длиной отличной от нуля?Для создания слайса с длиной отличной от нуля в golang, можно использовать одну из следующих функций: Функция make, которая принимает тип слайса, длину и вместимость, и возвращает слайс с заданными параметрами. Например: 1s := make([]int, 3, 5) // создает слайс из трех целых чисел с вместимостью пять Функция append, которая принимает слайс и один или несколько элементов того же типа, что и слайс, и возвращает новый слайс, содержащий все элементы исходного слайса и добавленные элементы. Например: 12s := []int&#123;&#125; // создает пустой слайсs = append(s, 1, 2, 3) // добавляет три элемента в слайс Литерал слайса, который позволяет инициализировать слайс с помощью фигурных скобок и перечисления элементов. Например: 1s := []int&#123;1, 2, 3&#125; // создает слайс из трех целых чисел Допустима ли конкуррентная работа со слайсом?Такая работа может быть допустима, если соблюдены определенные условия и предосторожности: Во-первых, конкуррентное чтение слайса не представляет опасности, если никто не пишет в слайс в то же время. То есть, можно безопасно читать слайс из нескольких горутин, если слайс не изменяется. Во-вторых, конкуррентная запись в слайс может привести к гонке данных (data race), если не использовать синхронизацию или атомарные операции. Для предотвращения гонки данных, можно использовать один из следующих способов: Использовать мьютекс sync.Mutex или sync.RWMutex для защиты слайса от одновременного доступа. Использовать атомарные операции (sync/atomic) для изменения отдельных элементов слайса. Использовать каналы для передачи слайса между горутинами.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Массивы и слайсы","slug":"Вопрос-Ответ/Массивы-и-слайсы","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%B8-%D1%81%D0%BB%D0%B0%D0%B9%D1%81%D1%8B/"},{"name":"Массивы и слайсы","slug":"Golang/Старт/Массивы-и-слайсы","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%B8-%D1%81%D0%BB%D0%B0%D0%B9%D1%81%D1%8B/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Дженерики","slug":"common/generics","date":"2024-06-01T07:07:00.000Z","updated":"2024-06-01T17:09:22.473Z","comments":true,"path":"2024/06/01/common/generics/","link":"","permalink":"https://goxpert.ru/2024/06/01/common/generics/","excerpt":"","text":"Чем кодогенерация отличается от дженериков?Кодогенерация и дженерики - это два способа написания кода, который не зависит от конкретных типов данных. Однако, они отличаются по тому, когда и как происходит привязка к типам. Кодогенерация - это процесс создания кода из другого кода или данных с помощью специальных инструментов или команд. Кодогенерация позволяет писать обобщенный код, который затем преобразуется в конкретный код для каждого типа данных. Кодогенерация происходит на этапе компиляции или до него, то есть до выполнения программы. Кодогенерация может быть полезна для увеличения производительности, избежания дублирования кода или реализации сложной логики. Дженерики - это способ написания кода, который параметризован по типам данных. Дженерики позволяют писать функции и типы, которые работают с любыми типами данных, передавая их в качестве аргументов. Дженерики происходят на этапе выполнения, то есть во время работы программы. Дженерики могут быть полезны для повышения выразительности, уменьшения количества кода или поддержки полиморфизма. В какой версии появились дженерики?В языке Go до версии 1.18 не было поддержки дженериков, поэтому разработчики часто использовали кодогенерацию или рефлексию для написания обобщенного кода. В версии 1.18 добавлена поддержка дженериков с помощью параметров типов (type parameters), которые позволяют определять функции и типы, которые принимают любые типы данных в качестве аргументов. Как работают дженерики под капотом?Дженерики под капотом в golang работают с помощью механизма, который называется type substitution (подстановка типов). Это означает, что при компиляции программы, компилятор заменяет параметры типов в дженерических функциях и типах на конкретные типы, которые передаются в качестве аргументов. Например, если мы имеем такую дженерическую функцию: 1234567func Map[F, T any](s T, f F) []T &#123; r := make([]T, len(s)) for i, v := range s &#123; r[i] = f(v) &#125; return r&#125; И мы вызываем ее так: 123s := []int&#123;1, 2, 3&#125;f := func(x int) string &#123; return strconv.Itoa(x) &#125;t := Map(s, f) То компилятор преобразует ее в такую функцию: 1234567func Map_int_string(s []int, f func(int) string) []string &#123; r := make([]string, len(s)) for i, v := range s &#123; r[i] = f(v) &#125; return r&#125; И вызывает ее так: 123s := []int&#123;1, 2, 3&#125;f := func(x int) string &#123; return strconv.Itoa(x) &#125;t := Map_int_string(s, f) 2 Таким образом, дженерики под капотом в golang не требуют дополнительной памяти или рефлексии, так как они превращаются в обычный код для каждого типа данных. Однако, это также означает, что дженерики под капотом в golang могут привести к увеличению размера исполняемого файла, так как для каждого типа данных создается своя версия дженерической функции или типа Источники: Habr Habr","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Generics","slug":"Вопрос-Ответ/Generics","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Generics/"},{"name":"Generics","slug":"Golang/Старт/Generics","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Generics/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Конструкции","slug":"common/constructions","date":"2024-06-01T07:06:00.000Z","updated":"2024-06-01T17:08:54.120Z","comments":true,"path":"2024/06/01/common/constructions/","link":"","permalink":"https://goxpert.ru/2024/06/01/common/constructions/","excerpt":"","text":"Гарантирует ли порядок выполнения конструкция select-case?В Go, порядок выполнения операторов в конструкции select-case не гарантируется. Когда у вас есть несколько операторов case в конструкции select, и они все готовы для выполнения (то есть каналы готовы для чтения/записи), Go выбирает один из них случайным образом. Это означает, что вы не можете предсказать или контролировать, какой оператор case будет выполнен первым, если у вас есть несколько готовых для выполнения операторов case. Это помогает предотвратить блокировку и гарантировать, что все горутины имеют равные шансы на выполнение. Источники: Advicemama Как выглядит конструкция утверждения типа switch?12345switch v := i.(type) &#123;case Type2:case SomeType:default:&#125; Нужно ли в switch-case проставлять break?В языке программирования Go, вам не нужно использовать break в конструкции switch-case. В отличие от некоторых других языков программирования, таких как C++ или Java, каждый case в Go автоматически прерывается, и выполнение программы продолжается после конструкции switch-case. Это означает, что после каждого case не нужно явно указывать break. Однако, если вы хотите, чтобы выполнение продолжилось и в следующем case, вы можете использовать ключевое слово fallthrough. Надеюсь, это помогло вам лучше понять, как работает конструкция switch-case в Go! Если у вас есть еще вопросы, не стесняйтесь задавать.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Select-case","slug":"Вопрос-Ответ/Select-case","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Select-case/"},{"name":"Select-case","slug":"Golang/Старт/Select-case","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Select-case/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Ошибки / Panic","slug":"common/errors-panics","date":"2024-06-01T07:05:00.000Z","updated":"2024-06-01T17:08:04.561Z","comments":true,"path":"2024/06/01/common/errors-panics/","link":"","permalink":"https://goxpert.ru/2024/06/01/common/errors-panics/","excerpt":"","text":"Что такое паника?Паника в программировании на Go обозначает серьезную ошибку, которая обычно приводит к немедленному завершению программы. Паника вызывает немедленное прекращение выполнения функции и начинает раскрутку стека Вы можете использовать функции defer и recover для перехвата и обработки паники. Что используется для обработки паники / Куда нужно помещать recover??В Go для обработки паники используются функции defer и recover: Defer: Функция defer в Go позволяет отложить выполнение функции до того, как окружающая функция завершит свое выполнение. Это полезно для обработки ошибок и очистки ресурсов. Recover: Функция recover используется для перехвата и обработки паник. Она должна вызываться внутри отложенной функции. 12345678func someFunction() &#123; defer func() &#123; if r := recover(); r != nil &#123; fmt.Println(&quot;Recovered from&quot;, r) &#125; &#125;() // Код, который может вызвать панику&#125; Какая парадигма в Golang с точки зрения обработки исключений и ошибок? Явная обработка ошибок: В Go ошибки считаются обычной частью работы программы и должны быть явно обработаны. Если функция может вызвать ошибку, она обычно возвращает значение ошибки в качестве одного из своих возвращаемых значений. Нет исключений: В отличие от некоторых других языков, в Go нет встроенной поддержки исключений. Вместо этого функции возвращают ошибки, которые затем проверяются и обрабатываются. Panic и recover: Go предоставляет функции panic и recover для обработки серьезных ошибок, которые обычно приводят к завершению программы. Однако эти функции обычно используются только в случае критических ошибок, и их использование для обычной обработки ошибок не рекомендуется. Defer: Go также предоставляет ключевое слово defer, которое позволяет отложить выполнение функции до того, как окружающая функция завершит свое выполнение. Это полезно для обработки ошибок и очистки ресурсов. Какие есть функции для оборачивания и сравнения ошибок?В Go есть несколько функций, которые можно использовать для оборачивания и сравнения ошибок: Оборачивание ошибок: fmt.Errorf: Эта функция используется для создания новой ошибки, которая включает в себя сообщение об ошибке и другую ошибку в качестве причины. Начиная с Go 1.13, fmt.Errorf поддерживает оборачивание ошибок с помощью нового модификатора формата %w. Сравнение ошибок: errors.Is: Эта функция используется для проверки, является ли одна ошибка другой ошибкой. Она выполняет проверку на равенство ошибок и учитывает обернутые ошибки. errors.As: Эта функция используется для проверки, является ли ошибка или обернутая ошибка определенным типом. Если это так, она присваивает эту ошибку указанному значению.Эти функции позволяют более эффективно работать с ошибками в Go, обеспечивая больше информации об ошибках и делая код более читаемым. Для чего используются ошибки, а для чего паника?В Go ошибки и паника используются для разных целей: Ошибки: Ошибки в Go обычно используются для обработки ожидаемых проблем, которые могут возникнуть во время выполнения программы. Если функция может вызвать ошибку, она обычно возвращает значение ошибки в качестве одного из своих возвращаемых значений. Эти ошибки затем проверяются и обрабатываются явно в коде. Паника: Паника в Go обычно используется для обработки неожиданных ошибок, которые не могут быть обработаны или которые должны привести к немедленному завершению программы. Паника вызывает немедленное прекращение выполнения функции и начинает раскрутку стека. Вы можете использовать функции defer и recover для перехвата и обработки паники. Важно отметить, что хотя паника может казаться похожей на исключения в некоторых других языках, в Go предпочитают явную обработку ошибок, и паника обычно используется только в случае серьезных ошибок.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Panic","slug":"Вопрос-Ответ/Panic","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Panic/"},{"name":"Panic","slug":"Golang/Старт/Panic","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Panic/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Defer","slug":"common/defer","date":"2024-06-01T07:04:00.000Z","updated":"2024-06-01T17:07:32.113Z","comments":true,"path":"2024/06/01/common/defer/","link":"","permalink":"https://goxpert.ru/2024/06/01/common/defer/","excerpt":"","text":"Что такое defer, как работает, зачем нужен?defer - это ключевое слово в языке программирования Go, которое используется для определения функции, которая должна быть выполнена после возвращения текущей функции, но до возвращения вызвавшей ее функции. Это позволяет очистить ресурсы или выполнить другие задачи, которые необходимо выполнить после завершения основной работы функции. Когда вызывается функция с ключевым словом defer, она не выполняется немедленно. Вместо этого она добавляется в список функций, которые будут выполняться в обратном порядке после возвращения текущей функции. Это означает, что последняя функция, вызванная с ключевым словом defer, будет выполнена первой после возврата текущей функции. Ключевое слово defer полезно для обеспечения правильной очистки ресурсов, например, для закрытия файлов или сетевых соединений. Его также можно использовать для упрощения обработки ошибок, позволяя функции возвращать значение ошибки, а затем обрабатывать эту ошибку в одном месте после возврата функции. Источники: Habr DigitalOcean Код в defer выполняется до return или после?Оператор defer в Go выполняется перед оператором return. Это позволяет удобно управлять ресурсами, такими как закрытие файлов или освобождение памяти, перед тем как функция завершится. defer выполняется после того, как оператор return вычислит возвращаемые значения, но перед фактическим возвращением управления из функции. Пример: 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; defer fmt.Println(changePointer()) fmt.Println(&quot;Third&quot;)&#125;func changePointer() string &#123; defer fmt.Println(&quot;Second&quot;) fmt.Println(&quot;First&quot;) return &quot;Fourth&quot;&#125; Где инициализируется defer, в стеке или куче?Дефер-вызовы в Go инициализируются в стеке, а не в куче. Когда функция, содержащая дефер-вызовы, начинает выполняться, эти вызовы помещаются в стек. Затем, когда функция завершается, стек разворачивается, и дефер-вызовы выполняются в обратном порядке, в котором они были помещены в стек. Это позволяет гарантировать, что ресурсы, такие как файлы или соединения, будут освобождены в правильном порядке, даже если в функции произойдет ошибка. Задача #1title123456789101112131415package mainimport ( &quot;fmt&quot;)func main() &#123; tmp := 101 fmt.Println(tmp) defer func() &#123; fmt.Println(tmp) &#125;() tmp = 202 return&#125; Этот код использует концепцию “замыкания”. Замыкание - это функция, которая имеет доступ к переменным из своего внешнего контекста.В данном случае, анонимная функция, которая откладывается с помощью defer, имеет доступ к переменной tmp из внешнего контекста. Когда вы вызываете defer func() &#123; fmt.Println(tmp) &#125;(), функция “захватывает” текущее значение tmp на момент вызова. Однако в этом случае tmp является ссылкой на переменную во внешнем контексте. Это значит, что если tmp изменяется после вызова defer, то измененное значение будет использоваться в отложенной функции. tmp сначала устанавливается в 101, затем выводится, затем откладывается функция, которая выводит tmp, и наконец tmp изменяется на 202.Когда функция main завершается, отложенная функция вызывается и выводит текущее значение tmp, которое теперь равно 202.В результате, вывод программы будет 101 и 202. Задача #2title123456789101112131415package mainimport ( &quot;fmt&quot;)func main() &#123; tmp := 101 fmt.Println(tmp) defer func(tmpx int) &#123; fmt.Println(tmpx) &#125;(tmp) tmp = 202 return&#125; В этом примере мы передаем tmp в отложенную функцию как аргумент. Это означает, что значение tmp будет скопировано в отложенную функцию, а не ссылаться на переменную во внешнем контексте. В результате, вывод программы будет 101 и 101.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Defer","slug":"Вопрос-Ответ/Defer","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Defer/"},{"name":"Defer","slug":"Golang/Старт/Defer","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Defer/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Пакеты","slug":"common/package","date":"2024-06-01T07:03:00.000Z","updated":"2024-06-01T17:06:56.711Z","comments":true,"path":"2024/06/01/common/package/","link":"","permalink":"https://goxpert.ru/2024/06/01/common/package/","excerpt":"","text":"Что такое пакет?В языке программирования Go, пакет (package) - это коллекция исходных файлов Go, которые находятся в одной и той же директории. Все файлы в одном пакете должны иметь одно и то же имя пакета в начале файла. Пакеты в Go используются для организации и повторного использования кода. Они представляют собой удобный способ разделения кода на отдельные модули. Это позволяет определить пакет с нужной функциональностью один раз и затем использовать его многократно в различных программах. В Go есть два типа пакетов: исполняемые (executable) и библиотеки (reusable). Исполняемые пакеты должны иметь имя main и содержать функцию main, которая является входной точкой в приложение. Все остальные пакеты являются библиотеками и не могут быть напрямую выполнены. Расскажи про папку internalВ Go, папка internal используется для хранения кода, который не должен быть доступен за пределами текущего модуля. Это означает, что любой код, который находится в папке internal (или в подпапках этой папки), может быть импортирован и использован только внутри того же модуля. Это полезно, когда вы хотите скрыть определенные части вашего кода от внешнего мира, чтобы предотвратить его неправильное использование. title123456test├─ go.mod├─ internal│ └─ handler│ └─ opkg.go├─ main.go","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Пакеты","slug":"Вопрос-Ответ/Пакеты","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%B0%D0%BA%D0%B5%D1%82%D1%8B/"},{"name":"Пакеты","slug":"Golang/Старт/Пакеты","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%B0%D0%BA%D0%B5%D1%82%D1%8B/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"Общие вопросы","slug":"overall-questions","date":"2024-06-01T07:02:00.000Z","updated":"2024-06-01T17:05:33.567Z","comments":true,"path":"2024/06/01/overall-questions/","link":"","permalink":"https://goxpert.ru/2024/06/01/overall-questions/","excerpt":"","text":"Какие технологические преимущества экосистемы Go вы можете назвать?В случае с экосистемой Go к потенциальным преимуществам можно отнести: Большое и активное сообщество разработчиков, которые вносят свой вклад в развитие языка Go и его экосистемы. Богатый набор библиотек и инструментов, облегчающих разработку, тестирование и развертывание приложений на Go. Совместимость с широким спектром платформ и систем, что делает его универсальным выбором для создания приложений. Сильная поддержка конкурентного и параллельного программирования, что позволяет повысить производительность и масштабируемость приложений. Упор на простоту и читабельность, что облегчает изучение и использование языка разработчиками и способствует развитию экосистемы. Go - императивный или декларативный? А в чем разница?Go - императивный язык программирования. Это означает, что в нем используются инструкции, которые описывают, как выполнять задачу. В декларативных языках программирования, например, SQL, описывается, что должно быть сделано, а не как это сделать. Какие особенности Go вы можете назвать? Статическая типизация Сборка мусора Конкурентность Параллелизм Отсутствие исключений Строгая типизация Строгая проверка ошибок Почему треды в Go - легковесныеВ Go горутины - это легковесные потоки, управляемые средой выполнения Go. Они более легковесны, чем потоки операционной системы, потому что занимают меньше места в памяти, обычно около 2 килобайт, по сравнению с памятью потока операционной системы, которая может составлять несколько мегабайт. Такой меньший объем памяти позволяет среде выполнения Go создавать большое количество горутин, часто тысячи или даже миллионы, не исчерпывая системных ресурсов. Кроме того, среда выполнения Go использует планировщик, чтобы мультиплексировать горутины на меньшее число потоков операционной системы, что позволяет снизить накладные расходы на создание и управление потоками. Планировщик также может выполнять контекстные переключения между горутинами без участия операционной системы, что может быть быстрее, чем полное контекстное переключение между потоками операционной системы. В целом, сочетание меньшего объема памяти и планировщика пользовательского пространства делает горутины легким и эффективным механизмом для параллельного выполнения в программах на Go. Какие средства обобщенного программирования есть в Go?В Go 1.18 появилась поддержка обобщенного программирования. Обобщенное программирование - это способность писать функции и типы, которые работают с любыми типами данных, а не только с конкретными типами данных. В Go 1.18 обобщенное программирование реализовано с помощью параметризованных типов и функций. Какие средства метапрограммирования есть в Go?В Go нет средств метапрограммирования, таких как макросы, шаблоны. Вместо этого Go предоставляет мощную систему интерфейсов, которая позволяет писать гибкий и расширяемый код, который может быть легко адаптирован к различным типам данных. Какая сортировка используется в Golang?В Go используется алгоритм сортировки “Quicksort”, который является эффективным алгоритмом сортировки с асимптотической сложностью O(n log n). Этот алгоритм используется в стандартной библиотеке “sort” для сортировки слайсов и пользовательских коллекций данных. Какая кодировка используется в Golang?Go поддерживает UTF-8 кодировку по умолчанию для всех строковых типов. Это означает, что вы можете безопасно использовать Unicode символы в строках в Go. Библиотека “unicode/utf8” предоставляет функции для работы с UTF-8 кодированными строками. Можно ли в Golang создать статический метод?В Go нет классов и, следовательно, нет статических методов в традиционном понимании этого термина, как в языках, таких как Java или C++. Однако, вы можете создать функции, которые привязаны к определенному типу данных, что близко к понятию статического метода. Вот пример: 1234567type MyType struct &#123; value int&#125;func (t MyType) StaticMethod() int &#123; return t.value * 2&#125; В этом примере StaticMethod является функцией, которая привязана к типу MyType. Вы можете вызвать эту функцию на экземпляре MyType. 12t := MyType&#123;value: 5&#125;result := t.StaticMethod() // result is 10 Это не совсем то же самое, что статический метод в языках с классами, но это ближайший аналог в Go.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Общие","slug":"Вопрос-Ответ/Общие","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9E%D0%B1%D1%89%D0%B8%D0%B5/"},{"name":"Общие","slug":"Golang/Старт/Общие","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9E%D0%B1%D1%89%D0%B8%D0%B5/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]},{"title":"С 1 Июня 2024!","slug":"helloworld","date":"2024-06-01T07:00:00.000Z","updated":"2024-06-02T07:43:20.347Z","comments":true,"path":"2024/06/01/helloworld/","link":"","permalink":"https://goxpert.ru/2024/06/01/helloworld/","excerpt":"","text":"Добрый день! Сегодня родился сайт GoXpert. Для чего нужен этот сайт: Во-первых, для меня. Да, меня зовут Дмитрий Сигаев. Это сайт, на мой взгляд, поможет мне структурировать свои знания в разных областях, но в основном в экосистеме GO. Я много, что умею, но не могу в нужный для меня момент вынуть из своей головы нужной информации. Данный сайт — это так называемое хранилище моего опыта и якорей для быстрой настройки кратковременной памяти :) Во-вторых, если это полезно для меня, то, на мой взгляд, найдется тот, кому это сайт тоже поможет в чем-то разобраться… В-третьих, хочу выразить благодарность Сергею Артамонову. Спасибо за второй шанс и последствие в виде данного сайта. Надеюсь, быть его падаваном и соавтором публикаций на данном сайта. Ладно, не будем терять времени… поехали… Let’s GO! Небо мой дом... var ap = new APlayer({ element: document.getElementById(\"aplayer-LMBIqxFh\"), narrow: false, autoplay: false, showlrc: 2, music: { title: \"Лови Момент\", author: \"Machete\", url: \"/audio/MacheteTakeIt.mp3\", pic: \"\", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/tags/Golang/"}]},{"title":"Горутины что было","slug":"concurrency/goroutines_old","date":"2024-06-01T06:17:00.000Z","updated":"2024-06-03T08:08:17.512Z","comments":true,"path":"2024/06/01/concurrency/goroutines_old/","link":"","permalink":"https://goxpert.ru/2024/06/01/concurrency/goroutines_old/","excerpt":"","text":"Горутины: всё, что вы хотели знать, но боялись спроситьКратко: Горутины выполняются в порядке очереди, то есть FIFO (First In, First Out). Исполнение горутины прерывается уже не может выполняться: то есть из-за системного вызова при использования синхронизирующих объектов (операции с каналами, мьютексами и т.п.). Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась в очередь. Самостоятельно вызвать runtime.Gosched() чтобы позволить планировщику вызывать goroutine В этой статье я постараюсь кратко и емко рассказать что такое горутины, когда стоит их использовать, какое отношение они имеют к системным потокам, а так же как работает планировщик. Что за горутины?Горутина (goroutine) — это функция, выполняющаяся конкурентно с другими горутинами в том же адресном пространстве. Запустить горутину очень просто:go normalFunc(args…) Функция normalFunc(args…) начнет выполняться асинхронно с вызвавшим ее кодом. Обратите внимание, горутины очень легковесны. Практически все расходы — это создание стека, который очень невелик, хотя при необходимости может расти. Сколько вешать в граммах?Чтобы было проще ориентироваться, рассмотрим цифры полученные опытным путем. В среднем можно рассчитывать примерно на 4,5kb на горутину. То есть, например, имея 4Gb оперативной памяти, вы сможете содержать около 800 тысяч работающих горутин. Может этого и недостаточно, чтобы впечатлить любителей Erlang, но мне кажется, что цифра весьма достойная :) И все же не стоит бездумно выделять функцию в горутину где только можно. Пользу это принесет в следующих случаях: Если нужна асинхронность. Например когда мы работаем с сетью, диском, базой данных, защищенным мьютексом ресурсом и т.п.Если время выполнения функции достаточно велико и можно получить выигрыш, нагрузив другие ядра. «Достаточно велико» — это сколько? Сложный вопрос. Скорее всего решать придется в зависимости от конкретной ситуации. Скажу только, что из моего опыта на моем железе (atom d525 64bit) это ~50мкс. А вообще, тестируйте и развивайте чутье ;) Системные потокиВ исходном коде src/pkg/runtime/proc.c приняты такие термины:G (Goroutine) — ГорутинаM (Machine) — Машина Каждая Машина работает в отдельном потоке и способна выполнять только одну Горутину в момент времени. Планировщик операционной системы, в которой работает программа, переключает Машины. Число работающих Машин ограничено переменной среды GOMAXPROCS или функцией runtime.GOMAXPROCS(n int). По умолчанию оно равно 1. Обычно имеет смысл сделать его равным числу ядер. Планировщик GoЦель планировщика (scheduler) в том, чтобы распределять готовые к выполнению горутины (G) по свободным машинам (M). Sindre Myren RT Capabillites of Google Go. Готовые к исполнению горутины выполняются в порядке очереди, то есть FIFO (First In, First Out). Исполнение горутины прерывается только тогда, когда она уже не может выполняться: то есть из-за системного вызова или использования синхронизирующих объектов (операции с каналами, мьютексами и т.п.). Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась в очередь. Чтобы позволить планировщику сделать это, нужно самостоятельно вызвать runtime.Gosched(). Как только функция вновь готова к выполнению, она снова попадает в очередь. ВыводыСкажу сразу, что меня текущее положение дел сильно удивило. Почему-то подсознательно я ожидал большей «параллельности», наверное потому что воспринимал горутины как легковесные системные потоки. Как видите, это не совсем так. На практике это в первую очередь означает, что иногда стоит использовать runtime.Gosched(), чтобы несколько долгоживущих горутин не остановили на существенное время работу всех других. С другой стороны, такие ситуации встречаются на практике довольно редко. Так же хочу отметить, что на данный момент планировщик отнюдь не совершенен, о чем упоминается в документации и официальном FAQ. В будущем планируются серьезные улучшения. Лично я в первую очередь ожидаю возможность задания горутинам приоритета.","categories":[{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"Горутины","slug":"Вопрос-Ответ/Горутины","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/"},{"name":"Горутины","slug":"Golang/Старт/Горутины","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"}]}],"categories":[{"name":"ОС","slug":"ОС","permalink":"https://goxpert.ru/categories/%D0%9E%D0%A1/"},{"name":"Планировщик ОS","slug":"ОС/Планировщик-ОS","permalink":"https://goxpert.ru/categories/%D0%9E%D0%A1/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA-%D0%9ES/"},{"name":"Cеть","slug":"ОС/Cеть","permalink":"https://goxpert.ru/categories/%D0%9E%D0%A1/C%D0%B5%D1%82%D1%8C/"},{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/categories/Golang/"},{"name":"Старт","slug":"Golang/Старт","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"},{"name":"Вопрос-Ответ","slug":"Вопрос-Ответ","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"},{"name":"SOLID","slug":"Вопрос-Ответ/SOLID","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/SOLID/"},{"name":"SOLID","slug":"Golang/Старт/SOLID","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/SOLID/"},{"name":"Планировщик","slug":"Вопрос-Ответ/Планировщик","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"},{"name":"Планировщик","slug":"Golang/Старт/Планировщик","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"},{"name":"Контекст","slug":"Вопрос-Ответ/Контекст","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82/"},{"name":"Контекст","slug":"Golang/Старт/Контекст","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82/"},{"name":"Горутины","slug":"Вопрос-Ответ/Горутины","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/"},{"name":"Горутины","slug":"Golang/Старт/Горутины","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/"},{"name":"Гонка данных","slug":"Вопрос-Ответ/Гонка-данных","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D0%BD%D0%BA%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/"},{"name":"Гонка данных","slug":"Golang/Старт/Гонка-данных","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%93%D0%BE%D0%BD%D0%BA%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/"},{"name":"Примитивы синхронизации","slug":"Вопрос-Ответ/Примитивы-синхронизации","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/"},{"name":"Примитивы синхронизации","slug":"Golang/Старт/Примитивы-синхронизации","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/"},{"name":"Типы","slug":"Вопрос-Ответ/Типы","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A2%D0%B8%D0%BF%D1%8B/"},{"name":"Типы","slug":"Golang/Старт/Типы","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A2%D0%B8%D0%BF%D1%8B/"},{"name":"Хеш-мапы","slug":"Вопрос-Ответ/Хеш-мапы","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A5%D0%B5%D1%88-%D0%BC%D0%B0%D0%BF%D1%8B/"},{"name":"Хеш-мапы","slug":"Golang/Старт/Хеш-мапы","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A5%D0%B5%D1%88-%D0%BC%D0%B0%D0%BF%D1%8B/"},{"name":"Интерфейсы","slug":"Вопрос-Ответ/Интерфейсы","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B/"},{"name":"Интерфейсы","slug":"Golang/Старт/Интерфейсы","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B/"},{"name":"Указатели","slug":"Вопрос-Ответ/Указатели","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8/"},{"name":"Указатели","slug":"Golang/Старт/Указатели","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8/"},{"name":"Структуры","slug":"Вопрос-Ответ/Структуры","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B/"},{"name":"Структуры","slug":"Golang/Старт/Структуры","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B/"},{"name":"Строки","slug":"Вопрос-Ответ/Строки","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8/"},{"name":"Строки","slug":"Golang/Старт/Строки","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8/"},{"name":"Массивы и слайсы","slug":"Вопрос-Ответ/Массивы-и-слайсы","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%B8-%D1%81%D0%BB%D0%B0%D0%B9%D1%81%D1%8B/"},{"name":"Массивы и слайсы","slug":"Golang/Старт/Массивы-и-слайсы","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%B8-%D1%81%D0%BB%D0%B0%D0%B9%D1%81%D1%8B/"},{"name":"Generics","slug":"Вопрос-Ответ/Generics","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Generics/"},{"name":"Generics","slug":"Golang/Старт/Generics","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Generics/"},{"name":"Select-case","slug":"Вопрос-Ответ/Select-case","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Select-case/"},{"name":"Select-case","slug":"Golang/Старт/Select-case","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Select-case/"},{"name":"Panic","slug":"Вопрос-Ответ/Panic","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Panic/"},{"name":"Panic","slug":"Golang/Старт/Panic","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Panic/"},{"name":"Defer","slug":"Вопрос-Ответ/Defer","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Defer/"},{"name":"Defer","slug":"Golang/Старт/Defer","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Defer/"},{"name":"Пакеты","slug":"Вопрос-Ответ/Пакеты","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%B0%D0%BA%D0%B5%D1%82%D1%8B/"},{"name":"Пакеты","slug":"Golang/Старт/Пакеты","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%B0%D0%BA%D0%B5%D1%82%D1%8B/"},{"name":"Общие","slug":"Вопрос-Ответ/Общие","permalink":"https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9E%D0%B1%D1%89%D0%B8%D0%B5/"},{"name":"Общие","slug":"Golang/Старт/Общие","permalink":"https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9E%D0%B1%D1%89%D0%B8%D0%B5/"}],"tags":[{"name":"Golang, Q&A","slug":"Golang-Q-A","permalink":"https://goxpert.ru/tags/Golang-Q-A/"},{"name":"Golang","slug":"Golang","permalink":"https://goxpert.ru/tags/Golang/"}]}