<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />

    

    
    <title>GoXpert.ru</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="Golang, Q&amp;A" />
    
    <meta name="description" content="Сортировка за константное время">
<meta property="og:type" content="article">
<meta property="og:title" content="GoXpert.ru">
<meta property="og:url" content="https://goxpert.ru/2024/06/01/algorithms/sort/constsort/index.html">
<meta property="og:site_name" content="GoXpert.ru">
<meta property="og:description" content="Сортировка за константное время">
<meta property="og:locale" content="ru_RU">
<meta property="article:published_time" content="2024-06-01T07:04:00.000Z">
<meta property="article:modified_time" content="2024-10-11T14:25:24.212Z">
<meta property="article:author" content="авторы проекта GoXpert">
<meta property="article:tag" content="Golang, Q&amp;A">
<meta name="twitter:card" content="summary">
    

    
        <link rel="alternate" href="/atom.xml" title="GoXpert.ru" type="application/atom+xml" />
        <link rel="alternate" type="application/rss+xml" title="GoXpert.ru" href="https://goxpert.ru/rss.xml" />
        <link rel="alternate" type="application/rss+xml" title="GoXpert.ru" href="https://goxpert.ru/rss-feed.xml" />
     

     
        <link rel="amphtml" href="https://goxpert.ru/amp2024/06/01/algorithms/sort/constsort/">
     


    
        <link rel="icon" href="/css/images/favicon.ico" />
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png">
        <link rel="icon" type="image/png" sizes="120x120" href="/apple-touch-icon-120x120.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
        <link rel="manifest" href="/site.webmanifest">
        <meta name="msapplication-TileColor" content="#da532c">
        <meta name="msapplication-TileImage" content="/mstile-144x144.png">
        <meta name="theme-color" content="#ffffff">
    

    
       <!-- Yandex.RTB -->
       <script>window.yaContextCb=window.yaContextCb||[]</script>
       <script src="https://yandex.ru/ads/system/context.js" async></script>
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/titillium-web/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">


    
<script src="/libs/jquery/3.5.0/jquery.min.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PWEJT515P"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PWEJT515P');
</script>
<!-- End Google Analytics -->

    
    
        <!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(86613025, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
   });
</script>
<!-- /Yandex.Metrika counter -->
    
    
    


</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">Главная</a>
                                </li>
                            
                                    <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Golang/">Golang</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Golang/Algorithms/">Algorithms</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Golang/GRPC/">GRPC</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/">Старт</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Kafka/">Kafka</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Kafka/%D0%A1%D1%82%D0%B0%D1%80%D1%82/">Старт</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/">Вопрос-Ответ</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Defer/">Defer</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Generics/">Generics</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Panic/">Panic</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/SOLID/">SOLID</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/SSA/">SSA</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Select-case/">Select-case</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D0%BD%D0%BA%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/">Гонка данных</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/">Горутины</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B/">Интерфейсы</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82/">Контекст</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%B8-%D1%81%D0%BB%D0%B0%D0%B9%D1%81%D1%8B/">Массивы и слайсы</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9E%D0%B1%D1%89%D0%B8%D0%B5/">Общие</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%B0%D0%BA%D0%B5%D1%82%D1%8B/">Пакеты</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/">Планировщик</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/">Примитивы синхронизации</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8/">Строки</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B/">Структуры</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A2%D0%B8%D0%BF%D1%8B/">Типы</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8/">Указатели</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A5%D0%B5%D1%88-%D0%BC%D0%B0%D0%BF%D1%8B/">Хеш-мапы</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%9E%D0%A1/">ОС</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%9E%D0%A1/CPU-cache/">CPU cache</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%9E%D0%A1/C%D0%B5%D1%82%D1%8C/">Cеть</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%9E%D0%A1/Namespaces/">Namespaces</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%D0%9E%D0%A1/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA-%D0%9ES/">Планировщик ОS</a></li></ul></li></ul>
                                
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/2024/06/01/helloworld/index.html">О сайте</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

<div class="ya-site-form ya-site-form_inited_no" data-bem="{&quot;action&quot;:&quot;/search.html&quot;,&quot;arrow&quot;:false,&quot;bg&quot;:&quot;transparent&quot;,&quot;fontsize&quot;:12,&quot;fg&quot;:&quot;#000000&quot;,&quot;language&quot;:&quot;ru&quot;,&quot;logo&quot;:&quot;rb&quot;,&quot;publicname&quot;:&quot;����� �� ����� GoXpert&quot;,&quot;suggest&quot;:true,&quot;target&quot;:&quot;_blank&quot;,&quot;tld&quot;:&quot;ru&quot;,&quot;type&quot;:2,&quot;usebigdictionary&quot;:true,&quot;searchid&quot;:2519671,&quot;input_fg&quot;:&quot;#000000&quot;,&quot;input_bg&quot;:&quot;#ffffff&quot;,&quot;input_fontStyle&quot;:&quot;normal&quot;,&quot;input_fontWeight&quot;:&quot;normal&quot;,&quot;input_placeholder&quot;:&quot;&quot;,&quot;input_placeholderColor&quot;:&quot;#000000&quot;,&quot;input_borderColor&quot;:&quot;#7f9db9&quot;}">
<form action="https://yandex.ru/search/site/" method="get" target="_blank" accept-charset="utf-8">
<input type="hidden" name="searchid" value="2519671"/>
<input type="hidden" name="l10n" value="ru"/>
<input type="hidden" name="reqenc" value=""/>
<input type="search" name="text" value=""/>
<input type="submit" value="�����"/>
</form>
</div>
    <style type="text/css">.ya-page_js_yes .ya-site-form_inited_no { display: none; }
</style>
<script type="text/javascript">
(function(w,d,c){var s=d.createElement('script'),h=d.getElementsByTagName('script')[0],e=d.documentElement;
if((' '+e.className+' ').indexOf(' ya-page_js_yes ')===-1)
{e.className+=' ya-page_js_yes';}s.type='text/javascript';
s.async=true;s.charset='utf-8';
s.src=(d.location.protocol==='https:'?'https:':'http:')+'//site.yandex.net/v2.0/js/all.js';
h.parentNode.insertBefore(s,h);(w[c]||(w[c]=[])).push(function(){

Ya.Site.Form.init()

})})(window,document,'yandex_site_callbacks');</script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/Golang/">Golang</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/Golang/Algorithms/">Algorithms</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/Golang/Algorithms/Sort/">Sort</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-algorithms/sort/constsort" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <div class="article-meta">
                
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2024/06/01/algorithms/sort/constsort/" class="article-date">
       <time datetime="2024-06-01T07:04:00.000Z" itemprop="datePublished">2024-06-01</time>
    </a>
  </div>


<div class="article-date">
  <i class="fa fa-calendar-plus-o"></i>
  <a href="/2024/06/01/algorithms/sort/constsort/" class="article-date">
     <time datetime="2024-10-11T14:25:24.212Z" itemprop="dateModified">2024-10-11</time>
  </a>
</div>


                

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/Golang-Q-A/" rel="tag">Golang, Q&A</a>
    </div>

                

                

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            

            

            

            <!-- feed_rem_st --><!-- feed_rem_end --><h2 id="Сортировка-за-константное-время"><a href="#Сортировка-за-константное-время" class="headerlink" title="Сортировка за константное время"></a>Сортировка за константное время</h2><p>Такой вопрос я задал одному из наших Российских AI-ассистент разработчика, который ускоряет создание ПО<br>ответ был такой:</p>
<p>Вот пример кода на Golang для сортировки подсчетом:</p>
<p>package main</p>
<p>import (<br>    “fmt”<br>)</p>
<p>// countingSort сортирует массив с использованием алгоритма сортировки подсчетом.<br>func countingSort(arr []int) {<br>    minValue := arr[0]<br>    maxValue := arr[len(arr)-1]<br>    count := make([]int, maxValue-minValue+1)</p>
<pre><code>for _, num := range arr &#123;
    count[num-minValue]++
&#125;

for i := 1; i &lt; len(count); i++ &#123;
    count[i] += count[i-1]
&#125;

index := 0
for _, num := range arr &#123;
    for count[num-minValue] &gt; 0 &#123;
        arr[index] = num
        index++
        count[num-minValue]--
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>func main() {<br>    inputArray := []int{5, 2, 3, 4, 1, 6, 7, 8, 9}<br>    sortedArray := make([]int, len(inputArray))</p>
<pre><code>copy(sortedArray, inputArray) // Копируем исходный массив в новый для сохранения результатов

countingSort(sortedArray)

for _, num := range sortedArray &#123;
    fmt.Printf(&quot;%d &quot;, num)
&#125;
fmt.Println()
</code></pre>
<p>}</p>
<p>Этот код сначала определяет минимальное и максимальное значения в массиве, затем создает массив count, который будет использоваться для подсчета количества каждого элемента. После этого он проходит по массиву и увеличивает счетчик для каждого элемента. Затем он проходит по счетчику и добавляет к нему предыдущее значение, чтобы определить индекс для каждого элемента после сортировки. В конце он проходит по массиву и заменяет элементы на их индексы.</p>
<p>Далее я задал вопрос: Что делает данных код, подробней можешь описать?</p>
<p>Этот код выполняет сортировку подсчетом на слайсе arr.<br>Алгоритм сортировки подсчетом заключается в следующем:</p>
<ol>
<li>Подсчитываем количество каждого элемента в массиве. Для этого мы используем счетчики count.</li>
<li>Используем эти подсчеты для определения индекса каждого элемента после сортировки. Мы создаем массив count и заполняем его нулями. Затем проходим по каждому элементу массива и увеличиваем счетчик для соответствующего элемента.</li>
<li>После того как мы подсчитали количество каждого элемента, мы проходим по счетчикам и добавляем к ним предыдущее значение, чтобы определить индекс для каждого элемента после сортировки.</li>
<li>Наконец, мы проходим по массиву и заменяем каждый элемент на его индекс.</li>
<li>В результате мы получаем отсортированный массив.</li>
</ol>
<p>Следующим вопросом был: Какая сложность данного алгоритма в нотации O?</p>
<p>Сложность алгоритма сортировки подсчетом в нотации O равна O(n). Это означает, что время выполнения алгоритма пропорционально количеству элементов в массиве.</p>
<p>Далее я спросил: А есть более быстрые алгоритмы сортировки?</p>
<p>Да, есть более быстрые алгоритмы сортировки. Например, сортировка выбором (selection sort), которая имеет сложность O(n^2), или сортировка вставками (insertion sort), которая имеет сложность O(n^2) для массивов с неравномерным распределением элементов. Однако, если распределение элементов близко к равномерному, то сортировка подсчетом может быть быстрее.</p>
<p>Но на самом деле не стоит спрашивать у AI-ассистента разработчика, а лучше разобраться самому.<br>Поехали….</p>
<p><a target="_blank" rel="noopener" href="https://habr.com/ru/articles/335920/">https://habr.com/ru/articles/335920/</a></p>
<h1 id="Вступление"><a href="#Вступление" class="headerlink" title="Вступление"></a>Вступление</h1><p>На эту тему написано уже немало статей. Однако я еще не видел статьи, в которой сравниваются все основные сортировки на большом числе тестов разного типа и размера. Кроме того, далеко не везде выложены реализации и описание набора тестов. Это приводит к тому, что могут возникнуть сомнения в правильности исследования. Однако цель моей работы состоит не только в том, чтобы определить, какие сортировки работают быстрее всего (в целом это и так известно). В первую очередь мне было интересно исследовать алгоритмы, оптимизировать их, чтобы они работали как можно быстрее. Работая над этим, мне удалось придумать эффективную формулу для сортировки Шелла.</p>
<p>Во многом статья посвящена тому, как написать все алгоритмы и протестировать их. Если говорить о самом программировании, то иногда могут возникнуть совершенно неожиданные трудности (во многом благодаря оптимизатору C++). Однако не менее трудно решить, какие именно тесты и в каких количествах нужно сделать. Коды всех алгоритмов, которые выложены в данной статье, написаны мной. Доступны и результаты запусков на всех тестах. Единственное, что я не могу показать — это сами тесты, поскольку они весят почти 140 ГБ. При малейшем подозрении я проверял и код, соответствующий тесту, и сам тест. Надеюсь, что статья Вам понравится.</p>
<p>Описание основных сортировок и их реализация</p>
<p>Я постараюсь кратко и понятно описать сортировки и указать асимптотику, хотя последнее в рамках данной статьи не очень важно (интересно же узнать реальное время работы). О потреблении памяти в дальнейшем ничего писать не буду, замечу только, что сортировки, использующие непростые структуры данных (как, например, сортировка деревом), обычно потребляют ее в больших количествах, а остальные сортировки в худшем случае только создают вспомогательный массив. Также существует понятие стабильности (устойчивости) сортировки. Это значит, что относительный порядок элементов при их равенстве не меняется. Это тоже в рамках данной статьи неважно (в конце концов, можно просто прицепить к элементу его индекс), однако в одном месте пригодится.</p>
<p>Сортировка пузырьком / Bubble sort</p>
<p>Будем идти по массиву слева направо. Если текущий элемент больше следующего, меняем их местами. Делаем так, пока массив не будет отсортирован. Заметим, что после первой итерации самый большой элемент будет находиться в конце массива, на правильном месте. После двух итераций на правильном месте будут стоять два наибольших элемента, и так далее. Очевидно, не более чем после n итераций массив будет отсортирован. Таким образом, асимптотика в худшем и среднем случае – O(n2), в лучшем случае – O(n).</p>
<p>Реализация:<br>void bubblesort(int* l, int* r) {<br>    int sz = r - l;<br>    if (sz &lt;= 1) return;<br>    bool b = true;<br>    while (b) {<br>        b = false;<br>        for (int* i = l; i + 1 &lt; r; i++) {<br>            if (*i &gt; *(i + 1)) {<br>                swap(*i, *(i + 1));<br>                b = true;<br>            }<br>        }<br>        r–;<br>    }<br>}</p>
<p>Шейкерная сортировка / Shaker sort</p>
<p>(также известна как сортировка перемешиванием и коктейльная сортировка). Заметим, что сортировка пузырьком работает медленно на тестах, в которых маленькие элементы стоят в конце (их еще называют «черепахами»). Такой элемент на каждом шаге алгоритма будет сдвигаться всего на одну позицию влево. Поэтому будем идти не только слева направо, но и справа налево. Будем поддерживать два указателя begin и end, обозначающих, какой отрезок массива еще не отсортирован. На очередной итерации при достижении end вычитаем из него единицу и движемся справа налево, аналогично, при достижении begin прибавляем единицу и двигаемся слева направо. Асимптотика у алгоритма такая же, как и у сортировки пузырьком, однако реальное время работы лучше.</p>
<p>Реализация:<br>void shakersort(int* l, int* r) {<br>    int sz = r - l;<br>    if (sz &lt;= 1) return;<br>    bool b = true;<br>    int* beg = l - 1;<br>    int* end = r - 1;<br>    while (b) {<br>        b = false;<br>        beg++;<br>        for (int* i = beg; i &lt; end; i++) {<br>            if (*i &gt; *(i + 1)) {<br>                swap(*i, <em>(i + 1));<br>                b = true;<br>            }<br>        }<br>        if (!b) break;<br>        end–;<br>        for (int</em> i = end; i &gt; beg; i–) {<br>            if (*i &lt; *(i - 1)) {<br>                swap(*i, *(i - 1));<br>                b = true;<br>            }<br>        }<br>    }<br>}</p>
<p>Сортировка расческой / Comb sort</p>
<p>Еще одна модификация сортировки пузырьком. Для того, чтобы избавиться от «черепах», будем переставлять элементы, стоящие на расстоянии. Зафиксируем его и будем идти слева направо, сравнивая элементы, стоящие на этом расстоянии, переставляя их, если необходимо. Очевидно, это позволит «черепахам» быстро добраться в начало массива. Оптимально изначально взять расстояние равным длине массива, а далее делить его на некоторый коэффициент, равный примерно 1.247. Когда расстояние станет равно единице, выполняется сортировка пузырьком. В лучшем случае асимптотика равна O(nlogn), в худшем – O(n2). Какая асимптотика в среднем мне не очень понятно, на практике похоже на O(nlogn).</p>
<p>Реализация:<br>void combsort(int* l, int* r) {<br>    int sz = r - l;<br>    if (sz &lt;= 1) return;<br>    double k = 1.2473309;<br>    int step = sz - 1;<br>    while (step &gt; 1) {<br>        for (int* i = l; i + step &lt; r; i++) {<br>            if (*i &gt; *(i + step))<br>                swap(*i, <em>(i + step));<br>        }<br>        step /= k;<br>    }<br>    bool b = true;<br>    while (b) {<br>        b = false;<br>        for (int</em> i = l; i + 1 &lt; r; i++) {<br>            if (*i &gt; *(i + 1)) {<br>                swap(*i, *(i + 1));<br>                b = true;<br>            }<br>        }<br>    }<br>}</p>
<p>Об этих сортировках (пузырьком, шейкерной и расческой) также можно почитать здесь.</p>
<p>Сортировка вставками / Insertion sort</p>
<p>Создадим массив, в котором после завершения алгоритма будет лежать ответ. Будем поочередно вставлять элементы из исходного массива так, чтобы элементы в массиве-ответе всегда были отсортированы. Асимптотика в среднем и худшем случае – O(n2), в лучшем – O(n). Реализовывать алгоритм удобнее по-другому (создавать новый массив и реально что-то вставлять в него относительно сложно): просто сделаем так, чтобы отсортирован был некоторый префикс исходного массива, вместо вставки будем менять текущий элемент с предыдущим, пока они стоят в неправильном порядке.</p>
<p>Реализация:<br>void insertionsort(int* l, int* r) {<br>    for (int *i = l + 1; i &lt; r; i++) {<br>        int* j = i;<br>        while (j &gt; l &amp;&amp; *(j - 1) &gt; <em>j) {<br>            swap(</em>(j - 1), *j);<br>            j–;<br>        }<br>    }<br>}</p>
<p>Сортировка Шелла / Shellsort</p>
<p>Используем ту же идею, что и сортировка с расческой, и применим к сортировке вставками. Зафиксируем некоторое расстояние. Тогда элементы массива разобьются на классы – в один класс попадают элементы, расстояние между которыми кратно зафиксированному расстоянию. Отсортируем сортировкой вставками каждый класс. В отличие от сортировки расческой, неизвестен оптимальный набор расстояний. Существует довольно много последовательностей с разными оценками. Последовательность Шелла – первый элемент равен длине массива, каждый следующий вдвое меньше предыдущего. Асимптотика в худшем случае – O(n2). Последовательность Хиббарда – 2n — 1, асимптотика в худшем случае – O(n1,5), последовательность Седжвика (формула нетривиальна, можете ее посмотреть по ссылке ниже) — O(n4/3), Пратта (все произведения степеней двойки и тройки) — O(nlog2n). Отмечу, что все эти последовательности нужно рассчитать только до размера массива и запускать от большего от меньшему (иначе получится просто сортировка вставками). Также я провел дополнительное исследование и протестировал разные последовательности вида si = a * si — 1 + k * si — 1 (отчасти это было навеяно эмпирической последовательностью Циура – одной из лучших последовательностей расстояний для небольшого количества элементов). Наилучшими оказались последовательности с коэффициентами a = 3, k = 1/3; a = 4, k = 1/4 и a = 4, k = -1/5.</p>
<p>Несколько полезных ссылок:</p>
<p>Сортировка Шелла в русскоязычной Википедии<br>Сортировка Шелла в англоязычной Википедии<br>Статья на Хабре</p>
<p>Реализации:<br>void shellsort(int* l, int* r) {<br>    int sz = r - l;<br>    int step = sz / 2;<br>    while (step &gt;= 1) {<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>        step /= 2;<br>    }<br>}<br>void shellsorthib(int</em> l, int</em> r) {<br>    int sz = r - l;<br>    if (sz &lt;= 1) return;<br>    int step = 1;<br>    while (step &lt; sz) step &lt;&lt;= 1;<br>    step &gt;&gt;= 1;<br>    step–;<br>    while (step &gt;= 1) {<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>        step /= 2;<br>    }<br>}<br>int steps[100];<br>void shellsortsedgwick(int</em> l, int</em> r) {<br>    int sz = r - l;<br>    steps[0] = 1;<br>    int q = 1;<br>    while (steps[q - 1] * 3 &lt; sz) {<br>        if (q % 2 == 0)<br>            steps[q] = 9 * (1 &lt;&lt; q) - 9 * (1 &lt;&lt; (q / 2)) + 1;<br>        else<br>            steps[q] = 8 * (1 &lt;&lt; q) - 6 * (1 &lt;&lt; ((q + 1) / 2)) + 1;<br>        q++;<br>    }<br>    q–;<br>    for (; q &gt;= 0; q–) {<br>        int step = steps[q];<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>    }<br>}<br>void shellsortpratt(int</em> l, int</em> r) {<br>    int sz = r - l;<br>    steps[0] = 1;<br>    int cur = 1, q = 1;<br>    for (int i = 1; i &lt; sz; i++) {<br>        int cur = 1 &lt;&lt; i;<br>        if (cur &gt; sz / 2) break;<br>        for (int j = 1; j &lt; sz; j++) {<br>            cur *= 3;<br>            if (cur &gt; sz / 2) break;<br>            steps[q++] = cur;<br>        }<br>    }<br>    insertionsort(steps, steps + q);<br>    q–;<br>    for (; q &gt;= 0; q–) {<br>        int step = steps[q];<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>    }<br>}<br>void myshell1(int</em> l, int</em> r) {<br>    int sz = r - l, q = 1;<br>    steps[0] = 1;<br>    while (steps[q - 1] &lt; sz) {<br>        int s = steps[q - 1];<br>        steps[q++] = s * 4 + s / 4;<br>    }<br>    q–;<br>    for (; q &gt;= 0; q–) {<br>        int step = steps[q];<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>    }<br>}<br>void myshell2(int</em> l, int</em> r) {<br>    int sz = r - l, q = 1;<br>    steps[0] = 1;<br>    while (steps[q - 1] &lt; sz) {<br>        int s = steps[q - 1];<br>        steps[q++] = s * 3 + s / 3;<br>    }<br>    q–;<br>    for (; q &gt;= 0; q–) {<br>        int step = steps[q];<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>    }<br>}<br>void myshell3(int</em> l, int</em> r) {<br>    int sz = r - l, q = 1;<br>    steps[0] = 1;<br>    while (steps[q - 1] &lt; sz) {<br>        int s = steps[q - 1];<br>        steps[q++] = s * 4 - s / 5;<br>    }<br>    q–;<br>    for (; q &gt;= 0; q–) {<br>        int step = steps[q];<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(*diff, *j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>    }<br>}</p>
<p>Сортировка деревом / Tree sort</p>
<p>Будем вставлять элементы в двоичное дерево поиска. После того, как все элементы вставлены достаточно обойти дерево в глубину и получить отсортированный массив. Если использовать сбалансированное дерево, например красно-черное, асимптотика будет равна O(nlogn) в худшем, среднем и лучшем случае. В реализации использован контейнер multiset.</p>
<p>Здесь можно почитать про деревья поиска:</p>
<p>Википедия<br>Статья на Хабре<br>И ещё статья на Хабре</p>
<p>Реализация:<br>void treesort(int* l, int* r) {<br>    multiset<int> m;<br>    for (int *i = l; i &lt; r; i++)<br>        m.insert(*i);<br>    for (int q : m)<br>        *l = q, l++;<br>}</p>
<p>Гномья сортировка / Gnome sort</p>
<p>Алгоритм похож на сортировку вставками. Поддерживаем указатель на текущий элемент, если он больше предыдущего или он первый — смещаем указатель на позицию вправо, иначе меняем текущий и предыдущий элементы местами и смещаемся влево.</p>
<p>Реализация:<br>void gnomesort(int* l, int* r) {<br>    int *i = l;<br>    while (i &lt; r) {<br>        if (i == l || *(i - 1) &lt;= <em>i) i++;<br>        else swap(</em>(i - 1), *i), i–;<br>    }<br>}</p>
<p>Сортировка выбором / Selection sort</p>
<p>На очередной итерации будем находить минимум в массиве после текущего элемента и менять его с ним, если надо. Таким образом, после i-ой итерации первые i элементов будут стоять на своих местах. Асимптотика: O(n2) в лучшем, среднем и худшем случае. Нужно отметить, что эту сортировку можно реализовать двумя способами – сохраняя минимум и его индекс или просто переставляя текущий элемент с рассматриваемым, если они стоят в неправильном порядке. Первый способ оказался немного быстрее, поэтому он и реализован.</p>
<p>Реализация:<br>void selectionsort(int* l, int* r) {<br>    for (int *i = l; i &lt; r; i++) {<br>        int minz = *i, *ind = i;<br>        for (int *j = i + 1; j &lt; r; j++) {<br>            if (*j &lt; minz) minz = *j, ind = j;<br>        }<br>        swap(*i, *ind);<br>    }<br>}</p>
<p>Пирамидальная сортировка / Heapsort</p>
<p>Развитие идеи сортировки выбором. Воспользуемся структурой данных «куча» (или «пирамида», откуда и название алгоритма). Она позволяет получать минимум за O(1), добавляя элементы и извлекая минимум за O(logn). Таким образом, асимптотика O(nlogn) в худшем, среднем и лучшем случае. Реализовывал кучу я сам, хотя в С++ и есть контейнер priority_queue, поскольку этот контейнер довольно медленный.</p>
<p>Почитать про кучу можно здесь:</p>
<p>Википедия<br>Статья на Хабре</p>
<p>Реализация:<br>template <class T><br>class heap {<br>public:<br>    int size() {<br>        return n;<br>    }<br>    int top() {<br>        return h[0];<br>    }<br>    bool empty() {<br>        return n == 0;<br>    }<br>    void push(T a) {<br>        h.push_back(a);<br>        SiftUp(n);<br>        n++;<br>    }<br>    void pop() {<br>        n–;<br>        swap(h[n], h[0]);<br>        h.pop_back();<br>        SiftDown(0);<br>    }<br>    void clear() {<br>        h.clear();<br>        n = 0;<br>    }<br>    T operator [] (int a) {<br>        return h[a];<br>    }<br>private:<br>    vector<T> h;<br>    int n = 0;<br>    void SiftUp(int a) {<br>        while (a) {<br>            int p = (a - 1) / 2;<br>            if (h[p] &gt; h[a]) swap(h[p], h[a]);<br>            else break;<br>            a–; a /= 2;<br>        }<br>    }<br>    void SiftDown(int a) {<br>        while (2 * a + 1 &lt; n) {<br>            int l = 2 * a + 1, r = 2 * a + 2;<br>            if (r == n) {<br>                if (h[l] &lt; h[a]) swap(h[l], h[a]);<br>                break;<br>            }<br>            else if (h[l] &lt;= h[r]) {<br>                if (h[l] &lt; h[a]) {<br>                    swap(h[l], h[a]);<br>                    a = l;<br>                }<br>                else break;<br>            }<br>            else if (h[r] &lt; h[a]) {<br>                swap(h[r], h[a]);<br>                a = r;<br>            }<br>            else break;<br>        }<br>    }<br>};<br>void heapsort(int* l, int* r) {<br>    heap<int> h;<br>    for (int *i = l; i &lt; r; i++) h.push(*i);<br>    for (int *i = l; i &lt; r; i++) {<br>        *i = h.top();<br>        h.pop();<br>    }<br>}</p>
<p>Быстрая сортировка / Quicksort</p>
<p>Выберем некоторый опорный элемент. После этого перекинем все элементы, меньшие его, налево, а большие – направо. Рекурсивно вызовемся от каждой из частей. В итоге получим отсортированный массив, так как каждый элемент меньше опорного стоял раньше каждого большего опорного. Асимптотика: O(nlogn) в среднем и лучшем случае, O(n2). Наихудшая оценка достигается при неудачном выборе опорного элемента. Моя реализация этого алгоритма совершенно стандартна, идем одновременно слева и справа, находим пару элементов, таких, что левый элемент больше опорного, а правый меньше, и меняем их местами. Помимо чистой быстрой сортировки, участвовала в сравнении и сортировка, переходящая при малом количестве элементов на сортировку вставками. Константа подобрана тестированием, а сортировка вставками — наилучшая сортировка, подходящая для этой задачи (хотя не стоит из-за этого думать, что она самая быстрая из квадратичных).</p>
<p>Реализация:<br>void quicksort(int* l, int* r) {<br>    if (r - l &lt;= 1) return;<br>    int z = *(l + (r - l) / 2);<br>    int* ll = l, *rr = r - 1;<br>    while (ll &lt;= rr) {<br>        while (*ll &lt; z) ll++;<br>        while (*rr &gt; z) rr–;<br>        if (ll &lt;= rr) {<br>            swap(*ll, *rr);<br>            ll++;<br>            rr–;<br>        }<br>    }<br>    if (l &lt; rr) quicksort(l, rr + 1);<br>    if (ll &lt; r) quicksort(ll, r);<br>}<br>void quickinssort(int* l, int* r) {<br>    if (r - l &lt;= 32) {<br>        insertionsort(l, r);<br>        return;<br>    }<br>    int z = *(l + (r - l) / 2);<br>    int* ll = l, *rr = r - 1;<br>    while (ll &lt;= rr) {<br>        while (*ll &lt; z) ll++;<br>        while (*rr &gt; z) rr–;<br>        if (ll &lt;= rr) {<br>            swap(*ll, *rr);<br>            ll++;<br>            rr–;<br>        }<br>    }<br>    if (l &lt; rr) quickinssort(l, rr + 1);<br>    if (ll &lt; r) quickinssort(ll, r);<br>}</p>
<p>Сортировка слиянием / Merge sort</p>
<p>Сортировка, основанная на парадигме «разделяй и властвуй». Разделим массив пополам, рекурсивно отсортируем части, после чего выполним процедуру слияния: поддерживаем два указателя, один на текущий элемент первой части, второй – на текущий элемент второй части. Из этих двух элементов выбираем минимальный, вставляем в ответ и сдвигаем указатель, соответствующий минимуму. Слияние работает за O(n), уровней всего logn, поэтому асимптотика O(nlogn). Эффективно заранее создать временный массив и передать его в качестве аргумента функции. Эта сортировка рекурсивна, как и быстрая, а потому возможен переход на квадратичную при небольшом числе элементов.</p>
<p>Реализация:<br>void merge(int* l, int* m, int* r, int* temp) {<br>    int <em>cl = l, <em>cr = m, cur = 0;<br>    while (cl &lt; m &amp;&amp; cr &lt; r) {<br>        if (<em>cl &lt; <em>cr) temp[cur++] = <em>cl, cl++;<br>        else temp[cur++] = <em>cr, cr++;<br>    }<br>    while (cl &lt; m) temp[cur++] = <em>cl, cl++;<br>    while (cr &lt; r) temp[cur++] = <em>cr, cr++;<br>    cur = 0;<br>    for (int</em> i = l; i &lt; r; i++)<br>         <em>i = temp[cur++];<br>}<br>void _mergesort(int</em> l, int</em> r, int</em> temp) {<br>    if (r - l &lt;= 1) return;<br>    int <em>m = l + (r - l) / 2;<br>    _mergesort(l, m, temp);<br>    _mergesort(m, r, temp);<br>    merge(l, m, r, temp);<br>}<br>void mergesort(int</em> l, int</em> r) {<br>    int</em> temp = new int[r - l];<br>    _mergesort(l, r, temp);<br>    delete temp;<br>}<br>void _mergeinssort(int</em> l, int</em> r, int</em> temp) {<br>    if (r - l &lt;= 32) {<br>        insertionsort(l, r);<br>        return;<br>    }<br>    int <em>m = l + (r - l) / 2;<br>    _mergeinssort(l, m, temp);<br>    _mergeinssort(m, r, temp);<br>    merge(l, m, r, temp);<br>}<br>void mergeinssort(int</em> l, int* r) {<br>    int* temp = new int[r - l];<br>    _mergeinssort(l, r, temp);<br>    delete temp;<br>}</p>
<p>Сортировка подсчетом / Counting sort</p>
<p>Создадим массив размера r – l, где l – минимальный, а r – максимальный элемент массива. После этого пройдем по массиву и подсчитаем количество вхождений каждого элемента. Теперь можно пройти по массиву значений и выписать каждое число столько раз, сколько нужно. Асимптотика – O(n + r — l). Можно модифицировать этот алгоритм, чтобы он стал стабильным: для этого определим место, где должно стоять очередное число (это просто префиксные суммы в массиве значений) и будем идти по исходному массиву слева направо, ставя элемент на правильное место и увеличивая позицию на 1. Эта сортировка не тестировалась, поскольку большинство тестов содержало достаточно большие числа, не позволяющие создать массив требуемого размера. Однако она, тем не менее, пригодилась.</p>
<p>Блочная сортировка / Bucket sort</p>
<p>(также известна как корзинная и карманная сортировка). Пусть l – минимальный, а r – максимальный элемент массива. Разобьем элементы на блоки, в первом будут элементы от l до l + k, во втором – от l + k до l + 2k и т.д., где k = (r – l) / количество блоков. В общем-то, если количество блоков равно двум, то данный алгоритм превращается в разновидность быстрой сортировки. Асимптотика этого алгоритма неясна, время работы зависит и от входных данных, и от количества блоков. Утверждается, что на удачных данных время работы линейно. Реализация этого алгоритма оказалась одной из самых трудных задач. Можно сделать это так: просто создавать новые массивы, рекурсивно их сортировать и склеивать. Однако такой подход все же довольно медленный и меня не устроил. В эффективной реализации используется несколько идей:</p>
<ol>
<li><p>Не будем создавать новых массивов. Для этого воспользуемся техникой сортировки подсчетом – подсчитаем количество элементов в каждом блоке, префиксные суммы и, таким образом, позицию каждого элемента в массиве.</p>
</li>
<li><p>Не будем запускаться из пустых блоков. Занесем индексы непустых блоков в отдельный массив и запустимся только от них.</p>
</li>
<li><p>Проверим, отсортирован ли массив. Это не ухудшит время работы, так как все равно нужно сделать проход с целью нахождения минимума и максимума, однако позволит алгоритму ускориться на частично отсортированных данных, ведь элементы вставляются в новые блоки в том же порядке, что и в исходном массиве.</p>
</li>
<li><p>Поскольку алгоритм получился довольно громоздким, при небольшом количестве элементов он крайне неэффективен. До такой степени, что переход на сортировку вставками ускоряет работу примерно в 10 раз.</p>
</li>
</ol>
<p>Осталось только понять, какое количество блоков нужно выбрать. На рандомизированных тестах мне удалось получить следующую оценку: 1500 блоков для 107 элементов и 3000 для 108. Подобрать формулу не удалось – время работы ухудшалось в несколько раз.</p>
<p>Реализация:<br>void _newbucketsort(int* l, int* r, int* temp) {<br>    if (r - l &lt;= 64) {<br>        insertionsort(l, r);<br>        return;<br>    }<br>    int minz = *l, maxz = *l;<br>    bool is_sorted = true;<br>    for (int *i = l + 1; i &lt; r; i++) {<br>        minz = min(minz, *i);<br>        maxz = max(maxz, *i);<br>        if (<em>i &lt; <em>(i - 1)) is_sorted = false;<br>    }<br>    if (is_sorted) return;<br>    int diff = maxz - minz + 1;<br>    int numbuckets;<br>    if (r - l &lt;= 1e7) numbuckets = 1500;<br>    else numbuckets = 3000;<br>    int range = (diff + numbuckets - 1) / numbuckets;<br>    int</em> cnt = new int[numbuckets + 1];<br>    for (int i = 0; i &lt;= numbuckets; i++)<br>        cnt[i] = 0;<br>    int cur = 0;<br>    for (int</em> i = l; i &lt; r; i++) {<br>        temp[cur++] = *i;<br>        int ind = (<em>i - minz) / range;<br>        cnt[ind + 1]++;<br>    }<br>    int sz = 0;<br>    for (int i = 1; i &lt;= numbuckets; i++)<br>        if (cnt[i]) sz++;<br>    int</em> run = new int[sz];<br>    cur = 0;<br>    for (int i = 1; i &lt;= numbuckets; i++)<br>        if (cnt[i]) run[cur++] = i - 1;<br>    for (int i = 1; i &lt;= numbuckets; i++)<br>        cnt[i] += cnt[i - 1];<br>    cur = 0;<br>    for (int <em>i = l; i &lt; r; i++) {<br>        int ind = (temp[cur] - minz) / range;<br>        <em>(l + cnt[ind]) = temp[cur];<br>        cur++;<br>        cnt[ind]++;<br>    }<br>    for (int i = 0; i &lt; sz; i++) {<br>        int r = run[i];<br>        if (r != 0) _newbucketsort(l + cnt[r - 1], l + cnt[r], temp);<br>        else _newbucketsort(l, l + cnt[r], temp);<br>    }<br>    delete run;<br>    delete cnt;<br>}<br>void newbucketsort(int</em> l, int</em> r) {<br>    int *temp = new int[r - l];<br>    _newbucketsort(l, r, temp);<br>    delete temp;<br>}</p>
<p>Поразрядная сортировка / Radix sort</p>
<p>(также известна как цифровая сортировка). Существует две версии этой сортировки, в которых, на мой взгляд, мало общего, кроме идеи воспользоваться представлением числа в какой-либо системе счисления (например, двоичной).</p>
<p>LSD (least significant digit):</p>
<p>Представим каждое число в двоичном виде. На каждом шаге алгоритма будем сортировать числа таким образом, чтобы они были отсортированы по первым k * i битам, где k – некоторая константа. Из данного определения следует, что на каждом шаге достаточно стабильно сортировать элементы по новым k битам. Для этого идеально подходит сортировка подсчетом (необходимо 2k памяти и времени, что немного при удачном выборе константы). Асимптотика: O(n), если считать, что числа фиксированного размера (а в противном случае нельзя было бы считать, что сравнение двух чисел выполняется за единицу времени). Реализация довольно проста.</p>
<p>Реализация:<br>int digit(int n, int k, int N, int M) {<br>    return (n &gt;&gt; (N * k) &amp; (M - 1));<br>}<br>void _radixsort(int* l, int* r, int N) {<br>    int k = (32 + N - 1) / N;<br>    int M = 1 &lt;&lt; N;<br>    int sz = r - l;<br>    int* b = new int[sz];<br>    int* c = new int[M];<br>    for (int i = 0; i &lt; k; i++) {<br>        for (int j = 0; j &lt; M; j++)<br>            c[j] = 0;<br>        for (int* j = l; j &lt; r; j++)<br>            c[digit(*j, i, N, M)]++;<br>        for (int j = 1; j &lt; M; j++)<br>            c[j] += c[j - 1];<br>        for (int* j = r - 1; j &gt;= l; j–)<br>            b[–c[digit(<em>j, i, N, M)]] = <em>j;<br>        int cur = 0;<br>        for (int</em> j = l; j &lt; r; j++)<br>            <em>j = b[cur++];<br>    }<br>    delete b;<br>    delete c;<br>}<br>void radixsort(int</em> l, int</em> r) {<br>    _radixsort(l, r, 8);<br>}</p>
<p>MSD (most significant digit):</p>
<p>На самом деле, некоторая разновидность блочной сортировки. В один блок будут попадать числа с равными k битами. Асимптотика такая же, как и у LSD версии. Реализация очень похожа на блочную сортировку, но проще. В ней используется функция digit, определенная в реализации LSD версии.</p>
<p>Реализация:<br>void _radixsortmsd(int* l, int* r, int N, int d, int* temp) {<br>    if (d == -1) return;<br>    if (r - l &lt;= 32) {<br>        insertionsort(l, r);<br>        return;<br>    }<br>    int M = 1 &lt;&lt; N;<br>    int* cnt = new int[M + 1];<br>    for (int i = 0; i &lt;= M; i++)<br>        cnt[i] = 0;<br>    int cur = 0;<br>    for (int* i = l; i &lt; r; i++) {<br>        temp[cur++] = <em>i;<br>        cnt[digit(<em>i, d, N, M) + 1]++;<br>    }<br>    int sz = 0;<br>    for (int i = 1; i &lt;= M; i++)<br>        if (cnt[i]) sz++;<br>    int</em> run = new int[sz];<br>    cur = 0;<br>    for (int i = 1; i &lt;= M; i++)<br>        if (cnt[i]) run[cur++] = i - 1;<br>    for (int i = 1; i &lt;= M; i++)<br>        cnt[i] += cnt[i - 1];<br>    cur = 0;<br>    for (int <em>i = l; i &lt; r; i++) {<br>        int ind = digit(temp[cur], d, N, M);<br>        <em>(l + cnt[ind]) = temp[cur];<br>        cur++;<br>        cnt[ind]++;<br>    }<br>    for (int i = 0; i &lt; sz; i++) {<br>        int r = run[i];<br>        if (r != 0) _radixsortmsd(l + cnt[r - 1], l + cnt[r], N, d - 1, temp);<br>        else _radixsortmsd(l, l + cnt[r], N, d - 1, temp);<br>    }<br>    delete run;<br>    delete cnt;<br>}<br>void radixsortmsd(int</em> l, int</em> r) {<br>    int</em> temp = new int[r - l];<br>    _radixsortmsd(l, r, 8, 3, temp);<br>    delete temp;<br>}</p>
<p>Битонная сортировка / Bitonic sort:</p>
<p>Идея данного алгоритма заключается в том, что исходный массив преобразуется в битонную последовательность – последовательность, которая сначала возрастает, а потом убывает. Ее можно эффективно отсортировать следующим образом: разобьем массив на две части, создадим два массива, в первый добавим все элементы, равные минимуму из соответственных элементов каждой из двух частей, а во второй – равные максимуму. Утверждается, что получатся две битонные последовательности, каждую из которых можно рекурсивно отсортировать тем же образом, после чего можно склеить два массива (так как любой элемент первого меньше или равен любого элемента второго). Для того, чтобы преобразовать исходный массив в битонную последовательность, сделаем следующее: если массив состоит из двух элементов, можно просто завершиться, иначе разделим массив пополам, рекурсивно вызовем от половинок алгоритм, после чего отсортируем первую часть по порядку, вторую в обратном порядке и склеим. Очевидно, получится битонная последовательность. Асимптотика: O(nlog2n), поскольку при построении битонной последовательности мы использовали сортировку, работающую за O(nlogn), а всего уровней было logn. Также заметим, что размер массива должен быть равен степени двойки, так что, возможно, придется его дополнять фиктивными элементами (что не влияет на асимптотику).</p>
<p>Реализация:<br>void bitseqsort(int* l, int* r, bool inv) {<br>    if (r - l &lt;= 1) return;<br>    int *m = l + (r - l) / 2;<br>    for (int *i = l, *j = m; i &lt; m &amp;&amp; j &lt; r; i++, j++) {<br>        if (inv ^ (*i &gt; <em>j)) swap(<em>i, <em>j);<br>    }<br>    bitseqsort(l, m, inv);<br>    bitseqsort(m, r, inv);<br>}<br>void makebitonic(int</em> l, int</em> r) {<br>    if (r - l &lt;= 1) return;<br>    int <em>m = l + (r - l) / 2;<br>    makebitonic(l, m);<br>    bitseqsort(l, m, 0);<br>    makebitonic(m, r);<br>    bitseqsort(m, r, 1);<br>}<br>void bitonicsort(int</em> l, int</em> r) {<br>    int n = 1;<br>    int inf = *max_element(l, r) + 1;<br>    while (n &lt; r - l) n <em>= 2;<br>    int</em> a = new int[n];<br>    int cur = 0;<br>    for (int *i = l; i &lt; r; i++)<br>        a[cur++] = *i;<br>    while (cur &lt; n) a[cur++] = inf;<br>    makebitonic(a, a + n);<br>    bitseqsort(a, a + n, 0);<br>    cur = 0;<br>    for (int *i = l; i &lt; r; i++)<br>        *i = a[cur++];<br>    delete a;<br>}</p>
<p>Timsort</p>
<p>Гибридная сортировка, совмещающая сортировку вставками и сортировку слиянием. Разобьем элементы массива на несколько подмассивов небольшого размера, при этом будем расширять подмассив, пока элементы в нем отсортированы. Отсортируем подмассивы сортировкой вставками, пользуясь тем, что она эффективно работает на отсортированных массивах. Далее будем сливать подмассивы как в сортировке слиянием, беря их примерно равного размера (иначе время работы приблизится к квадратичному). Для этого удобного хранить подмассивы в стеке, поддерживая инвариант — чем дальше от вершины, тем больше размер, и сливать подмассивы на верхушке только тогда, когда размер третьего по отдаленности от вершины подмассива больше или равен сумме их размеров. Асимптотика: O(n) в лучшем случае и O(nlogn) в среднем и худшем случае. Реализация нетривиальна, твердой уверенности в ней у меня нет, однако время работы она показала довольно неплохое и согласующееся с моими представлениями о том, как должна работать эта сортировка.</p>
<p>Подробнее timsort описан здесь:</p>
<p>Здесь<br>Здесь</p>
<p>Реализация:<br>void _timsort(int* l, int* r, int* temp) {<br>    int sz = r - l;<br>    if (sz &lt;= 64) {<br>        insertionsort(l, r);<br>        return;<br>    }<br>    int minrun = sz, f = 0;<br>    while (minrun &gt;= 64) {<br>        f |= minrun &amp; 1;<br>        minrun &gt;&gt;= 1;<br>    }<br>    minrun += f;<br>    int* cur = l;<br>    stack&lt;pair&lt;int, int*&gt;&gt; s;<br>    while (cur &lt; r) {<br>        int* c1 = cur;<br>        while (c1 &lt; r - 1 &amp;&amp; <em>c1 &lt;= *(c1 + 1)) c1++;<br>        int* c2 = cur;<br>        while (c2 &lt; r - 1 &amp;&amp; *c2 &gt;= <em>(c2 + 1)) c2++;<br>        if (c1 &gt;= c2) {<br>            c1 = max(c1, cur + minrun - 1);<br>            c1 = min(c1, r - 1);<br>            insertionsort(cur, c1 + 1);<br>            s.push({ c1 - cur + 1, cur });<br>            cur = c1 + 1;<br>        }<br>        else {<br>            c2 = max(c2, cur + minrun - 1);<br>            c2 = min(c2, r - 1);<br>            reverse(cur, c2 + 1);<br>            insertionsort(cur, c2 + 1);<br>            s.push({ c2 - cur + 1, cur });<br>            cur = c2 + 1;<br>        }<br>        while (s.size() &gt;= 3) {<br>            pair&lt;int, int*&gt; x = s.top();<br>            s.pop();<br>            pair&lt;int, int*&gt; y = s.top();<br>            s.pop();<br>            pair&lt;int, int*&gt; z = s.top();<br>            s.pop();<br>            if (z.first &gt;= x.first + y.first &amp;&amp; y.first &gt;= x.first) {<br>                s.push(z);<br>                s.push(y);<br>                s.push(x);<br>                break;<br>            }<br>            else if (z.first &gt;= x.first + y.first) {<br>                merge(y.second, x.second, x.second + x.first, temp);<br>                s.push(z);<br>                s.push({ x.first + y.first, y.second });<br>            }<br>            else {<br>                merge(z.second, y.second, y.second + y.first, temp);<br>                s.push({ z.first + y.first, z.second });<br>                s.push(x);<br>            }<br>        }<br>    }<br>    while (s.size() != 1) {<br>        pair&lt;int, int*&gt; x = s.top();<br>        s.pop();<br>        pair&lt;int, int*&gt; y = s.top();<br>        s.pop();<br>        if (x.second &lt; y.second) swap(x, y);<br>        merge(y.second, x.second, x.second + x.first, temp);<br>        s.push({ y.first + x.first, y.second });<br>    }<br>}<br>void timsort(int</em> l, int</em> r) {<br>    int* temp = new int[r - l];<br>    _timsort(l, r, temp);<br>    delete temp;<br>}</p>
<p>Тестирование</p>
<p>Железо и система</p>
<p>Процессор: Intel Core i7-3770 CPU 3.40 GHz<br>ОЗУ: 8 ГБ<br>Тестирование проводилось на почти чистой системе Windows 10 x64, установленной за несколько дней до запуска. Использованная IDE – Microsoft Visual Studio 2015.</p>
<p>Тесты</p>
<p>Все тесты поделены на четыре группы. Первая группа – массив случайных чисел по разным модулям (10, 1000, 105, 107 и 109). Вторая группа – массив, разбивающийся на несколько отсортированных подмассивов. Фактически брался массив случайных чисел по модулю 109, а далее отсортировывались подмассивы размера, равного минимуму из длины оставшегося суффикса и случайного числа по модулю некоторой константы. Последовательность констант – 10, 100, 1000 и т.д. вплоть до размера массива. Третья группа – изначально отсортированный массив случайных чисел с некоторым числом «свопов» — перестановок двух случайных элементов. Последовательность количеств свопов такая же, как и в предыдущей группе. Наконец, последняя группа состоит из нескольких тестов с полностью отсортированным массивом (в прямом и обратном порядке), нескольких тестов с исходным массивом натуральных чисел от 1 до n, в котором несколько чисел заменены на случайное, и тестов с большим количеством повторений одного элемента (10%, 25%, 50%, 75% и 90%). Таким образом, тесты позволяют посмотреть, как сортировки работают на случайных и частично отсортированных массивах, что выглядит наиболее существенным. Четвертая группа во многом направлена против сортировок с линейным временем работы, которые любят последовательности случайных чисел. В конце статьи есть ссылка на файл, в котором подробно описаны все тесты.</p>
<p>Размер входных данных</p>
<p>Было бы довольно глупо сравнивать, например, сортировку с линейным временем работы и квадратичную, и запускать их на тестах одного размера. Поэтому каждая из групп тестов делится еще на четыре группы, размера 105, 106, 107и 108 элементов. Сортировки были разбиты на три группы, в первой – квадратичные (сортировка пузырьком, вставками, выбором, шейкерная и гномья), во второй – нечто среднее между логарифмическим временем и квадратом, (битонная, несколько видов сортировки Шелла и сортировка деревом), в третьей все остальные. Кого-то, возможно, удивит, что сортировка деревом попала не в третью группу, хотя ее асимптотика и O(nlogn), но, к сожалению, ее константа очень велика. Сортировки первой группы тестировались на тестах с 105элементов, второй группы – на тестах с 106и 107, третьей – на тестах с 107и 108. Именно такие размеры данных позволяют как-то увидеть рост времени работы, при меньших размерах слишком велика погрешность, при больших алгоритм работает слишком долго (или же недостаток оперативной памяти). С первой группой я не стал заморачиваться, чтобы не нарушать десятикратное увеличение (104 элементов для квадратичных сортировок слишком мало), в конце концов, сами по себе они представляют мало интереса.</p>
<p>Как проводилось тестирование</p>
<p>На каждом тесте было производилось 20 запусков, итоговое время работы – среднее по получившимся значениям. Почти все результаты были получены после одного запуска программы, однако из-за нескольких ошибок в коде и системных глюков (все же тестирование продолжалось почти неделю чистого времени) некоторые сортировки и тесты пришлось впоследствии перетестировать.</p>
<p>Тонкости реализации</p>
<p>Возможно, кого-то удивит, что в реализации самого процесса тестирования я не использовал указатели на функции, что сильно сократило бы код. Оказалось, что это заметно замедляет работу алгоритма (примерно на 5-10%). Поэтому я использовал отдельный вызов каждой функции (это, конечно, не отразилось бы на относительной скорости, но… все же хочется улучшить и абсолютную). По той же причине были заменены векторы на обычные массивы, не были использованы шаблоны и функции-компараторы. Все это более актуально для промышленного использования алгоритма, нежели его тестирования.</p>

        </div>
        <footer class="article-footer">
            



    <a data-url="https://goxpert.ru/2024/06/01/algorithms/sort/constsort/" data-id="cm2643k9900017cwl9fb65972" class="article-share-link"><i class="fa fa-share"></i>Поделиться</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "авторы проекта GoXpert"
        },
        
        "image": "https://goxpert.ru",
        "keywords": "Golang, Q&A",
        "genre": "Golang Algorithms Sort",
        "datePublished": "2024-06-01",
        "dateCreated": "2024-06-01",
        "dateModified": "2024-10-11",
        "url": "https://goxpert.ru/2024/06/01/algorithms/sort/constsort/",
        "description": "Сортировка за константное времяТакой вопрос я задал одному из наших Российских AI-ассистент разработчика, который ускоряет создание ПОответ был такой:
Вот пример кода на Golang для сортировки подсчето",
        "wordCount": 9554
    }
</script>

</article>

    <section id="comments">
    
        
    <div id="vk_comments"></div>
    <script type="text/javascript">
      window.onload = function () {
      VK.init({apiId: 51937371, onlyWidgets: true});
      VK.Widgets.Comments("vk_comments", {limit: 20, attach: "*", autoPublish: 1, pageUrl: "https://goxpert.ru/2024/06/01/algorithms/sort/constsort/"});
    }
   </script>

    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>Подписаться:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="vk" href="https://vk.com/goxpert" target="_blank" rel="noopener">
                        <i class="icon fa fa-vk"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="telegram" href="https://t.me/goxpert_ru" target="_blank" rel="noopener">
                        <i class="icon fa fa-telegram"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="youtube" href="https://www.youtube.com/c/УчимсянаПять" target="_blank" rel="noopener">
                        <i class="icon fa fa-youtube"></i>
                    </a>
                </li>
                
            
                
            
                
                <li>
                    <a class="social-tooltip" title="twitter" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-twitter"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="facebook" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-facebook"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="weibo" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-weibo"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="rss" href="/atom.xml" target="_blank" rel="noopener">
                        <i class="icon fa fa-rss"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2024/06/01/grpc/grpc/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">новые</strong>
        <p class="article-nav-title">
        
            (no title)
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2024/06/01/common/package/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">старые</strong>
        <p class="article-nav-title">Пакеты</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">недавние</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2024/10/21/kafka/consumer_group/" class="thumbnail">
    
    
        <span style="background-image:url(/images/Kafka_Internals_Group.png)" alt="Consumer Group Protocol" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Kafka/">Kafka</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Kafka/%D0%A1%D1%82%D0%B0%D1%80%D1%82/">Старт</a></p>
                            <p class="item-title"><a href="/2024/10/21/kafka/consumer_group/" class="title">Consumer Group Protocol</a></p>
                            <p class="item-date"><time datetime="2024-10-21T07:10:00.000Z" itemprop="datePublished">2024-10-21</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2024/06/02/os/os_scheduler/" class="thumbnail">
    
    
        <span style="background-image:url(/images/os_sched_1.jpg)" alt="Планировщик ОS" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/%D0%9E%D0%A1/">ОС</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/%D0%9E%D0%A1/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA-%D0%9ES/">Планировщик ОS</a></p>
                            <p class="item-title"><a href="/2024/06/02/os/os_scheduler/" class="title">Планировщик ОS</a></p>
                            <p class="item-date"><time datetime="2024-06-02T15:32:20.263Z" itemprop="datePublished">2024-06-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2024/06/01/concurrency/go_scheduler/" class="thumbnail">
    
    
        <span style="background-image:url(/images/go_sched1.png)" alt="Планировщик GO" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Golang/">Golang</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/">Старт</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/">Вопрос-Ответ</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/">Планировщик</a></p>
                            <p class="item-title"><a href="/2024/06/01/concurrency/go_scheduler/" class="title">Планировщик GO</a></p>
                            <p class="item-date"><time datetime="2024-06-01T09:35:00.000Z" itemprop="datePublished">2024-06-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2024/06/01/concurrency/go_scheduler_more/" class="thumbnail">
    
    
        <span style="background-image:url(/images/golang_scheduler_more1.png)" alt="Планировщик GO другой взгляд" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Golang/">Golang</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/">Старт</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/">Вопрос-Ответ</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/">Планировщик</a></p>
                            <p class="item-title"><a href="/2024/06/01/concurrency/go_scheduler_more/" class="title">Планировщик GO другой взгляд</a></p>
                            <p class="item-date"><time datetime="2024-06-01T09:35:00.000Z" itemprop="datePublished">2024-06-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2024/06/01/concurrency/go_concurrency/" class="thumbnail">
    
    
        <span style="background-image:url(/images/golang_concurrency1.png)" alt="Планировщик GO - Concurrency" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Golang/">Golang</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/">Старт</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/">Вопрос-Ответ</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/">Планировщик</a></p>
                            <p class="item-title"><a href="/2024/06/01/concurrency/go_concurrency/" class="title">Планировщик GO - Concurrency</a></p>
                            <p class="item-date"><time datetime="2024-06-01T09:35:00.000Z" itemprop="datePublished">2024-06-01</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">Категории</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><span class="category-list-count">30</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/Algorithms/">Algorithms</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/Algorithms/Sort/">Sort</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/GRPC/">GRPC</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/GRPC/Sort/">Sort</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/">Старт</a><span class="category-list-count">28</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Defer/">Defer</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Generics/">Generics</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Panic/">Panic</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/SOLID/">SOLID</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/SSA/">SSA</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Select-case/">Select-case</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%93%D0%BE%D0%BD%D0%BA%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/">Гонка данных</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/">Горутины</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B/">Интерфейсы</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82/">Контекст</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%B8-%D1%81%D0%BB%D0%B0%D0%B9%D1%81%D1%8B/">Массивы и слайсы</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9E%D0%B1%D1%89%D0%B8%D0%B5/">Общие</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%B0%D0%BA%D0%B5%D1%82%D1%8B/">Пакеты</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/">Планировщик</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/">Примитивы синхронизации</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8/">Строки</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B/">Структуры</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A2%D0%B8%D0%BF%D1%8B/">Типы</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8/">Указатели</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A5%D0%B5%D1%88-%D0%BC%D0%B0%D0%BF%D1%8B/">Хеш-мапы</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kafka/">Kafka</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Kafka/%D0%A1%D1%82%D0%B0%D1%80%D1%82/">Старт</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Kafka/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Consumer-Group/">Consumer Group</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/">Вопрос-Ответ</a><span class="category-list-count">27</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Defer/">Defer</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Generics/">Generics</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Panic/">Panic</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/SOLID/">SOLID</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/SSA/">SSA</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Select-case/">Select-case</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D0%BD%D0%BA%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/">Гонка данных</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/">Горутины</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B/">Интерфейсы</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82/">Контекст</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%B8-%D1%81%D0%BB%D0%B0%D0%B9%D1%81%D1%8B/">Массивы и слайсы</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9E%D0%B1%D1%89%D0%B8%D0%B5/">Общие</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%B0%D0%BA%D0%B5%D1%82%D1%8B/">Пакеты</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/">Планировщик</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/">Примитивы синхронизации</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8/">Строки</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B/">Структуры</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A2%D0%B8%D0%BF%D1%8B/">Типы</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8/">Указатели</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A5%D0%B5%D1%88-%D0%BC%D0%B0%D0%BF%D1%8B/">Хеш-мапы</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%9E%D0%A1/">ОС</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%9E%D0%A1/CPU-cache/">CPU cache</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%9E%D0%A1/C%D0%B5%D1%82%D1%8C/">Cеть</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%9E%D0%A1/Namespaces/">Namespaces</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%D0%9E%D0%A1/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA-%D0%9ES/">Планировщик ОS</a><span class="category-list-count">1</span></li></ul></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">архивы</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">октябрь 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">июнь 2024</a><span class="archive-list-count">39</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">Тэги</h3>
        <div class="widget">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-Q-A/" rel="tag">Golang, Q&A</a><span class="tag-list-count">38</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka-Consumer-Group/" rel="tag">Kafka, Consumer Group</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">Облако тэгов</h3>
        <div class="widget tagcloud">
            <a href="/tags/Golang/" style="font-size: 10px;">Golang</a> <a href="/tags/Golang-Q-A/" style="font-size: 20px;">Golang, Q&A</a> <a href="/tags/Kafka-Consumer-Group/" style="font-size: 10px;">Kafka, Consumer Group</a>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">ссылки</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a target="_blank" rel="noopener" href="https://vk.com/goxpert">мы в vk</a>
                    </li>
                
                    <li>
                        <a target="_blank" rel="noopener" href="https://www.youtube.com/c/УчимсянаПять">мы в youtube</a>
                    </li>
                
            </ul>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2024 авторы проекта GoXpert</p>
                
                <p>Powered by <a href="https://designest.ru/" target="_blank">DESIGNest Studio Ltd</a></p>
                
            </div>
            <div class="footer-plugins">
                
			<!-- Yandex.RTB R-A-1394392-1 -->
			<div id="yandex_rtb_R-A-1394392-1"></div>
			<script>window.yaContextCb.push(()=>{Ya.Context.AdvManager.render({renderTo: 'yandex_rtb_R-A-1394392-1',  blockId: 'R-A-1394392-1' }) })</script>
                
              
    


            </div>
        </div>
    </div>
</footer>                                                                                            

    </div>
    
    
    <script type="text/javascript">
    var vk_shortname = 'true';
    (function() {
    var vk = document.createElement('script');
    vk.type = 'text/javascript';
    vk.async = true;
    vk.src = '//vk.com/js/api/openapi.js?169'; 
    vk.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
    || document.getElementsByTagName('body')[0]).appendChild(vk);
    })();
    </script>




    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    

    
    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


</body>
</html>
