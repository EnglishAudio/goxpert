<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:yandex="http://news.yandex.ru"
     xmlns:media="http://search.yahoo.com/mrss/"
     xmlns:turbo="http://turbo.yandex.ru"
     version="2.0">
  <channel>
    <title>GoXpert.ru</title>
    <link>https://goxpert.ru/</link>
    <description>Секреты Golang. Архитектура и дизайн приложений на GO. Всё о GO изнутри</description>
    <turbo:analytics type="Yandex"
                 id="86613025">    <!-- https://yandex.ru/dev/turbo/doc/settings/analytics.html#analytics__rss-1 -->
    </turbo:analytics>    
    
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/types/types-common/</turbo:source>
      <turbo:topic>Типы данных</turbo:topic>
      <title>Типы данных</title>
      <link>https://goxpert.ru/2024/06/01/types/types-common/</link>
      <pubDate>Sat, 01 Jun 2024 07:14:00 GMT</pubDate>
       
      <yandex:related type="infinity">
         
        <link url="https://goxpert.ru/2024/06/01/types/map/">Следующая статья: Хеш-мапы (map)</link>
        
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Что-такое-type-switch"><a href="#Что-такое-type-switch" class="headerlink" title="Что такое type switch?"></a>Что такое type switch?</h2><blockquote><p><strong><code>Type switch</code></strong> в Go - это способ проверить, какого типа является значение, хранящееся в интерфейсе. Это похоже на обычный <strong><code>switch</code></strong>, но вместо значений в кейсах указываются типы.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do(<span class="number">21</span>)</span><br><span class="line">    do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Какие-типы-данных-есть-в-Golang"><a href="#Какие-типы-данных-есть-в-Golang" class="headerlink" title="Какие типы данных есть в Golang?"></a>Какие типы данных есть в Golang?</h2><ol><li><strong>Целочисленные типы</strong>: <strong><code>int8</code></strong>, <strong><code>int16</code></strong>, <strong><code>int32</code></strong>, <strong><code>int64</code></strong>, <strong><code>uint8</code></strong>, <strong><code>uint16</code></strong>, <strong><code>uint32</code></strong>, <strong><code>uint64</code></strong>, <strong><code>byte</code></strong> (синоним для <strong><code>uint8</code></strong>), <strong><code>rune</code></strong> (синоним для <strong><code>int32</code></strong>), <strong><code>int</code></strong> и <strong><code>uint</code>.</strong></li><li><strong>Числа с плавающей точкой</strong>: <strong><code>float32</code></strong> и <strong><code>float64</code>.</strong></li><li><strong>Строки</strong>: <strong><code>string</code></strong>.</li><li><strong>Булев тип</strong>: <strong><code>bool</code></strong>.</li><li><strong>Составные типы</strong>: Массивы, срезы, структуры, ассоциативные массивы</li></ol><h2 id="Какой-длины-руна"><a href="#Какой-длины-руна" class="headerlink" title="Какой длины руна?"></a>Какой длины руна?</h2><p><strong><code>rune</code></strong> - это алиас для <strong><code>int32</code></strong>. Это означает, что <strong><code>rune</code></strong> занимает 4 байта или 32 бита. Каждая <strong><code>rune</code></strong> представляет собой один Юникод символ. Например, строка может быть преобразована в срез <strong><code>rune</code></strong> (<strong><code>[]rune</code></strong>), и каждый элемент этого среза будет представлять собой один Юникод символ.</p><h2 id="Как-реализовать-Enum-в-Golang"><a href="#Как-реализовать-Enum-в-Golang" class="headerlink" title="Как реализовать Enum в Golang?"></a>Как реализовать Enum в Golang?</h2><p>В Go нет встроенной поддержки перечислений (enum), но их можно эмулировать с помощью констант. Вот пример реализации enum в Go:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Season <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Summer Season = <span class="literal">iota</span></span><br><span class="line">    Autumn</span><br><span class="line">    Winter</span><br><span class="line">    Spring</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Season)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...]<span class="keyword">string</span>&#123;<span class="string">&quot;Лето&quot;</span>, <span class="string">&quot;Осень&quot;</span>, <span class="string">&quot;Зима&quot;</span>, <span class="string">&quot;Весна&quot;</span>&#125;[s]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Winter</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Что-если-во-время-компиляции-переполним-тип-В-int8-запишем-256"><a href="#Что-если-во-время-компиляции-переполним-тип-В-int8-запишем-256" class="headerlink" title="Что если во время компиляции переполним тип? В int8 запишем 256?"></a>Что если во время компиляции переполним тип? В int8 запишем 256?</h2><p>Если вы попытаетесь записать значение, превышающее максимально допустимое для данного типа, в Go, то произойдет переполнение типа.</p><p>Например, <strong><code>int8</code></strong> может хранить значения от -128 до 127. Если вы попытаетесь записать 256 в переменную типа <strong><code>int8</code></strong>, то произойдет переполнение. В результате, вместо 256 будет записано значение, которое соответствует остатку от деления 256 на 256 (количество возможных значений для <strong><code>int8</code></strong>), то есть 01.</p><p>Важно отметить, что такое поведение может привести к неожиданным результатам, поэтому всегда следует убедиться, что значения, которые вы записываете в переменные, не превышают максимально допустимые для их типа</p><h2 id="Что-происходит-при-переполнении-числа-например-в-uint8-выйдем-за-границу-на-1"><a href="#Что-происходит-при-переполнении-числа-например-в-uint8-выйдем-за-границу-на-1" class="headerlink" title="Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?"></a>Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?</h2><p>Если вы попытаетесь записать значение, превышающее максимально допустимое для данного типа, в Go, то произойдет переполнение типа.</p><p>Например, <strong><code>uint8</code></strong> может хранить значения от 0 до 255. Если вы попытаетесь записать 256 в переменную типа <strong><code>uint8</code></strong>, то произойдет переполнение. В результате, вместо 256 будет записано значение, которое соответствует остатку от деления 256 на 256 (количество возможных значений для <strong><code>uint8</code></strong>), то есть 0.</p><p>Важно отметить, что такое поведение может привести к неожиданным результатам, поэтому всегда следует убедиться, что значения, которые вы записываете в переменные, не превышают максимально допустимые для их типа.</p><p><img src="/images/golang_types.jpg" alt="Вот вам и types"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/types/map/</turbo:source>
      <turbo:topic>Хеш-мапы (map)</turbo:topic>
      <title>Хеш-мапы (map)</title>
      <link>https://goxpert.ru/2024/06/01/types/map/</link>
      <pubDate>Sat, 01 Jun 2024 07:13:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/types/types-common/">Предыдущая статья: Типы данных</link>
        <link url="https://goxpert.ru/2024/06/01/types/interface/">Следующая статья: Интерфейсы</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Что-такое-мапа-map"><a href="#Что-такое-мапа-map" class="headerlink" title="Что такое мапа (map)??"></a>Что такое мапа (<a href="https://go.dev/tour/moretypes/19">map</a>)??</h2><p>Мапа в Go - это тип данных, который предназначен для хранения пар “ключ-значение”. Это структура данных, также известная как хэш-таблица, словарь или ассоциативный массив. Мапа позволяет получить значение по ключу. Ключами в мапе могут быть любые сравниваемые типы — все сравнимые типы.</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    m[<span class="string">&quot;apple&quot;</span>] = <span class="number">1</span></span><br><span class="line">    m[<span class="string">&quot;banana&quot;</span>] = <span class="number">2</span></span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Что-произойдет-при-конкурентной-записи-в-мапу"><a href="#Что-произойдет-при-конкурентной-записи-в-мапу" class="headerlink" title="Что произойдет при конкурентной записи в мапу?"></a>Что произойдет при конкурентной записи в мапу?</h2><p>Мапы в Go не являются потокобезопасными. Это означает, что если вы попытаетесь записать данные в мапу из нескольких горутин одновременно, это может привести к состоянию гонки. Если вам нужно работать с мапой из нескольких горутин, вы должны использовать механизмы синхронизации, такие как sync.Mutex или sync.RWMutex, чтобы гарантировать, что в любой момент времени только одна горутина может изменять мапу. Вот пример использования sync.Mutex для безопасной записи в мапу из нескольких горутин:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            mu.Lock()</span><br><span class="line">            m[i] = i * <span class="number">2</span></span><br><span class="line">            mu.Unlock()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Как-устроена-мапа-под-капотом"><a href="#Как-устроена-мапа-под-капотом" class="headerlink" title="Как устроена мапа под капотом?"></a>Как устроена мапа под капотом?</h2><p>Мапа в Go - это структура данных, которая хранит пары “ключ-значение”. Внутри мапы ключи и значения хранятся в выделенном участке памяти, последовательно. Для получения адресов ячеек конкретных ключей и значений используется хэширующая функция. </p><p>Вот некоторые детали о том, как устроена мапа в Go:</p><ul><li><a href="https://www.youtube.com/watch?v=P_SXTUiA-9Y">Мапа разбивается на бакеты для более эффективного поиска</a>.</li><li><a href="https://www.youtube.com/watch?v=P_SXTUiA-9Y">Хэш-функция используется для равномерного распределения ключей по бакетам</a>.</li><li><a href="https://www.youtube.com/watch?v=P_SXTUiA-9Y">При переполнении бакета происходит рост мапы</a>.</li><li><a href="https://www.youtube.com/watch?v=P_SXTUiA-9Y">Эвакуация данных происходит при заполнении мапы</a>.</li><li><a href="https://www.youtube.com/watch?v=P_SXTUiA-9Y">Порядок обхода мапы является случайным</a>.</li></ul><h2 id="Какие-ключи-могут-быть-у-мапы"><a href="#Какие-ключи-могут-быть-у-мапы" class="headerlink" title="Какие ключи могут быть у мапы?"></a>Какие ключи могут быть у мапы?</h2><p>Ключами в мапе могут быть любые сравниваемые типы — все простые скалярные типы, массивы. Несравниваемые типы — срезы, мапы, функции. Ключи и значения мапы будут храниться в выделенном участке памяти, последовательно.</p><h2 id="Какая-сложность-работы-с-мапой"><a href="#Какая-сложность-работы-с-мапой" class="headerlink" title="Какая сложность работы с мапой?"></a>Какая сложность работы с мапой?</h2><p>Операции вставки, удаления и поиска в мапе в Go обычно имеют сложность O(1), то есть они выполняются за постоянное время. Это достигается за счет использования хэш-таблицы внутри мапы. Однако в худшем случае, когда все ключи попадают в один и тот же бакет, эти операции могут иметь сложность O(n), где n - количество элементов в мапе</p><h2 id="Можно-ли-взять-адрес-элемента-мапы-и-почему"><a href="#Можно-ли-взять-адрес-элемента-мапы-и-почему" class="headerlink" title="Можно ли взять адрес элемента мапы и почему?"></a>Можно ли взять адрес элемента мапы и почему?</h2><p>Нет, нельзя взять адрес элемента мапы в Go. Это связано с тем, как устроена мапа внутри. Мапа разбита на бакеты, и при росте мапы элементы могут переходить из одного бакета в другой. Это означает, что адрес элемента в памяти может меняться, и поэтому Go не позволяет взять адрес элемента мапы. Если вы попытаетесь это сделать, компилятор выдаст ошибку.</p><h2 id="Как-работает-эвакуация-данных"><a href="#Как-работает-эвакуация-данных" class="headerlink" title="Как работает эвакуация данных?"></a>Как работает эвакуация данных?</h2><p>Эвакуация данных в мапе Go происходит при переполнении мапы. Когда количество элементов в мапе достигает определенного порога, мапа “растет” - создается новая, большая мапа, и все элементы из старой мапы копируются в новую. Этот процесс называется “эвакуацией”. Важно отметить, что в Go рост мапы происходит асинхронно. Это означает, что во время роста мапы могут возникать ситуации, когда при попытке доступа к данным часть бакетов уже переехала в новую мапу, а часть еще нет. Благодаря этому не происходит просадок во время роста большой мапы.</p><h2 id="Как-разрешаются-коллизии-в-мапе"><a href="#Как-разрешаются-коллизии-в-мапе" class="headerlink" title="Как разрешаются коллизии в мапе?"></a>Как разрешаются коллизии в мапе?</h2><p>В мапе Go коллизии разрешаются с помощью бакетов. Каждый бакет может содержать до восьми элементов. Если все ячейки в бакете заняты, то происходит переполнение и мапа “растет” - создается новая, большая мапа, и все элементы из старой мапы копируются в новую. Этот процесс называется “эвакуацией”. При этом, благодаря использованию хэш-функции, ключи равномерно распределяются по бакетам. Это позволяет минимизировать количество коллизий и обеспечивает быстрый доступ к данным.</p><h2 id="В-функции-make-для-мапы-мы-указываем-число-Что-оно-дает"><a href="#В-функции-make-для-мапы-мы-указываем-число-Что-оно-дает" class="headerlink" title="В функции make для мапы мы указываем число. Что оно дает?"></a>В функции make для мапы мы указываем число. Что оно дает?</h2><p>Число, указываемое в функции make для мапы в Go, определяет начальную вместимость мапы. Это число элементов, которые мапа сможет хранить без необходимости расширения. Если вы заранее знаете, сколько элементов будет в мапе, вы можете использовать это число при создании мапы, чтобы уменьшить количество операций реаллокации памяти, что может улучшить производительность. Вот пример создания мапы с начальной вместимостью 10:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="Стало-слишком-много-коллизий-в-мапе-как-решить-проблему"><a href="#Стало-слишком-много-коллизий-в-мапе-как-решить-проблему" class="headerlink" title="Стало слишком много коллизий в мапе, как решить проблему?"></a>Стало слишком много коллизий в мапе, как решить проблему?</h2><p>Если в мапе Go стало слишком много коллизий, вы можете использовать следующие подходы для решения проблемы:</p><p>Изменить размер мапы: Если мапа слишком мала, она может быстро заполняться, что приводит к большому количеству коллизий. В этом случае вы можете увеличить размер мапы, чтобы уменьшить вероятность коллизий.</p><p>Использовать метод раздельного связывания: Это метод, при котором внутри хеш-таблицы хранится массив фиксированного размера, элементы которого - связанные списки. По хешу ключа определяется элемент массива (bucket - корзину) и потом смотрится в списке, нет ли такого элемента и действуется соответствующее (добавляется/удаляется/модифицируется).</p><h2 id="Чем-мапа-отличается-от-sync-Map"><a href="#Чем-мапа-отличается-от-sync-Map" class="headerlink" title="Чем мапа отличается от sync.Map?"></a>Чем мапа отличается от sync.Map?</h2><p><strong>sync.Map</strong> и обычная мапа в Go имеют различия в использовании и производительности</p><ol><li><strong>Потокобезопасность</strong>: Обычная мапа в Go не является потокобезопасной, что означает, что одновременная запись в мапу из нескольких горутин может привести к состоянию гонки. В то время как <strong><code>sync.Map</code></strong> разработана для использования в многопоточных ситуациях и обеспечивает потокобезопасность.</li><li><strong>Производительность</strong> <strong><code>sync.Map</code></strong> обычно близка по скорости к обычной мапе с <strong><code>sync.RWMutex</code></strong>, но может быть лучше в случае чтения. Когда происходит чтение и обновление, <strong><code>sync.Map</code></strong> будет иметь элементы и в чтении, и в “грязном” состоянии.</li><li><strong>Использование</strong> <strong><code>sync.Map</code></strong> - это структура с методами, предоставляющими обычные операции с мапой. Вы не можете использовать синтаксис <strong><code>a_map[&quot;key&quot;]</code></strong> с <strong><code>sync.Map</code></strong>, вместо этого нужно использовать методы, такие как <strong><code>Load</code></strong>, <strong><code>Store</code></strong> и <strong><code>Delete</code></strong>.</li><li><strong>Структура</strong> <strong><code>sync.Map</code></strong> - это сложная структура, обычно состоящая из двух мап - одной для чтения и одной для новых элементов.</li></ol><p>Важно отметить, что <strong><code>sync.Map</code></strong> следует использовать только в тех случаях, когда большинство операций с мапой - это чтение, и когда ключи мапы меняются динамически.</p><h2 id="Какая-функция-используется-при-хешировании-ключа-в-мапе"><a href="#Какая-функция-используется-при-хешировании-ключа-в-мапе" class="headerlink" title="Какая функция используется при хешировании ключа в мапе?"></a>Какая функция используется при хешировании ключа в мапе?</h2><p>При хешировании ключа в мапе golang используется функция runtime.mapaccess1_faststr, которая принимает тип мапы, саму мапу и ключ в виде строки. Функция ищет ключ в мапе и возвращает указатель на соответствующее значение. Функция runtime.mapaccess1_faststr является специализированной версией функции runtime.mapaccess1, которая работает с любым типом ключа.</p><p>Хеширование ключа в мапе golang основано на алгоритме MurmurHash, который быстро и равномерно распределяет ключи по хеш-таблице. Хеш-таблица в golang состоит из массива корзин (buckets), каждая из которых содержит до восьми пар ключ-значение. Кроме того, каждая корзина имеет указатель на переполненную корзину, которая создается при коллизии хешей.</p><p>Если вы хотите узнать больше о реализации мапы в golang, вы можете почитать эту статью или эту статью на Хабре. Они объясняют детали работы мапы в golang с примерами кода и иллюстрациями. 😊</p><p>Источники:</p><ul><li><a href="https://habr.com/ru/articles/457728/">Habr</a></li><li><a href="https://habr.com/ru/articles/704796/">Habr</a></li><li><a href="https://golangforall.com/ru/post/map-principles-golang.html">GolangForAll</a></li></ul><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">  Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex) <span class="comment">// иначе паника</span></span><br><span class="line">  m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>,&#125;</span><br><span class="line">  m[<span class="string">&quot;A2&quot;</span>] = Vertex&#123;<span class="number">42</span>, <span class="number">-24</span>,&#125;</span><br><span class="line">  </span><br><span class="line">  fmt.Println(m)     <span class="comment">// реализовано так, что детерменированный вывод</span></span><br><span class="line">  <span class="keyword">for</span> _, val := <span class="keyword">range</span> m &#123;  <span class="comment">// произвольный обход</span></span><br><span class="line">    fmt.Println(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <a href="https://habr.com/ru/companies/avito/articles/774618/">Хорошая статья Pro Map</a><br><img src="/images/golang_map.jpg" alt="Вот вам и map"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/types/interface/</turbo:source>
      <turbo:topic>Интерфейсы</turbo:topic>
      <title>Интерфейсы</title>
      <link>https://goxpert.ru/2024/06/01/types/interface/</link>
      <pubDate>Sat, 01 Jun 2024 07:12:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/types/map/">Предыдущая статья: Хеш-мапы (map)</link>
        <link url="https://goxpert.ru/2024/06/01/types/pointers/">Следующая статья: Указатели</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Что-такое-интерфейс-interface"><a href="#Что-такое-интерфейс-interface" class="headerlink" title="Что такое интерфейс (interface)?"></a>Что такое интерфейс (<a href="https://go.dev/tour/methods/9">interface</a>)?</h2><p>Интерфейс в golang - это тип, который определяет набор сигнатур методов. Интерфейс позволяет абстрагироваться от конкретной реализации и работать с разными типами данных, которые реализуют один и тот же интерфейс. </p><p>Например, интерфейс Printer определяет метод Print(), который может быть реализован разными структурами, такими как User или Document. Для того, чтобы тип реализовывал интерфейс, он должен предоставить определения всех методов интерфейса. </p><p>В Go реализация интерфейса происходит неявно, то есть не требуется указывать, что тип реализует интерфейса.</p><h2 id="Для-чего-используется-интерфейс"><a href="#Для-чего-используется-интерфейс" class="headerlink" title="Для чего используется интерфейс?"></a>Для чего используется интерфейс?</h2><p>Интерфейс в golang используется для определения набора методов, которые должен реализовывать какой-либо тип данных.</p><p>Интерфейсы позволяют абстрагироваться от конкретных реализаций и работать с разными типами, имеющими общее поведение. Интерфейсы также способствуют модульности, гибкости и переиспользованию кода. </p><p>Например, интерфейс fmt.Stringer определяет метод String(), который возвращает строковое представление любого типа, реализующего этот интерфейс. </p><h2 id="Как-в-строго-типизированным-языке-сделать-функцию-которая-работает-с-разными-типами"><a href="#Как-в-строго-типизированным-языке-сделать-функцию-которая-работает-с-разными-типами" class="headerlink" title="Как в строго типизированным языке сделать функцию, которая работает с разными типами?"></a>Как в строго типизированным языке сделать функцию, которая работает с разными типами?</h2><p>Один из способов сделать это - использовать обобщения (generics), которые появились в Go 1.18. Обобщения позволяют объявлять и использовать функции или типы, которые написаны для работы с любым из набора типов, предоставляемых вызывающим кодом. Для этого в Go введены три новых элемента языка:</p><ul><li>Параметры типов для функций и типов. Это означает, что вы можете задать переменную типа T, которая может принимать разные конкретные типы при вызове функции или создании типа.</li><li>Определение интерфейсных типов как множеств типов, включая типы, не имеющие методов. Это означает, что вы можете задать ограничение (constraint) на параметр типа, указав, какие свойства должен иметь тип, чтобы его можно было использовать в обобщенной функции или типе.</li><li>Вывод типов, который позволяет опускать аргументы типов во многих случаях при вызове функции. Это означает, что вы можете не указывать конкретный тип при вызове обобщенной функции, если компилятор может сам его определить из контекста.</li></ul><h2 id="Есть-интерфейс-а-есть-указатель-на-структуру-который-nil-Кладем-указатель-в-интерфейс-Что-если-сравнить-интерфейс-с-nil"><a href="#Есть-интерфейс-а-есть-указатель-на-структуру-который-nil-Кладем-указатель-в-интерфейс-Что-если-сравнить-интерфейс-с-nil" class="headerlink" title="Есть интерфейс, а есть указатель на структуру, который nil. Кладем указатель в интерфейс. Что если сравнить интерфейс с nil?"></a>Есть интерфейс, а есть указатель на структуру, который nil. Кладем указатель в интерфейс. Что если сравнить интерфейс с nil?</h2><p>Интерфейс в Go является типом, который может хранить любые типы, удовлетворяющие ему.</p><p>Интерфейс, в котором лежит указатель на структуру, и nil интерфейс сравнимы между собой. Если вы сравните интерфейс, в котором лежит указатель на структуру, с nil, результат будет “false”, потому что интерфейс не пустой.</p><p>Однако, если вы сравните интерфейс с интерфейсом, содержащим nil указатель, результат будет “false”.</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SomeInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    SomeMethod()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SomeStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SomeStruct)</span> <span class="title">SomeMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s SomeStruct</span><br><span class="line">    <span class="keyword">var</span> i1 SomeInterface = &amp;s</span><br><span class="line">    <span class="keyword">var</span> i2 SomeInterface</span><br><span class="line"></span><br><span class="line">    fmt.Println(i1 == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">    fmt.Println(i2 == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В примере выше мы создаем интерфейс SomeInterface с методом SomeMethod. Внутри интерфейса i1 лежит указатель на структуру SomeStruct, а интерфейс i2 является пустым интерфейсом. Сравнивая i1 с nil, мы получаем “false”, так как интерфейс i1 не пустой. Сравнивая i2 с nil, мы получаем “true”, так как интерфейс i2 является пустым интерфейсом.</p><h2 id="Чем-any-отличается-от-пустого-интерфейса"><a href="#Чем-any-отличается-от-пустого-интерфейса" class="headerlink" title="Чем any отличается от пустого интерфейса?"></a>Чем <code>any</code> отличается от пустого интерфейса?</h2><p>Пустой интерфейс в Go (nil интерфейс) не хранит значение. Если интерфейс пустой, то его сравнение с nil будет всегда возвращать true.</p><p>Тип any (тоже известный как интерфейс <strong><code>interface&#123;&#125;</code></strong>) в Go - это специальный тип интерфейса, который может хранить значение любого типа. Тип any является универсальным типом и может быть использован, когда нужно написать обобщенный код, который будет работать с различными типами.</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i1 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = (*SomeStruct)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(i1 == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">    fmt.Println(i2 == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Чем-пустой-интерфейс-отличается-от-пустой-структуры"><a href="#Чем-пустой-интерфейс-отличается-от-пустой-структуры" class="headerlink" title="Чем пустой интерфейс отличается от пустой структуры?"></a>Чем пустой интерфейс отличается от пустой структуры?</h2><p>Пустой интерфейс (interface{}) и пустая структура (struct{}) являются двумя различными понятиями в Go.</p><p>Пустая структура (struct{}) не содержит никаких полей и не реализует никаких методов. Она используется в основном для создания переменных, которые не содержат никаких данных. Например:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>Пустой интерфейс (interface{}), с другой стороны, может указывать на любое значение любого типа. Он не имеет никаких методов и не содержит никаких данных. Он используется в основном для передачи значений различных типов в функции или методы. Например:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyInterface <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">emptyInterface = <span class="number">10</span></span><br><span class="line">emptyInterface = <span class="string">&quot;hello&quot;</span></span><br><span class="line">emptyInterface = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure><p>Таким образом, основное отличие заключается в том, что пустая структура не может указывать на значения различных типов, в то время как пустой интерфейс может.</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">  Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a Abser</span><br><span class="line">  f := MyFloat(-math.Sqrt2)</span><br><span class="line">  v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">  </span><br><span class="line">  a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">  a = &amp;v <span class="comment">// a *Vertex implements Abser  реализует интерфейс</span></span><br><span class="line"></span><br><span class="line">  a = v  <span class="comment">// Ошибка! v - это Vertex (а не *Vertex) и НЕ реализует интерфейс</span></span><br><span class="line">  fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">  X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/golang_interface.jpg" alt="Вот вам и interface"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/types/pointers/</turbo:source>
      <turbo:topic>Указатели</turbo:topic>
      <title>Указатели</title>
      <link>https://goxpert.ru/2024/06/01/types/pointers/</link>
      <pubDate>Sat, 01 Jun 2024 07:11:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/types/interface/">Предыдущая статья: Интерфейсы</link>
        <link url="https://goxpert.ru/2024/06/01/types/structs/">Следующая статья: Структуры</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Что-такое-указатель-pointer"><a href="#Что-такое-указатель-pointer" class="headerlink" title="Что такое указатель (pointer)?"></a>Что такое указатель (<a href="https://go.dev/tour/moretypes/1">pointer</a>)?</h2><p>Указатель в программировании - это переменная, которая хранит адрес другой переменной в памяти. В Go, указатели используются для того, чтобы иметь возможность изменять значение переменной напрямую или для оптимизации производительности при работе с большими структурами данных.</p><p>Вы можете получить адрес переменной с помощью оператора <code>&amp;</code>, а затем этот адрес можно сохранить в указателе. Для доступа к значению, на которое указывает указатель, используется оператор <code>*</code>.</p><p>Вот пример:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">    p = &amp;x <span class="comment">// Получаем адрес переменной x и сохраняем его в p</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(*p) <span class="comment">// Выводим значение переменной, на которую указывает p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере <code>p</code> является указателем на <code>x</code>, и <code>*p</code> дает нам доступ к значению <code>x</code>.</p><h2 id="Что-такое-ссылка-на-значение"><a href="#Что-такое-ссылка-на-значение" class="headerlink" title="Что такое ссылка на значение?"></a>Что такое ссылка на значение?</h2><p>В Go, ссылка на значение обычно означает использование указателей. Указатель - это переменная, которая хранит адрес другой переменной. </p><p>Вы можете получить адрес переменной с помощью оператора <code>&amp;</code>, а затем этот адрес можно сохранить в указателе. Для доступа к значению, на которое указывает указатель, используется оператор <code>*</code>.</p><p>Вот пример:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">    p = &amp;x <span class="comment">// Получаем адрес переменной x и сохраняем его в p</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(*p) <span class="comment">// Выводим значение переменной, на которую указывает p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере <code>p</code> является указателем на <code>x</code>, и <code>*p</code> дает нам доступ к значению <code>x</code>.</p><h2 id="Чем-отличается-ссылка-от-указателя"><a href="#Чем-отличается-ссылка-от-указателя" class="headerlink" title="Чем отличается ссылка от указателя?"></a>Чем отличается ссылка от указателя?</h2><p>В Go, термины “ссылка” и “указатель” часто используются взаимозаменяемо, но они имеют некоторые различия.</p><ol><li><strong>Указатель</strong> - это переменная, которая хранит адрес другой переменной. Указатели могут быть нулевыми, что означает, что они не указывают ни на одну переменную.</li><li><strong>Ссылка</strong> - это альтернативное имя для уже существующей переменной. В Go, ссылки как таковые не существуют, но аналогом являются указатели.</li></ol><p>Основное различие между ними заключается в том, что указатели могут быть переназначены для указания на разные переменные во время выполнения, в то время как ссылки, как правило, не могут быть изменены после их инициализации (хотя в Go это не применимо, так как нет ссылок в традиционном понимании этого термина).</p><h2 id="Чем-чревато-передавать-структуру-по-ссылке"><a href="#Чем-чревато-передавать-структуру-по-ссылке" class="headerlink" title="Чем чревато передавать структуру по ссылке?"></a>Чем чревато передавать структуру по ссылке?</h2><p>Передача структуры по ссылке в Go означает передачу указателя на структуру. Это может иметь следующие последствия:</p><ol><li><strong>Изменение оригинальной структуры</strong>: Поскольку вы передаете указатель, любые изменения, которые вы вносите в структуру внутри функции, будут отражаться на оригинальной структуре. Это может быть как полезным, так и опасным, в зависимости от того, ожидаете ли вы эти изменения.</li><li><strong>Производительность</strong>: Передача структуры по ссылке обычно быстрее, чем передача по значению, особенно для больших структур, поскольку не требуется копирование всей структуры.</li><li><strong>Nullability</strong>: Указатели могут быть <code>nil</code>, в то время как структуры - нет. Это значит, что если вы передаете структуру по ссылке, вам нужно быть уверенным, что она не <code>nil</code>, прежде чем обращаться к ее полям, иначе вы получите панику во время выполнения.</li></ol><p>В общем, передача структуры по ссылке может быть полезной для оптимизации производительности и для изменения оригинальной структуры, но требует более внимательного обращения, чтобы избежать ошибок во время выполнения.</p><h2 id="Для-чего-используются-указатели"><a href="#Для-чего-используются-указатели" class="headerlink" title="Для чего используются указатели?"></a>Для чего используются указатели?</h2><p>Указатели в Go используются по нескольким причинам:</p><ol><li><strong>Изменение значения в функции</strong>: Если вы хотите, чтобы функция изменяла значение переменной, вы можете передать указатель на эту переменную в функцию. Это позволяет функции напрямую изменять значение переменной, а не ее копию.</li><li><strong>Оптимизация производительности</strong>: Для больших структур данных передача указателей может быть более эффективной, чем передача значений, поскольку передача значений включает в себя копирование всей структуры данных.</li><li><strong>Работа с динамическими структурами данных</strong>: Указатели необходимы для создания сложных структур данных, таких как связанные списки, деревья, графы и т.д.</li><li><strong>Интерфейсы и полиморфизм</strong>: Указатели используются для реализации интерфейсов и полиморфизма. Если методы определены для указателя на тип, то только указатели этого типа могут использоваться для вызова этих методов.</li></ol><p>Вот пример использования указателей для изменения значения в функции:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *x = *x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    increment(&amp;x)</span><br><span class="line">    fmt.Println(x) <span class="comment">// Выводит 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере функция <code>increment</code> принимает указатель на <code>int</code> и увеличивает значение, на которое указывает этот указатель.</p><h2 id="Для-чего-в-практике-используешь-указатели"><a href="#Для-чего-в-практике-используешь-указатели" class="headerlink" title="Для чего в практике используешь указатели?"></a>Для чего в практике используешь указатели?</h2><p>В практическом программировании на Go указатели используются в следующих ситуациях:</p><ol><li><strong>Изменение значения переменной в функции</strong>: Если вы хотите изменить значение переменной внутри функции, вы передаете указатель на эту переменную в функцию. Это позволяет функции напрямую изменять значение переменной, а не ее копию.</li><li><strong>Оптимизация производительности</strong>: Для больших структур данных передача указателей может быть более эффективной, чем передача значений, поскольку передача значений включает в себя копирование всей структуры данных.</li><li><strong>Работа с динамическими структурами данных</strong>: Указатели необходимы для создания сложных структур данных, таких как связанные списки, деревья, графы и т.д.</li><li><strong>Интерфейсы и полиморфизм</strong>: Указатели используются для реализации интерфейсов и полиморфизма. Если методы определены для указателя на тип, то только указатели этого типа могут использоваться для вызова этих методов.</li><li><strong>Опциональные поля в структурах</strong>: В Go, указатели могут быть <code>nil</code>, что позволяет им использоваться для представления опциональных полей в структурах.</li><li><strong>Работа с внешними ресурсами</strong>: Указатели часто используются при работе с внешними ресурсами, такими как файлы или сетевые соединения. Это позволяет функциям и методам изменять состояние этих ресурсов.</li></ol><h2 id="Какие-есть-средства-для-работы-с-указателями"><a href="#Какие-есть-средства-для-работы-с-указателями" class="headerlink" title="Какие есть средства для работы с указателями?"></a>Какие есть средства для работы с указателями?</h2><p>В Go есть несколько ключевых средств для работы с указателями:</p><ol><li><strong>Оператор <code>&amp;</code></strong>: Этот оператор используется для получения адреса переменной. Например, если <code>x</code> - это переменная, то <code>&amp;x</code> - это адрес этой переменной.</li><li><strong>Оператор <code>*</code></strong>: Этот оператор используется для доступа к значению, на которое указывает указатель. Например, если <code>p</code> - это указатель на <code>int</code>, то <code>*p</code> - это <code>int</code>, на который указывает <code>p</code>.</li><li><strong>Функция <code>new</code></strong>: Эта функция создает новую переменную заданного типа, инициализирует ее нулем и возвращает указатель на нее.</li></ol><p>Вот пример использования этих средств:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    p := &amp;x <span class="comment">// Получаем адрес переменной x</span></span><br><span class="line">    fmt.Println(*p) <span class="comment">// Выводим значение, на которое указывает p</span></span><br><span class="line"></span><br><span class="line">    y := <span class="built_in">new</span>(<span class="keyword">int</span>) <span class="comment">// Создаем новую переменную типа int и получаем указатель на нее</span></span><br><span class="line">    fmt.Println(*y) <span class="comment">// Выводит 0, так как новые переменные инициализируются нулем</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере <code>p</code> - это указатель на <code>x</code>, и <code>*p</code> дает нам доступ к значению <code>x</code>. <code>y</code> - это указатель на новую переменную <code>int</code>, инициализированную нулем.</p><h2 id="Когда-лучше-использовать-не-использовать-указатели"><a href="#Когда-лучше-использовать-не-использовать-указатели" class="headerlink" title="Когда лучше использовать/не использовать указатели?"></a>Когда лучше использовать/не использовать указатели?</h2><p>Указатели в Go могут быть полезными, но их использование зависит от конкретной ситуации. Вот несколько рекомендаций:</p><p><strong>Используйте указатели, когда:</strong></p><ol><li><strong>Вы хотите изменить значение переменной внутри функции.</strong> Если вы передаете переменную по значению, функция получит копию этой переменной, и любые изменения, которые вы внесете, не повлияют на исходную переменную. Если вы передаете переменную по ссылке (т.е. передаете указатель на нее), функция сможет изменить исходную переменную.</li><li><strong>Вы работаете с большими структурами данных.</strong> Передача больших структур данных по значению может быть накладной с точки зрения производительности, поскольку это требует копирования всей структуры. Передача указателя на структуру вместо этого может быть более эффективной.</li><li><strong>Вы хотите иметь возможность присвоить переменной значение <code>nil</code>.</strong> В Go, только указатели могут иметь значение <code>nil</code>.</li></ol><p><strong>Избегайте использования указателей, когда:</strong></p><ol><li><strong>Вы работаете с небольшими структурами данных или простыми типами.</strong> Для небольших структур данных или простых типов, таких как <code>int</code> или <code>bool</code>, передача по значению обычно быстрее и безопаснее.</li><li><strong>Вы не хотите, чтобы функция изменяла исходную переменную.</strong> Если вы передаете переменную по значению, функция не сможет изменить исходную переменную, что может быть полезно для предотвращения неожиданных побочных эффектов.</li><li><strong>Вы хотите избежать ошибок во время выполнения, связанных с <code>nil</code>.</strong> Если вы используете указатель, вам нужно быть уверенным, что он не <code>nil</code>, прежде чем обращаться к его значению, иначе вы получите панику во время выполнения.</li></ol><p><img src="/images/golang_pointer.jpg" alt="Вот вам и pointer"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/types/structs/</turbo:source>
      <turbo:topic>Структуры</turbo:topic>
      <title>Структуры</title>
      <link>https://goxpert.ru/2024/06/01/types/structs/</link>
      <pubDate>Sat, 01 Jun 2024 07:10:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/types/pointers/">Предыдущая статья: Указатели</link>
        <link url="https://goxpert.ru/2024/06/01/types/strings/">Следующая статья: Строки</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Имеет-ли-значение-порядок-полей-в-структуре"><a href="#Имеет-ли-значение-порядок-полей-в-структуре" class="headerlink" title="Имеет ли значение порядок полей в структуре?"></a>Имеет ли значение порядок полей в структуре?</h2><p>Да, порядок полей в структуре Go может иметь значение в некоторых случаях.</p><p>Выравнивание памяти: Go размещает поля структур в соответствии с гарантиями выравнивания для типов полей. Это может влиять на общий размер структуры и использование памяти.</p><p>Источники: </p><ul><li><a href="https://ru.stackoverflow.com/questions/1541584/%d0%9f%d0%be%d1%80%d1%8f%d0%b4%d0%be%d0%ba-%d0%bf%d0%b5%d1%80%d0%b5%d0%bc%d0%bd%d0%bd%d1%8b%d1%85-%d0%b2-%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%82%d1%83%d1%80%d0%b5-go-golang">Stackoverflow</a></li></ul><h2 id="От-чего-зависит-размер-выравнивания-в-структуре"><a href="#От-чего-зависит-размер-выравнивания-в-структуре" class="headerlink" title="От чего зависит размер выравнивания в структуре?"></a>От чего зависит размер выравнивания в структуре?</h2><p>Размер выравнивания в структуре в Go зависит от нескольких факторов:</p><ul><li>Тип данных: Размер выравнивания обычно зависит от типа данных. Например, int32 требует выравнивания по 4 байтам.</li><li>Порядок полей: Порядок полей в структуре может влиять на размер выравнивания. Если поля структуры переставить, размер структуры может измениться.</li><li>Архитектура системы: Размер выравнивания также может зависеть от архитектуры системы. Например, на 32-битной архитектуре структуры выравниваются под 4 байта.</li></ul><p>Важно отметить, что выравнивание влияет на производительность и использование памяти, поэтому его следует учитывать при проектировании структур.</p><p><img src="/images/golang_struct.jpg" alt="Вот вам и struct"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/types/strings/</turbo:source>
      <turbo:topic>Строки</turbo:topic>
      <title>Строки</title>
      <link>https://goxpert.ru/2024/06/01/types/strings/</link>
      <pubDate>Sat, 01 Jun 2024 07:09:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/types/structs/">Предыдущая статья: Структуры</link>
        <link url="https://goxpert.ru/2024/06/01/types/array-slice/">Следующая статья: Массивы и слайсы</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Что-такое-string-или-строки"><a href="#Что-такое-string-или-строки" class="headerlink" title="Что такое string или строки?"></a>Что такое string или строки?</h2><p>Строка в golang - это последовательность символов, которая представляет собой текстовые данные.<br>Строки в golang объявляются с типом string и заключаются в двойные кавычки, например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">// или сокращенная запись</span></span><br><span class="line">s := <span class="string">&quot;hey&quot;</span></span><br></pre></td></tr></table></figure><p>Строки в golang являются неизменяемыми, то есть их нельзя модифицировать после создания. Однако, можно создавать новые строки из существующих, используя различные операции и функции. </p><p>Например, можно склеивать строки с помощью оператора +, сравнивать строки с помощью оператора ==, или применять функции из пакета <code>strings</code> для поиска, замены, преобразования и других манипуляций со строками.</p><p>Строки в golang хранят символы в кодировке UTF-8, которая поддерживает множество языков и специальных символов.</p><p>Каждый символ в строке называется руной (<code>rune</code>), которая является псевдонимом для типа <code>int32</code>. Руны можно получать из строк с помощью цикла for-range или функции range, а также преобразовывать в строки с помощью функции <code>string</code>.</p><p>Источники: </p><ul><li><a href="https://www.programiz.com/golang/string">Programiz</a></li><li><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-the-strings-package-in-go-ru">DigitalOcean</a></li></ul><h2 id="Какие-особенности-есть-у-string"><a href="#Какие-особенности-есть-у-string" class="headerlink" title="Какие особенности есть у string?"></a>Какие особенности есть у string?</h2><p>Строка в golang - это неизменяемая последовательность символов в кодировке UTF-8, которая представляет собой текстовые данные. Строки в golang имеют тип <code>string</code> и заключаются в двойные кавычки или обратные апострофы. Строки в golang поддерживают множество языков и специальных символов, включая русские буквы и эмодзи. </p><p>Строки в golang можно объединять, сравнивать, искать, заменять, преобразовывать и выполнять другие манипуляции с помощью различных функций из пакета <code>strings</code>. Строки в golang также можно преобразовывать в руны (кодовые значения символов) и байты (единицы хранения данных) для более низкоуровневой работы с текстом</p><ul><li><a href="https://golangify.com/string">Golangify</a></li></ul><h2 id="Как-устроена-строка-внутри-а-точнее-reflect-String-и-reflect-StringHeader"><a href="#Как-устроена-строка-внутри-а-точнее-reflect-String-и-reflect-StringHeader" class="headerlink" title="Как устроена строка внутри, а точнее reflect.String и reflect.StringHeader?"></a>Как устроена строка внутри, а точнее reflect.String и reflect.StringHeader?</h2><p>reflect.String - это псевдоним для типа string, который является неизменяемой последовательностью символов в кодировке UTF-8. </p><p>reflect.StringHeader - это структура, которая содержит два поля: Data и Len. Data - это указатель на первый байт строки, а Len - это длина строки в байтах. Структура reflect.StringHeader может быть получена из строки с помощью функции unsafe.Pointer, которая преобразует любое значение в указатель безопасного типа. Например, можно использовать такой код:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">fmt.Println(sh.Data, sh.Len) <span class="comment">// выводит адрес и длину строки</span></span><br></pre></td></tr></table></figure><p>Структура reflect.StringHeader может быть также использована для создания новой строки из существующей, изменяя ее указатель или длину. Например, можно использовать такой код:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello, world!&quot;</span></span><br><span class="line">sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">sh.Data += <span class="number">7</span> <span class="comment">// сдвигаем указатель на 7 байтов</span></span><br><span class="line">sh.Len -= <span class="number">7</span> <span class="comment">// уменьшаем длину на 7 байтов</span></span><br><span class="line">fmt.Println(s) <span class="comment">// выводит &quot;world!&quot;</span></span><br></pre></td></tr></table></figure><p>Однако, такое использование reflect.StringHeader может быть опасным, так как оно нарушает неизменяемость строк и может привести к непредвиденным ошибкам или поведению. Например, если мы изменим длину строки больше, чем ее емкость, то мы можем получить доступ к памяти, которая не принадлежит строке, и вызвать панику или нарушение сегментации. Также, если мы изменим указатель на данные, то мы можем потерять ссылку на оригинальную строку и вызвать утечку памяти или сборку мусора.</p><p>Поэтому, reflect.String и reflect.StringHeader следует использовать с осторожностью и только в тех случаях, когда это необходимо для решения конкретной задачи. В большинстве случаев, можно обойтись стандартными функциями и методами для работы со строками в golang.</p><p><img src="/images/golang_string.jpg" alt="Вот вам и string"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/types/array-slice/</turbo:source>
      <turbo:topic>Массивы и слайсы</turbo:topic>
      <title>Массивы и слайсы</title>
      <link>https://goxpert.ru/2024/06/01/types/array-slice/</link>
      <pubDate>Sat, 01 Jun 2024 07:08:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/types/strings/">Предыдущая статья: Строки</link>
        <link url="https://goxpert.ru/2024/06/01/common/generics/">Следующая статья: Дженерики</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Что-такое-слайс"><a href="#Что-такое-слайс" class="headerlink" title="Что такое слайс?"></a>Что такое слайс?</h2><p>Слайс в golang - это динамический массив, который может хранить элементы одного типа. Слайс имеет нефиксированную длину, которая может изменяться в процессе работы с ним. Слайс также имеет вместимость, которая определяет, сколько элементов может поместиться в слайс без выделения новой памяти. Слайс можно создавать из массивов, с помощью функции make или литералов слайсов.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Слайс можно считать как ссылку на массив, который содержит элементы слайса.<br>Слайс состоит из трех полей: указателя на первый элемент массива, длины слайса и вместимости слайса.<br>Слайс можно передавать в функции по значению, но при этом изменение элементов слайса в функции отразится на исходном слайсе, так как они ссылаются на один и тот же массив.</p><p>Слайсом можно манипулировать с помощью различных операций и функций. Например, можно получать подслайсы с помощью оператора [:], добавлять элементы в конец слайса с помощью функции append, копировать элементы из одного слайса в другой с помощью функции copy, сортировать элементы слайса с помощью функции sort, и так далее.</p><h2 id="Чем-массив-отличается-от-слайса"><a href="#Чем-массив-отличается-от-слайса" class="headerlink" title="Чем массив отличается от слайса?"></a>Чем массив отличается от слайса?</h2><p>Массив и слайс в golang - это структуры данных, которые могут хранить элементы одного типа. Однако, между ними есть несколько отличий:</p><ul><li>Массив имеет фиксированный размер, который определяется при его создании. Слайс имеет переменную длину, которая может изменяться в процессе работы с ним.</li><li>Массив является значением, а слайс - ссылкой. При передаче массива в функцию или присваивании его другой переменной, происходит копирование всех его элементов. При передаче слайса в функцию или присваивании его другой переменной, происходит копирование только его заголовка, а не элементов.</li><li>Массив можно сравнивать с другим массивом того же размера и типа с помощью оператора ==. Слайс нельзя сравнивать с другим слайсом с помощью оператора ==, только с nil.</li><li>Массив можно инициализировать с помощью литерала массива, указав его размер и элементы в фигурных скобках. Слайс можно инициализировать с помощью литерала слайса, не указывая его размер, или с помощью функции make, указав его длину и вместимость</li></ul><h2 id="Как-работает-append"><a href="#Как-работает-append" class="headerlink" title="Как работает append?"></a>Как работает append?</h2><p>Функция append в golang позволяет добавлять элементы в конец слайса, увеличивая его длину и вместимость при необходимости. Функция append принимает слайс и один или несколько элементов того же типа, что и слайс, и возвращает новый слайс, содержащий все элементы исходного слайса и добавленные элементы. </p><p>Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создаем слайс из трех элементов</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// добавляем два элемента в конец слайса</span></span><br><span class="line">fmt.Println(s) <span class="comment">// выводит [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><p>Функция append может также принимать другой слайс в качестве аргумента, если он заключен в оператор … Это позволяет объединять два слайса в один. </p><p>Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создаем первый слайс</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// создаем второй слайс</span></span><br><span class="line">s3 := <span class="built_in">append</span>(s1, s2...) <span class="comment">// добавляем второй слайс в конец первого слайса</span></span><br><span class="line">fmt.Println(s3) <span class="comment">// выводит [1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure><p>Функция append работает таким образом, что если вместимость исходного слайса достаточна для добавления новых элементов, то она просто копирует их в свободное пространство массива, на который ссылается слайс. </p><p>Если же вместимость исходного слайса недостаточна, то функция append выделяет новый массив большего размера, копирует в него все элементы исходного слайса и добавляет новые элементы. Затем функция append возвращает новый слайс, который ссылается на новый массив.</p><h2 id="До-какого-размера-можно-увеличивать-слайс"><a href="#До-какого-размера-можно-увеличивать-слайс" class="headerlink" title="До какого размера можно увеличивать слайс?"></a>До какого размера можно увеличивать слайс?</h2><p>Размер слайса в golang ограничен только доступной памятью в системе. Однако, при увеличении размера слайса с помощью функции append, может происходить перевыделение памяти, если вместимость исходного слайса недостаточна для добавления новых элементов. При этом, функция append выделяет новый массив большего размера, копирует в него все элементы исходного слайса и добавляет новые элементы. Затем функция append возвращает новый слайс, который ссылается на новый массив.</p><p>При перевыделении памяти, функция append следует определенной стратегии, чтобы избежать частого копирования и минимизировать оверхед. При текущем размере слайса менее 256 элементов, размер памяти увеличивается вдвое (вне зависимости от запрашиваемой cap). При размере слайса больше 256 элементов, слайс увеличивается на четверть текущего размера.</p><p>Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// создаем слайс с длиной 0 и вместимостью 5</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// выводит 0 5</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// добавляем 5 элементов в слайс</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// выводит 5 5</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">6</span>) <span class="comment">// добавляем еще один элемент в слайс</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// выводит 6 10 - вместимость увеличилась вдвое</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) <span class="comment">// добавляем еще 4 элемента в слайс</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// выводит 10 10</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">11</span>) <span class="comment">// добавляем еще один элемент в слайс</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// выводит 11 20 - вместимость увеличилась вдвое</span></span><br></pre></td></tr></table></figure><h2 id="Берем-от-слайса-слайс-куда-будет-указывать-его-указатель"><a href="#Берем-от-слайса-слайс-куда-будет-указывать-его-указатель" class="headerlink" title="Берем от слайса слайс, куда будет указывать его указатель?"></a>Берем от слайса слайс, куда будет указывать его указатель?</h2><p>Если мы берем от слайса слайс, то его указатель будет указывать на тот же массив, что и указатель исходного слайса, но с другим смещением. Например, если мы имеем слайс s, который ссылается на массив [1, 2, 3, 4, 5], и мы берем от него подслайс s[1:3], то его указатель будет указывать на тот же массив, но с элемента 2. То есть, подслайс будет содержать элементы [2, 3] из исходного массива.</p><p>Это означает, что если мы изменим элементы подслайса, то это отразится на исходном слайсе и наоборот, так как они ссылаются на один и тот же массив. Однако, если мы добавим элементы в подслайс с помощью функции append, то это может привести к перевыделению памяти и созданию нового массива, если вместимость подслайса недостаточна. В этом случае, подслайс будет ссылаться на новый массив, а исходный слайс - на старый.</p><h2 id="В-чем-разница-между-слайсом-указателей-и-слайсом-значений-с-точки-зрения-вызова-функции"><a href="#В-чем-разница-между-слайсом-указателей-и-слайсом-значений-с-точки-зрения-вызова-функции" class="headerlink" title="В чем разница между слайсом указателей и слайсом значений с точки зрения вызова функции?"></a>В чем разница между слайсом указателей и слайсом значений с точки зрения вызова функции?</h2><p>Разница между слайсом указателей и слайсом значений с точки зрения вызова функции заключается в том, как они передаются и изменяются внутри функции. </p><p>Слайс указателей - это слайс, который содержит указатели на элементы другого типа, например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sp []*<span class="keyword">int</span> <span class="comment">// слайс указателей на int</span></span><br></pre></td></tr></table></figure><p>Слайс значений - это слайс, который содержит элементы другого типа, например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sv []<span class="keyword">int</span> <span class="comment">// слайс значений int</span></span><br></pre></td></tr></table></figure><p>Когда мы передаем слайс указателей в функцию, мы копируем только заголовок слайса, который содержит указатель на первый элемент, длину и вместимость.</p><p>Однако, сами элементы слайса, на которые указывают указатели, не копируются. Это означает, что если мы изменяем элементы слайса в функции, то это отразится на исходном слайсе, так как они ссылаются на одни и те же значения. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x := <span class="number">1</span></span><br><span class="line">  y := <span class="number">2</span></span><br><span class="line">  z := <span class="number">3</span></span><br><span class="line">  sp := []*<span class="keyword">int</span>&#123;&amp;x, &amp;y, &amp;z&#125; <span class="comment">// создаем слайс указателей</span></span><br><span class="line">  fmt.Println(*sp[<span class="number">0</span>], *sp[<span class="number">1</span>], *sp[<span class="number">2</span>]) <span class="comment">// выводит 1 2 3</span></span><br><span class="line">  modifySlicePointers(sp) <span class="comment">// передаем слайс в функцию</span></span><br><span class="line">  fmt.Println(*sp[<span class="number">0</span>], *sp[<span class="number">1</span>], *sp[<span class="number">2</span>]) <span class="comment">// выводит 10 20 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlicePointers</span><span class="params">(sp []*<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  *sp[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// изменяем значение, на которое указывает первый элемент слайса</span></span><br><span class="line">  *sp[<span class="number">1</span>] = <span class="number">20</span> <span class="comment">// изменяем значение, на которое указывает второй элемент слайса</span></span><br><span class="line">  *sp[<span class="number">2</span>] = <span class="number">30</span> <span class="comment">// изменяем значение, на которое указывает третий элемент слайса</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Когда мы передаем слайс значений в функцию, мы также копируем только заголовок слайса, который содержит указатель на первый элемент, длину и вместимость. Однако, сами элементы слайса, на которые указывает указатель, также не копируются. Это означает, что если мы изменяем элементы слайса в функции, то это также отразится на исходном слайсе, так как они ссылаются на одни и те же значения. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sv := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создаем слайс значений</span></span><br><span class="line">  fmt.Println(sv[<span class="number">0</span>], sv[<span class="number">1</span>], sv[<span class="number">2</span>]) <span class="comment">// выводит 1 2 3</span></span><br><span class="line">  modifySliceValues(sv) <span class="comment">// передаем слайс в функцию</span></span><br><span class="line">  fmt.Println(sv[<span class="number">0</span>], sv[<span class="number">1</span>], sv[<span class="number">2</span>]) <span class="comment">// выводит 10 20 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySliceValues</span><span class="params">(sv []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  sv[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// изменяем значение первого элемента слайса</span></span><br><span class="line">  sv[<span class="number">1</span>] = <span class="number">20</span> <span class="comment">// изменяем значение второго элемента слайса</span></span><br><span class="line">  sv[<span class="number">2</span>] = <span class="number">30</span> <span class="comment">// изменяем значение третьего элемента слайса</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Стоит быть внимательным при добавлении элементов в слайс в функции с помощью <code>append</code>, так как мы изменяем копию структуры слайса. В этом случае, слайс в функции будет иметь другие значния len, cap и, возможно, ссылки на массив. Это означает, что добавленные элементы не будут видны в исходном слайсе. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sv := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создаем слайс значений</span></span><br><span class="line">  appendSliceValues(sv) <span class="comment">// передаем слайс в функцию</span></span><br><span class="line">  fmt.Println(sv) <span class="comment">// выводит [1 2 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSliceValues</span><span class="params">(sv []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  sv = <span class="built_in">append</span>(sv, <span class="number">4</span>) <span class="comment">// добавляем элемент в слайс</span></span><br><span class="line">  fmt.Println(sv) <span class="comment">// выводит [1 2 3 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Если мы хотим, чтобы добавленные элементы сохранялись в исходном слайсе, мы должны возвращать слайс из функции и присваивать его исходному слайсу. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sv := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создаем слайс значений</span></span><br><span class="line">  sv = appendSliceValues(sv) <span class="comment">// передаем слайс в функцию и присваиваем его исходному слайсу</span></span><br><span class="line">  fmt.Println(sv) <span class="comment">// выводит [1 2 3 4]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSliceValues</span><span class="params">(sv []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  sv = <span class="built_in">append</span>(sv, <span class="number">4</span>) <span class="comment">// добавляем элемент в слайс</span></span><br><span class="line">  <span class="keyword">return</span> sv <span class="comment">// возвращаем слайс из функции</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Какие-есть-ограничения-при-работе-со-слайсом"><a href="#Какие-есть-ограничения-при-работе-со-слайсом" class="headerlink" title="Какие есть ограничения при работе со слайсом?"></a>Какие есть ограничения при работе со слайсом?</h2><p>При работе со слайсом есть некоторые ограничения, которые нужно учитывать:</p><ul><li>Слайс не может содержать элементы разных типов, только одного. Для хранения элементов разных типов нужно использовать структуры, интерфейсы или пустые интерфейсы (interface{}).</li><li>Слайс не может быть сравнен с другим слайсом с помощью оператора ==, только с nil. Для сравнения двух слайсов нужно использовать цикл или функцию reflect.DeepEqual.</li><li>Слайс не может быть использован в качестве ключа мапы, так как он не является хешируемым типом. Для использования слайса в качестве ключа мапы нужно преобразовать его в строку или другой хешируемый тип.</li><li>Слайс не может быть константой, так как он является ссылочным типом. Для объявления слайса нужно использовать var, := или make.</li><li>Слайс не может быть безопасно передан в функцию или возвращен из функции, так как он ссылается на массив, который может быть изменен в другом месте. Для безопасной передачи или возврата слайса нужно копировать его элементы в новый слайс с помощью функции copy или среза [:].</li></ul><h2 id="С-какой-скоростью-идет-поиск-в-массиве-и-почему"><a href="#С-какой-скоростью-идет-поиск-в-массиве-и-почему" class="headerlink" title="С какой скоростью идет поиск в массиве и почему?"></a>С какой скоростью идет поиск в массиве и почему?</h2><p>Самый простой алгоритм поиска в массиве - это линейный поиск, который перебирает все элементы массива по порядку, пока не найдет искомый элемент или не дойдет до конца массива.</p><p>Скорость линейного поиска пропорциональна длине массива, то есть чем больше элементов в массиве, тем дольше будет идти поиск. Сложность линейного поиска в худшем случае составляет O(n), где n - это количество элементов в массиве.</p><h2 id="Какая-есть-функции-для-создания-слайса-с-длиной-отличной-от-нуля"><a href="#Какая-есть-функции-для-создания-слайса-с-длиной-отличной-от-нуля" class="headerlink" title="Какая есть функции для создания слайса с длиной отличной от нуля?"></a>Какая есть функции для создания слайса с длиной отличной от нуля?</h2><p>Для создания слайса с длиной отличной от нуля в golang, можно использовать одну из следующих функций:</p><p>Функция make, которая принимает тип слайса, длину и вместимость, и возвращает слайс с заданными параметрами. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">// создает слайс из трех целых чисел с вместимостью пять</span></span><br></pre></td></tr></table></figure><p>Функция append, которая принимает слайс и один или несколько элементов того же типа, что и слайс, и возвращает новый слайс, содержащий все элементы исходного слайса и добавленные элементы. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;&#125; <span class="comment">// создает пустой слайс</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// добавляет три элемента в слайс</span></span><br></pre></td></tr></table></figure><p>Литерал слайса, который позволяет инициализировать слайс с помощью фигурных скобок и перечисления элементов. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создает слайс из трех целых чисел</span></span><br></pre></td></tr></table></figure><h2 id="Допустима-ли-конкуррентная-работа-со-слайсом"><a href="#Допустима-ли-конкуррентная-работа-со-слайсом" class="headerlink" title="Допустима ли конкуррентная работа со слайсом?"></a>Допустима ли конкуррентная работа со слайсом?</h2><p>Такая работа может быть допустима, если соблюдены определенные условия и предосторожности:</p><ul><li>Во-первых, конкуррентное чтение слайса не представляет опасности, если никто не пишет в слайс в то же время. То есть, можно безопасно читать слайс из нескольких горутин, если слайс не изменяется.</li><li>Во-вторых, конкуррентная запись в слайс может привести к гонке данных (data race), если не использовать синхронизацию или атомарные операции.</li></ul><p>Для предотвращения гонки данных, можно использовать один из следующих способов:</p><ul><li>Использовать мьютекс sync.Mutex или sync.RWMutex для защиты слайса от одновременного доступа. </li><li>Использовать атомарные операции (sync/atomic) для изменения отдельных элементов слайса.</li><li>Использовать каналы для передачи слайса между горутинами.</li></ul><p><img src="/images/golang_slices.jpg" alt="Вот вам и slices"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/common/generics/</turbo:source>
      <turbo:topic>Дженерики</turbo:topic>
      <title>Дженерики</title>
      <link>https://goxpert.ru/2024/06/01/common/generics/</link>
      <pubDate>Sat, 01 Jun 2024 07:07:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/types/array-slice/">Предыдущая статья: Массивы и слайсы</link>
        <link url="https://goxpert.ru/2024/06/01/common/constructions/">Следующая статья: Конструкции</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Чем-кодогенерация-отличается-от-дженериков"><a href="#Чем-кодогенерация-отличается-от-дженериков" class="headerlink" title="Чем кодогенерация отличается от дженериков?"></a>Чем кодогенерация отличается от дженериков?</h2><p>Кодогенерация и дженерики - это два способа написания кода, который не зависит от конкретных типов данных. Однако, они отличаются по тому, когда и как происходит привязка к типам.</p><p>Кодогенерация - это процесс создания кода из другого кода или данных с помощью специальных инструментов или команд. Кодогенерация позволяет писать обобщенный код, который затем преобразуется в конкретный код для каждого типа данных. Кодогенерация происходит на этапе компиляции или до него, то есть до выполнения программы. Кодогенерация может быть полезна для увеличения производительности, избежания дублирования кода или реализации сложной логики.</p><p>Дженерики - это способ написания кода, который параметризован по типам данных. Дженерики позволяют писать функции и типы, которые работают с любыми типами данных, передавая их в качестве аргументов. Дженерики происходят на этапе выполнения, то есть во время работы программы. Дженерики могут быть полезны для повышения выразительности, уменьшения количества кода или поддержки полиморфизма.</p><h2 id="В-какой-версии-появились-дженерики"><a href="#В-какой-версии-появились-дженерики" class="headerlink" title="В какой версии появились дженерики?"></a>В какой версии появились дженерики?</h2><p>В языке Go до версии 1.18 не было поддержки дженериков, поэтому разработчики часто использовали кодогенерацию или рефлексию для написания обобщенного кода. </p><p>В версии 1.18 добавлена поддержка дженериков с помощью параметров типов (type parameters), которые позволяют определять функции и типы, которые принимают любые типы данных в качестве аргументов.</p><h2 id="Как-работают-дженерики-под-капотом"><a href="#Как-работают-дженерики-под-капотом" class="headerlink" title="Как работают дженерики под капотом?"></a>Как работают дженерики под капотом?</h2><p>Дженерики под капотом в golang работают с помощью механизма, который называется type substitution (подстановка типов). Это означает, что при компиляции программы, компилятор заменяет параметры типов в дженерических функциях и типах на конкретные типы, которые передаются в качестве аргументов. </p><p>Например, если мы имеем такую дженерическую функцию:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span>[<span class="title">F</span>, <span class="title">T</span> <span class="title">any</span>]<span class="params">(s T, f F)</span> []<span class="title">T</span></span> &#123;</span><br><span class="line">  r := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    r[i] = f(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>И мы вызываем ее так:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> strconv.Itoa(x) &#125;</span><br><span class="line">t := Map(s, f)</span><br></pre></td></tr></table></figure><p>То компилятор преобразует ее в такую функцию:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map_int_string</span><span class="params">(s []<span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">string</span>) []<span class="title">string</span></span> &#123;</span><br><span class="line">  r := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    r[i] = f(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>И вызывает ее так:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> strconv.Itoa(x) &#125;</span><br><span class="line">t := Map_int_string(s, f)</span><br></pre></td></tr></table></figure><pre><code>                                                                          2</code></pre><p>Таким образом, дженерики под капотом в golang не требуют дополнительной памяти или рефлексии, так как они превращаются в обычный код для каждого типа данных. </p><p>Однако, это также означает, что дженерики под капотом в golang могут привести к увеличению размера исполняемого файла, так как для каждого типа данных создается своя версия дженерической функции или типа</p><p>Источники: </p><ul><li><a href="https://habr.com/ru/companies/karuna/articles/552944/">Habr</a></li><li><a href="https://habr.com/ru/companies/skillfactory/articles/657853/">Habr</a></li></ul><p><img src="/images/golang_generics.jpg" alt="Вот вам и дженерик"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/common/constructions/</turbo:source>
      <turbo:topic>Конструкции</turbo:topic>
      <title>Конструкции</title>
      <link>https://goxpert.ru/2024/06/01/common/constructions/</link>
      <pubDate>Sat, 01 Jun 2024 07:06:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/common/generics/">Предыдущая статья: Дженерики</link>
        <link url="https://goxpert.ru/2024/06/01/common/errors-panics/">Следующая статья: Ошибки / Panic</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Гарантирует-ли-порядок-выполнения-конструкция-select-case"><a href="#Гарантирует-ли-порядок-выполнения-конструкция-select-case" class="headerlink" title="Гарантирует ли порядок выполнения конструкция select-case?"></a>Гарантирует ли порядок выполнения конструкция select-case?</h2><p>В Go, порядок выполнения операторов в конструкции select-case не гарантируется.</p><p>Когда у вас есть несколько операторов case в конструкции select, и они все готовы для выполнения (то есть каналы готовы для чтения/записи), Go выбирает один из них случайным образом.</p><p>Это означает, что вы не можете предсказать или контролировать, какой оператор case будет выполнен первым, если у вас есть несколько готовых для выполнения операторов case. Это помогает предотвратить блокировку и гарантировать, что все горутины имеют равные шансы на выполнение.</p><p>Источники: </p><ul><li><a href="https://advicemama.ru/primenenie-operatora-select-v-yazyke-golang-osnovnye-principy-i-sposoby-ispolzovaniya/">Advicemama</a></li></ul><h2 id="Как-выглядит-конструкция-утверждения-типа-switch"><a href="#Как-выглядит-конструкция-утверждения-типа-switch" class="headerlink" title="Как выглядит конструкция утверждения типа switch?"></a>Как выглядит конструкция утверждения типа switch?</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> Type2:</span><br><span class="line"><span class="keyword">case</span> SomeType:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Нужно-ли-в-switch-case-проставлять-break"><a href="#Нужно-ли-в-switch-case-проставлять-break" class="headerlink" title="Нужно ли в switch-case проставлять break?"></a>Нужно ли в switch-case проставлять break?</h2><p>В языке программирования Go, вам не нужно использовать break в конструкции switch-case. В отличие от некоторых других языков программирования, таких как C++ или Java, каждый case в Go автоматически прерывается, и выполнение программы продолжается после конструкции switch-case. Это означает, что после каждого case не нужно явно указывать break.</p><p>Однако, если вы хотите, чтобы выполнение продолжилось и в следующем case, вы можете использовать ключевое слово fallthrough.</p><p>Надеюсь, это помогло вам лучше понять, как работает конструкция switch-case в Go! Если у вас есть еще вопросы, не стесняйтесь задавать.</p><p><img src="/images/golang_constructions.jpg" alt="Вот вам и конструкции"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/common/errors-panics/</turbo:source>
      <turbo:topic>Ошибки / Panic</turbo:topic>
      <title>Ошибки / Panic</title>
      <link>https://goxpert.ru/2024/06/01/common/errors-panics/</link>
      <pubDate>Sat, 01 Jun 2024 07:05:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/common/constructions/">Предыдущая статья: Конструкции</link>
        <link url="https://goxpert.ru/2024/06/01/common/defer/">Следующая статья: Defer</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Что-такое-паника"><a href="#Что-такое-паника" class="headerlink" title="Что такое паника?"></a>Что такое паника?</h2><p>Паника в программировании на Go обозначает серьезную ошибку, которая обычно приводит к немедленному завершению программы. Паника вызывает немедленное прекращение выполнения функции и начинает раскрутку стека Вы можете использовать функции defer и recover для перехвата и обработки паники.</p><h2 id="Что-используется-для-обработки-паники-Куда-нужно-помещать-recover"><a href="#Что-используется-для-обработки-паники-Куда-нужно-помещать-recover" class="headerlink" title="Что используется для обработки паники / Куда нужно помещать recover??"></a>Что используется для обработки паники / Куда нужно помещать recover??</h2><p>В Go для обработки паники используются функции <code>defer</code> и <code>recover</code>:</p><ul><li>Defer: Функция <code>defer</code> в Go позволяет отложить выполнение функции до того, как окружающая функция завершит свое выполнение. Это полезно для обработки ошибок и очистки ресурсов.</li><li>Recover: Функция <code>recover</code> используется для перехвата и обработки паник. Она должна вызываться внутри отложенной функции.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered from&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// Код, который может вызвать панику</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Какая-парадигма-в-Golang-с-точки-зрения-обработки-исключений-и-ошибок"><a href="#Какая-парадигма-в-Golang-с-точки-зрения-обработки-исключений-и-ошибок" class="headerlink" title="Какая парадигма в Golang с точки зрения обработки исключений и ошибок?"></a>Какая парадигма в Golang с точки зрения обработки исключений и ошибок?</h2><ul><li><p>Явная обработка ошибок: В Go ошибки считаются обычной частью работы программы и должны быть явно обработаны. Если функция может вызвать ошибку, она обычно возвращает значение ошибки в качестве одного из своих возвращаемых значений.</p></li><li><p>Нет исключений: В отличие от некоторых других языков, в Go нет встроенной поддержки исключений. Вместо этого функции возвращают ошибки, которые затем проверяются и обрабатываются.</p></li><li><p>Panic и recover: Go предоставляет функции <code>panic</code> и <code>recover</code> для обработки серьезных ошибок, которые обычно приводят к завершению программы. Однако эти функции обычно используются только в случае критических ошибок, и их использование для обычной обработки ошибок не рекомендуется.</p></li><li><p>Defer: Go также предоставляет ключевое слово <code>defer</code>, которое позволяет отложить выполнение функции до того, как окружающая функция завершит свое выполнение. Это полезно для обработки ошибок и очистки ресурсов.</p></li></ul><h2 id="Какие-есть-функции-для-оборачивания-и-сравнения-ошибок"><a href="#Какие-есть-функции-для-оборачивания-и-сравнения-ошибок" class="headerlink" title="Какие есть функции для оборачивания и сравнения ошибок?"></a>Какие есть функции для оборачивания и сравнения ошибок?</h2><p>В Go есть несколько функций, которые можно использовать для оборачивания и сравнения ошибок:</p><p>Оборачивание ошибок:</p><ul><li><p><code>fmt.Errorf</code>: Эта функция используется для создания новой ошибки, которая включает в себя сообщение об ошибке и другую ошибку в качестве причины. Начиная с Go 1.13, <code>fmt.Errorf</code> поддерживает оборачивание ошибок с помощью нового модификатора формата <code>%w</code>.</p></li><li><p>Сравнение ошибок:</p><ul><li><code>errors.Is</code>: Эта функция используется для проверки, является ли одна ошибка другой ошибкой. Она выполняет проверку на равенство ошибок и учитывает обернутые ошибки.</li><li><code>errors.As</code>: Эта функция используется для проверки, является ли ошибка или обернутая ошибка определенным типом. Если это так, она присваивает эту ошибку указанному значению.<br>Эти функции позволяют более эффективно работать с ошибками в Go, обеспечивая больше информации об ошибках и делая код более читаемым.</li></ul></li></ul><h2 id="Для-чего-используются-ошибки-а-для-чего-паника"><a href="#Для-чего-используются-ошибки-а-для-чего-паника" class="headerlink" title="Для чего используются ошибки, а для чего паника?"></a>Для чего используются ошибки, а для чего паника?</h2><p>В Go ошибки и паника используются для разных целей:</p><p>Ошибки:</p><ul><li>Ошибки в Go обычно используются для обработки ожидаемых проблем, которые могут возникнуть во время выполнения программы.</li><li>Если функция может вызвать ошибку, она обычно возвращает значение ошибки в качестве одного из своих возвращаемых значений.</li><li>Эти ошибки затем проверяются и обрабатываются явно в коде.</li></ul><p>Паника:</p><ul><li>Паника в Go обычно используется для обработки неожиданных ошибок, которые не могут быть обработаны или которые должны привести к немедленному завершению программы.</li><li>Паника вызывает немедленное прекращение выполнения функции и начинает раскрутку стека.</li><li>Вы можете использовать функции <code>defer</code> и <code>recover</code> для перехвата и обработки паники.</li><li>Важно отметить, что хотя паника может казаться похожей на исключения в некоторых других языках, в Go предпочитают явную обработку ошибок, и паника обычно используется только в случае серьезных ошибок.</li></ul><p><img src="/images/golang_panic.jpg" alt="Вот вам и паника!"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/common/defer/</turbo:source>
      <turbo:topic>Defer</turbo:topic>
      <title>Defer</title>
      <link>https://goxpert.ru/2024/06/01/common/defer/</link>
      <pubDate>Sat, 01 Jun 2024 07:04:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/common/errors-panics/">Предыдущая статья: Ошибки / Panic</link>
        <link url="https://goxpert.ru/2024/06/01/common/package/">Следующая статья: Пакеты</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Что-такое-defer-как-работает-зачем-нужен"><a href="#Что-такое-defer-как-работает-зачем-нужен" class="headerlink" title="Что такое defer, как работает, зачем нужен?"></a>Что такое defer, как работает, зачем нужен?</h2><p>defer - это ключевое слово в языке программирования Go, которое используется для определения функции, которая должна быть выполнена после возвращения текущей функции, но до возвращения вызвавшей ее функции. Это позволяет очистить ресурсы или выполнить другие задачи, которые необходимо выполнить после завершения основной работы функции.</p><p>Когда вызывается функция с ключевым словом defer, она не выполняется немедленно. Вместо этого она добавляется в список функций, которые будут выполняться в обратном порядке после возвращения текущей функции. Это означает, что последняя функция, вызванная с ключевым словом defer, будет выполнена первой после возврата текущей функции.</p><p>Ключевое слово defer полезно для обеспечения правильной очистки ресурсов, например, для закрытия файлов или сетевых соединений. Его также можно использовать для упрощения обработки ошибок, позволяя функции возвращать значение ошибки, а затем обрабатывать эту ошибку в одном месте после возврата функции.</p><p>Источники: </p><ul><li><a href="https://habr.com/ru/articles/492948/">Habr</a></li><li><a href="https://www.digitalocean.com/community/tutorials/understanding-defer-in-go-ru">DigitalOcean</a></li></ul><h2 id="Код-в-defer-выполняется-до-return-или-после"><a href="#Код-в-defer-выполняется-до-return-или-после" class="headerlink" title="Код в defer выполняется до return или после?"></a>Код в defer выполняется до return или после?</h2><p>Оператор defer в Go выполняется перед оператором return. Это позволяет удобно управлять ресурсами, такими как закрытие файлов или освобождение памяти, перед тем как функция завершится. </p><p>defer выполняется после того, как оператор return вычислит возвращаемые значения, но перед фактическим возвращением управления из функции.</p><p>Пример:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(changePointer())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Third&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changePointer</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;First&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Fourth&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Где-инициализируется-defer-в-стеке-или-куче"><a href="#Где-инициализируется-defer-в-стеке-или-куче" class="headerlink" title="Где инициализируется defer, в стеке или куче?"></a>Где инициализируется defer, в стеке или куче?</h2><p>Дефер-вызовы в Go инициализируются в стеке, а не в куче. Когда функция, содержащая дефер-вызовы, начинает выполняться, эти вызовы помещаются в стек. Затем, когда функция завершается, стек разворачивается, и дефер-вызовы выполняются в обратном порядке, в котором они были помещены в стек. Это позволяет гарантировать, что ресурсы, такие как файлы или соединения, будут освобождены в правильном порядке, даже если в функции произойдет ошибка.</p><h2 id="Задача-1"><a href="#Задача-1" class="headerlink" title="Задача #1"></a>Задача #1</h2><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tmp := <span class="number">101</span></span><br><span class="line">fmt.Println(tmp)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(tmp)</span><br><span class="line">&#125;()</span><br><span class="line">tmp = <span class="number">202</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Этот код использует концепцию “замыкания”. Замыкание - это функция, которая имеет доступ к переменным из своего внешнего контекста.<br>В данном случае, анонимная функция, которая откладывается с помощью defer, имеет доступ к переменной tmp из внешнего контекста.</p><p>Когда вы вызываете <code>defer func() &#123; fmt.Println(tmp) &#125;()</code>, функция “захватывает” текущее значение tmp на момент вызова. </p><p>Однако в этом случае tmp является ссылкой на переменную во внешнем контексте. Это значит, что если tmp изменяется после вызова defer, то измененное значение будет использоваться в отложенной функции.</p><p>tmp сначала устанавливается в 101, затем выводится, затем откладывается функция, которая выводит tmp, и наконец tmp изменяется на 202.<br>Когда функция main завершается, отложенная функция вызывается и выводит текущее значение tmp, которое теперь равно 202.<br>В результате, вывод программы будет 101 и 202.</p><h2 id="Задача-2"><a href="#Задача-2" class="headerlink" title="Задача #2"></a>Задача #2</h2><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tmp := <span class="number">101</span></span><br><span class="line">fmt.Println(tmp)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(tmpx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(tmpx)</span><br><span class="line">&#125;(tmp)</span><br><span class="line">tmp = <span class="number">202</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере мы передаем tmp в отложенную функцию как аргумент. Это означает, что значение tmp будет скопировано в отложенную функцию, а не ссылаться на переменную во внешнем контексте.</p><p>В результате, вывод программы будет 101 и 101.</p><p><img src="/images/golang_defer.jpg" alt="Вот вам и defer"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/common/package/</turbo:source>
      <turbo:topic>Пакеты</turbo:topic>
      <title>Пакеты</title>
      <link>https://goxpert.ru/2024/06/01/common/package/</link>
      <pubDate>Sat, 01 Jun 2024 07:03:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/common/defer/">Предыдущая статья: Defer</link>
        <link url="https://goxpert.ru/2024/06/01/overall-questions/">Следующая статья: Общие вопросы</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Что-такое-пакет"><a href="#Что-такое-пакет" class="headerlink" title="Что такое пакет?"></a>Что такое пакет?</h2><p>В языке программирования Go, пакет (package) - это коллекция исходных файлов Go, которые находятся в одной и той же директории. Все файлы в одном пакете должны иметь одно и то же имя пакета в начале файла.</p><p>Пакеты в Go используются для организации и повторного использования кода. Они представляют собой удобный способ разделения кода на отдельные модули. Это позволяет определить пакет с нужной функциональностью один раз и затем использовать его многократно в различных программах.</p><p>В Go есть два типа пакетов: исполняемые (executable) и библиотеки (reusable). Исполняемые пакеты должны иметь имя <strong><code>main</code></strong> и содержать функцию <strong><code>main</code></strong>, которая является входной точкой в приложение. Все остальные пакеты являются библиотеками и не могут быть напрямую выполнены.</p><h2 id="Расскажи-про-папку-internal"><a href="#Расскажи-про-папку-internal" class="headerlink" title="Расскажи про папку internal"></a>Расскажи про папку internal</h2><p>В Go, папка <strong><code>internal</code></strong> используется для хранения кода, который не должен быть доступен за пределами текущего модуля. Это означает, что любой код, который находится в папке <strong><code>internal</code></strong> (или в подпапках этой папки), может быть импортирован и использован только внутри того же модуля. Это полезно, когда вы хотите скрыть определенные части вашего кода от внешнего мира, чтобы предотвратить его неправильное использование.</p><figure class="highlight plaintext"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">├─ go.mod</span><br><span class="line">├─ internal</span><br><span class="line">│ └─ handler</span><br><span class="line">│   └─ opkg.go</span><br><span class="line">├─ main.go</span><br></pre></td></tr></table></figure><p><img src="/images/golang_packege.jpg" alt="Вот вам и пакет!"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/overall-questions/</turbo:source>
      <turbo:topic>Общие вопросы</turbo:topic>
      <title>Общие вопросы</title>
      <link>https://goxpert.ru/2024/06/01/overall-questions/</link>
      <pubDate>Sat, 01 Jun 2024 07:02:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
         
        <link url="https://goxpert.ru/2024/06/01/common/package/">Предыдущая статья: Пакеты</link>
        <link url="https://goxpert.ru/2024/06/01/helloworld/">Следующая статья: С 1 Июня 2024!</link>
        
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<h2 id="Какие-технологические-преимущества-экосистемы-Go-вы-можете-назвать"><a href="#Какие-технологические-преимущества-экосистемы-Go-вы-можете-назвать" class="headerlink" title="Какие технологические преимущества экосистемы Go вы можете назвать?"></a>Какие технологические преимущества экосистемы Go вы можете назвать?</h2><p>В случае с экосистемой Go к потенциальным преимуществам можно отнести:</p><ul><li>Большое и активное сообщество разработчиков, которые вносят свой вклад в развитие языка Go и его экосистемы.</li><li>Богатый набор библиотек и инструментов, облегчающих разработку, тестирование и развертывание приложений на Go.</li><li>Совместимость с широким спектром платформ и систем, что делает его универсальным выбором для создания приложений.</li><li>Сильная поддержка конкурентного и параллельного программирования, что позволяет повысить производительность и масштабируемость приложений.</li><li>Упор на простоту и читабельность, что облегчает изучение и использование языка разработчиками и способствует развитию экосистемы.</li></ul><h2 id="Go-императивный-или-декларативный-А-в-чем-разница"><a href="#Go-императивный-или-декларативный-А-в-чем-разница" class="headerlink" title="Go - императивный или декларативный? А в чем разница?"></a>Go - императивный или декларативный? А в чем разница?</h2><p>Go - императивный язык программирования. Это означает, что в нем используются инструкции, которые описывают, как выполнять задачу. В декларативных языках программирования, например, SQL, описывается, что должно быть сделано, а не как это сделать.</p><h2 id="Какие-особенности-Go-вы-можете-назвать"><a href="#Какие-особенности-Go-вы-можете-назвать" class="headerlink" title="Какие особенности Go вы можете назвать?"></a>Какие особенности Go вы можете назвать?</h2><ul><li>Статическая типизация</li><li>Сборка мусора</li><li>Конкурентность</li><li>Параллелизм</li><li>Отсутствие исключений</li><li>Строгая типизация</li><li>Строгая проверка ошибок</li></ul><h2 id="Почему-треды-в-Go-легковесные"><a href="#Почему-треды-в-Go-легковесные" class="headerlink" title="Почему треды в Go - легковесные"></a>Почему треды в Go - легковесные</h2><p>В Go горутины - это легковесные потоки, управляемые средой выполнения Go. Они более легковесны, чем потоки операционной системы, потому что занимают меньше места в памяти, обычно около 2 килобайт, по сравнению с памятью потока операционной системы, которая может составлять несколько мегабайт. Такой меньший объем памяти позволяет среде выполнения Go создавать большое количество горутин, часто тысячи или даже миллионы, не исчерпывая системных ресурсов.</p><p>Кроме того, среда выполнения Go использует планировщик, чтобы мультиплексировать горутины на меньшее число потоков операционной системы, что позволяет снизить накладные расходы на создание и управление потоками. Планировщик также может выполнять контекстные переключения между горутинами без участия операционной системы, что может быть быстрее, чем полное контекстное переключение между потоками операционной системы.</p><p>В целом, сочетание меньшего объема памяти и планировщика пользовательского пространства делает горутины легким и эффективным механизмом для параллельного выполнения в программах на Go.</p><h2 id="Какие-средства-обобщенного-программирования-есть-в-Go"><a href="#Какие-средства-обобщенного-программирования-есть-в-Go" class="headerlink" title="Какие средства обобщенного программирования есть в Go?"></a>Какие средства обобщенного программирования есть в Go?</h2><p>В Go 1.18 появилась поддержка обобщенного программирования. Обобщенное программирование - это способность писать функции и типы, которые работают с любыми типами данных, а не только с конкретными типами данных. В Go 1.18 обобщенное программирование реализовано с помощью параметризованных типов и функций.</p><h2 id="Какие-средства-метапрограммирования-есть-в-Go"><a href="#Какие-средства-метапрограммирования-есть-в-Go" class="headerlink" title="Какие средства метапрограммирования есть в Go?"></a>Какие средства метапрограммирования есть в Go?</h2><p>В Go нет средств метапрограммирования, таких как макросы, шаблоны. Вместо этого Go предоставляет мощную систему интерфейсов, которая позволяет писать гибкий и расширяемый код, который может быть легко адаптирован к различным типам данных.</p><h2 id="Какая-сортировка-используется-в-Golang"><a href="#Какая-сортировка-используется-в-Golang" class="headerlink" title="Какая сортировка используется в Golang?"></a>Какая сортировка используется в Golang?</h2><p>В Go используется алгоритм сортировки “Quicksort”, который является эффективным алгоритмом сортировки с асимптотической сложностью O(n log n). Этот алгоритм используется в стандартной библиотеке “sort” для сортировки слайсов и пользовательских коллекций данных.</p><h2 id="Какая-кодировка-используется-в-Golang"><a href="#Какая-кодировка-используется-в-Golang" class="headerlink" title="Какая кодировка используется в Golang?"></a>Какая кодировка используется в Golang?</h2><p>Go поддерживает UTF-8 кодировку по умолчанию для всех строковых типов. Это означает, что вы можете безопасно использовать Unicode символы в строках в Go. Библиотека “unicode/utf8” предоставляет функции для работы с UTF-8 кодированными строками.</p><h2 id="Можно-ли-в-Golang-создать-статический-метод"><a href="#Можно-ли-в-Golang-создать-статический-метод" class="headerlink" title="Можно ли в Golang создать статический метод?"></a>Можно ли в Golang создать статический метод?</h2><p>В Go нет классов и, следовательно, нет статических методов в традиционном понимании этого термина, как в языках, таких как Java или C++. Однако, вы можете создать функции, которые привязаны к определенному типу данных, что близко к понятию статического метода.</p><p>Вот пример:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t MyType)</span> <span class="title">StaticMethod</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.value * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере <code>StaticMethod</code> является функцией, которая привязана к типу <code>MyType</code>. Вы можете вызвать эту функцию на экземпляре <code>MyType</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := MyType&#123;value: <span class="number">5</span>&#125;</span><br><span class="line">result := t.StaticMethod() <span class="comment">// result is 10</span></span><br></pre></td></tr></table></figure><p>Это не совсем то же самое, что статический метод в языках с классами, но это ближайший аналог в Go.</p><p><img src="/images/common_questions.jpg" alt="С первым полетом!"></p> ]]></turbo:content>
      
     </item>
    
    <item turbo="true">
      <turbo:extendedHtml>true</turbo:extendedHtml>
      <turbo:source>https://goxpert.ru/2024/06/01/helloworld/</turbo:source>
      <turbo:topic>С 1 Июня 2024!</turbo:topic>
      <title>С 1 Июня 2024!</title>
      <link>https://goxpert.ru/2024/06/01/helloworld/</link>
      <pubDate>Sat, 01 Jun 2024 07:00:00 GMT</pubDate>
       
      <yandex:related type="infinity">
        
        
         
        <link url="https://goxpert.ru/2024/06/01/overall-questions/">Предыдущая статья: Общие вопросы</link>
        
      </yandex:related>
      
      
      <turbo:content><![CDATA[<p>Добрый день! Сегодня родился сайт GoXpert. </p><p>Для чего нужен этот сайт:</p><ul><li>Во-первых, для меня. Да, меня зовут Дмитрий Сигаев. Это сайт, на мой взгляд, поможет мне структурировать свои знания в разных областях, но в основном в экосистеме GO. Я много, что умею, но не могу в нужный для меня момент вынуть из своей головы нужной информации. Данный сайт — это так называемое хранилище моего опыта и якорей для быстрой настройки кратковременной памяти :) </li><li>Во-вторых, если это полезно для меня, то, на мой взгляд, найдется тот, кому это сайт тоже поможет в чем-то разобраться…</li><li>В-третьих, хочу выразить благодарность Сергею Артамонову. Спасибо за второй шанс и последствие в виде данного сайта. Надеюсь, быть его падаваном и соавтором публикаций на данном сайта.</li></ul><p>Ладно, не будем терять времени… поехали…</p><p>Let’s GO!</p><p><img src="/images/lets_go_with_goxpert.jpg" alt="С первым полетом!"></p><div id="aplayer-LMBIqxFh" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"><pre class="aplayer-lrc-content">Небо мой дом...</pre></div><script>var ap = new APlayer({element: document.getElementById("aplayer-LMBIqxFh"),narrow: false,autoplay: false,showlrc: 2,music: {title: "Лови Момент",author: "Machete",url: "/audio/MacheteTakeIt.mp3",pic: "",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><p><img src="/images/okko_2024_05.jpg" alt="Цель есть и она за окном... возможностей"></p> ]]></turbo:content>
      
     </item>
    
  </channel>
</rss>
