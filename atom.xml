<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GoXpert.ru</title>
  
  <subtitle>GoXpert.ru для тех, кто хочет стать экспертом в GO разработке</subtitle>
  <link href="https://goxpert.ru/atom.xml" rel="self"/>
  
  <link href="https://goxpert.ru/"/>
  <updated>2024-10-24T16:19:59.395Z</updated>
  <id>https://goxpert.ru/</id>
  
  <author>
    <name>авторы проекта GoXpert</name>
    
  </author>
  
  
  <entry>
    <title>Consumer Group Protocol</title>
    <link href="https://goxpert.ru/2024/10/21/kafka/consumer_group/"/>
    <id>https://goxpert.ru/2024/10/21/kafka/consumer_group/</id>
    <published>2024-10-21T07:10:00.000Z</published>
    <updated>2024-10-24T16:19:59.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Краткое-содержание-статьи"><a href="#Краткое-содержание-статьи" class="headerlink" title="Краткое содержание статьи"></a>Краткое содержание статьи</h2><p>Протокол группы потребителей: Масштабируемость и отказоустойчивость</p><ul><li>Кафка разделяет хранилище и вычисления между брокерами и потребителями.</li><li>Группы потребителей играют ключевую роль в эффективности и масштабируемости Kafka.</li><li>Группа потребителей определяется с помощью group.id в конфигурации потребителя.</li><li>Единицей параллелизма является разбиение, каждый пользователь может обрабатывать только один раздел.</li><li>Назначение разделов экземплярам группы потребителей происходит динамически и автоматически балансируется при изменении членства.</li><li>Координатор группы помогает равномерно распределять данные и поддерживает баланс при изменении членства в группе. </li><li>Запуск группы потребителей включает поиск координатора группы, присоединение участников и присвоение разделов.</li><li>Стратегии назначения разделов включают распределение диапазона, циклическое распределение и привязку разделов.</li><li>Отслеживание потребления разделов осуществляется с помощью CommitOffsetRequest и OffsetFetchRequest.</li><li>Восстановление баланса в группе потребителей может быть выполнено с помощью StickyAssignor, CooperativeStickyAssignor и статического членства в группе.</li></ul><h2 id="Протокол-группы-потребителей-Consumer-Group-Protocol"><a href="#Протокол-группы-потребителей-Consumer-Group-Protocol" class="headerlink" title="Протокол группы потребителей (Consumer Group Protocol)"></a>Протокол группы потребителей (Consumer Group Protocol)</h2><p>Kafka отделяет хранение данных от вычислений. Хранение данных осуществляется брокерами, а вычисления в основном осуществляются потребителями или фреймворками, созданными на основе потребителей (Kafka Streams, ksqlDB). Группы потребителей играют ключевую роль в эффективности и масштабируемости потребителей Kafka.</p><h3 id="Группа-потребителей-Kafka-Kafka-Consumer-Group"><a href="#Группа-потребителей-Kafka-Kafka-Consumer-Group" class="headerlink" title="Группа потребителей Kafka (Kafka Consumer Group)"></a>Группа потребителей Kafka (Kafka Consumer Group)</h3><p><img src="/images/Kafka_Internals_Group.png" alt="Группа потребителей Kafka"></p><p>Чтобы определить группу потребителей, нам нужно просто задать group.id в конфигурации потребителя. Как только это будет сделано, каждый новый экземпляр этого потребителя будет добавлен в группу. Затем, когда группа потребителей подписывается на одну или несколько тем, их разделы будут равномерно распределены между экземплярами в группе. Это позволяет выполнять параллельную обработку данных в этих темах.</p><p>Единицей параллелизма является раздел. Для заданной группы потребителей потребители могут обрабатывать более одного раздела, но раздел может обрабатываться только одним потребителем. Если наша группа подписана на две темы и каждая из них содержит два раздела, то мы можем эффективно использовать до четырёх потребителей в группе. Мы могли бы добавить пятого, но он будет простаивать, так как разделы нельзя использовать совместно.</p><p>Распределение разделов между экземплярами группы потребителей происходит динамически. По мере добавления потребителей в группу, а также при сбое или удалении потребителей из группы по какой-либо другой причине рабочая нагрузка автоматически перераспределяется.</p><h3 id="Координатор-группы-Group-Coordinator"><a href="#Координатор-группы-Group-Coordinator" class="headerlink" title="Координатор группы (Group Coordinator)"></a>Координатор группы (Group Coordinator)</h3><p><img src="/images/Kafka_Internals_Group_2.png" alt="Координатор группы kafka"></p><p>Волшебство, стоящее за группами потребителей, обеспечивается координатором группы. Координатор группы помогает равномерно распределять данные в подписных темах между экземплярами группы потребителей и поддерживает баланс при изменении состава группы. Координатор использует внутреннюю тему Kafka для отслеживания метаданных группы.</p><p>В типичном кластере Kafka будет несколько координаторов групп. Это позволяет эффективно управлять несколькими группами потребителей.</p><h3 id="Групповой-запуск-Group-Startup"><a href="#Групповой-запуск-Group-Startup" class="headerlink" title="Групповой запуск (Group Startup)"></a>Групповой запуск (Group Startup)</h3><p>Давайте рассмотрим этапы создания новой потребительской группы.</p><p>Шаг 1 – Найдите координатора группы</p><p><img src="/images/Kafka_Internals_Group_3.png" alt="Групповой запуск в kafka"></p><p>Когда экземпляр потребителя запускается, он отправляет запрос FindCoordinator, включающий group.id, любому брокеру в кластере. Брокер создаст хэш group.id и сравнит его с количеством разделов во внутренней теме __consumer_offsets. Это определяет раздел, в который будут записываться все события метаданных для этой группы. Брокер, на котором находится ведущая реплика для этого раздела, возьмёт на себя роль координатора группы для новой группы потребителей. Брокер, получивший запрос FindCoordinator, ответит конечной точкой координатора группы.</p><p>Шаг 2 – Участники присоединяются</p><p><img src="/images/Kafka_Internals_Group_4.png" alt="Участники присоединяются"></p><p>Затем потребители и координатор группы начинают небольшой логистический процесс, который начинается с того, что потребители отправляют запрос JoinGroup и передают информацию о подписке на тему. Координатор выбирает одного потребителя, обычно первого, отправившего запрос JoinGroup, в качестве лидера группы. Координатор возвращает memberId каждому потребителю, но также возвращает список всех участников и информацию о подписке лидеру группы. Это делается для того, чтобы лидер группы мог выполнить фактическое назначение разделов с помощью настраиваемой стратегии назначения разделов.</p><p>Шаг 3 – Назначение разделов</p><p><img src="/images/Kafka_Internals_Group_5.png" alt="Назначение разделов"></p><p>После того как лидер группы получит полный список участников и информацию о подписке, он воспользуется настроенным им разделителем, чтобы назначить разделы подписки участникам группы. После этого лидер отправит SyncGroupRequest координатору, передав свой идентификатор участника и назначения разделов, предоставленные разделителем. Другие участники отправят аналогичный запрос, но передадут только свой идентификатор участника. Координатор воспользуется информацией о назначениях, предоставленной лидером группы, чтобы вернуть фактические назначения каждому участнику. Теперь потребители могут приступить к реальной работе по потреблению и обработке данных.</p><h3 id="Стратегия-назначения-разделов-диапазона-Range-Partition-Assignment-Strategy"><a href="#Стратегия-назначения-разделов-диапазона-Range-Partition-Assignment-Strategy" class="headerlink" title="Стратегия назначения разделов диапазона (Range Partition Assignment Strategy)"></a>Стратегия назначения разделов диапазона (Range Partition Assignment Strategy)</h3><p><img src="/images/Kafka_Internals_Group_6.png" alt="Range Partition Assignment Strategy"></p><p>Теперь давайте рассмотрим некоторые доступные стратегии назначения. Начнём со стратегии назначения по диапазону. Эта стратегия просматривает каждую тему в подписке и назначает каждую из секций потребителю, начиная с первого потребителя. Это означает, что первая секция каждой темы будет назначена первому потребителю, вторая секция каждой темы будет назначена второму потребителю и так далее. Если ни одна тема в подписке не содержит столько секций, сколько есть потребителей, то некоторые потребители будут простаивать.</p><p>На первый взгляд это может показаться не очень хорошей стратегией, но у неё есть особая цель. При объединении событий из нескольких тем события должны считываться одним и тем же потребителем. Если события в двух разных темах используют один и тот же ключ, они будут находиться в одном и том же разделе соответствующих тем, а с помощью диапазона разделов они будут назначены одному и тому же потребителю.</p><h3 id="Стратегии-циклического-перебора-и-фиксированного-назначения-разделов-Round-Robin-and-Sticky-Partition-Assignment-Strategies"><a href="#Стратегии-циклического-перебора-и-фиксированного-назначения-разделов-Round-Robin-and-Sticky-Partition-Assignment-Strategies" class="headerlink" title="Стратегии циклического перебора и фиксированного назначения разделов (Round Robin and Sticky Partition Assignment Strategies)"></a>Стратегии циклического перебора и фиксированного назначения разделов (Round Robin and Sticky Partition Assignment Strategies)</h3><p><img src="/images/Kafka_Internals_Group_7.png" alt="Round Robin and Sticky Partition Assignment Strategies"></p><p>Далее рассмотрим стратегию «Круговой перекрёсток». При использовании этой стратегии все разделы подписки, независимо от темы, будут равномерно распределены между доступными потребителями. Это приводит к меньшему количеству простаивающих экземпляров потребителей и более высокой степени параллелизма.</p><p>Вариант стратегии «Круговой перекрёстный опрос», называемый стратегией «Прилипчивый раздел», работает по тому же принципу, но прилагает максимум усилий, чтобы придерживаться предыдущего распределения во время перебалансировки. Это обеспечивает более быструю и эффективную перебалансировку.</p><h3 id="Отслеживание-потребления-разделов-Tracking-Partition-Consumption"><a href="#Отслеживание-потребления-разделов-Tracking-Partition-Consumption" class="headerlink" title="Отслеживание потребления разделов (Tracking Partition Consumption)"></a>Отслеживание потребления разделов (Tracking Partition Consumption)</h3><p><img src="/images/Kafka_Internals_Group_8.png" alt="Tracking Partition Consumption"></p><p>В Kafka отслеживать прогресс потребителя относительно просто. Каждому потребителю всегда назначается один раздел, и события в этом разделе всегда считываются потребителем в порядке смещения. Таким образом, потребителю нужно только отслеживать последнее смещение, которое он прочитал для каждого раздела. Для этого потребитель отправляет CommitOffsetRequest координатору группы. Затем координатор сохраняет эту информацию во внутренней теме __consumer_offsets.</p><h3 id="Определение-начального-смещения-для-потребления-Determining-Starting-Offset-to-Consume"><a href="#Определение-начального-смещения-для-потребления-Determining-Starting-Offset-to-Consume" class="headerlink" title="Определение начального смещения для потребления (Determining Starting Offset to Consume)"></a>Определение начального смещения для потребления (Determining Starting Offset to Consume)</h3><p><img src="/images/Kafka_Internals_Group_9.png" alt="Determining Starting Offset to Consume"></p><p>При перезапуске экземпляра группы потребителей он отправит запрос на получение смещения координатору группы, чтобы получить последнее зафиксированное смещение для назначенного ему раздела. Получив смещение, он возобновит потребление с этой точки. Если этот экземпляр потребителя запускается впервые и для этой группы потребителей не сохранено смещение, то конфигурация auto.offset.reset определит, с какого смещения он начнет потребление: с самого раннего или с самого позднего.</p><h3 id="Отказоустойчивость-координатора-группы-Group-Coordinator-Failover"><a href="#Отказоустойчивость-координатора-группы-Group-Coordinator-Failover" class="headerlink" title="Отказоустойчивость координатора группы (Group Coordinator Failover)"></a>Отказоустойчивость координатора группы (Group Coordinator Failover)</h3><p><img src="/images/Kafka_Internals_Group_10.png" alt="Group Coordinator Failover"></p><p>Внутренняя тема __consumer_offsets реплицируется, как и любая другая тема Kafka. Кроме того, помните, что координатор группы — это брокер, на котором размещена ведущая реплика раздела __consumer_offsets, назначенного этой группе. Поэтому, если координатор группы выйдет из строя, новым координатором группы станет брокер, на котором размещена одна из ведомых реплик этого раздела. Потребители будут уведомлены о новом координаторе, когда попытаются выполнить вызов к старому, и затем всё продолжится как обычно.</p><h3 id="Триггеры-перебалансировки-группы-потребителей-Consumer-Group-Rebalance-Triggers"><a href="#Триггеры-перебалансировки-группы-потребителей-Consumer-Group-Rebalance-Triggers" class="headerlink" title="Триггеры перебалансировки группы потребителей (Consumer Group Rebalance Triggers)"></a>Триггеры перебалансировки группы потребителей (Consumer Group Rebalance Triggers)</h3><p><img src="/images/Kafka_Internals_Group_11.png" alt="Group Coordinator Failover"></p><p>Одной из ключевых особенностей потребительских групп является перераспределение. Мы подробнее обсудим перераспределение, но сначала давайте рассмотрим некоторые события, которые могут привести к перераспределению:</p><ul><li>Экземпляр не отправляет сигнал о состоянии координатору до истечения времени ожидания и удаляется из группы</li><li>В группу добавлен экземпляр</li><li>Разделы добавлены в тему подписки группы</li><li>У группы есть подписка с шаблоном, и создается новая соответствующая тема</li><li>И, конечно же, первоначальный запуск группы<br>Далее мы рассмотрим, что происходит при перебалансировке.</li></ul><h3 id="Уведомление-о-перебалансировке-группы-потребителей-Consumer-Group-Rebalance-Notification"><a href="#Уведомление-о-перебалансировке-группы-потребителей-Consumer-Group-Rebalance-Notification" class="headerlink" title="Уведомление о перебалансировке группы потребителей (Consumer Group Rebalance Notification)"></a>Уведомление о перебалансировке группы потребителей (Consumer Group Rebalance Notification)</h3><p><img src="/images/Kafka_Internals_Group_12.png" alt="Consumer Group Rebalance Notification"></p><p>Процесс балансировки начинается с того, что координатор уведомляет экземпляры потребителей о начале балансировки. Он делает это, используя HeartbeatResponse или OffsetFetchResponse. А теперь начинается самое интересное!</p><h3 id="Перебалансировка-по-принципу-“Останови-мир”-Stop-the-World-Rebalance"><a href="#Перебалансировка-по-принципу-“Останови-мир”-Stop-the-World-Rebalance" class="headerlink" title="Перебалансировка по принципу “Останови мир” (Stop-the-World Rebalance)"></a>Перебалансировка по принципу “Останови мир” (Stop-the-World Rebalance)</h3><p><img src="/images/Kafka_Internals_Group_13.png" alt="Stop-the-World Rebalance"></p><p>Традиционный процесс балансировки довольно сложен. Как только потребители получат уведомление о балансировке от координатора, они отменят свои текущие назначения разделов. Если они поддерживали какое-либо состояние, связанное с данными в ранее назначенных разделах, им также придется его очистить. Теперь они, по сути, являются новыми потребителями и пройдут те же этапы, что и новый потребитель, присоединяющийся к группе.</p><p>Они отправят координатору запрос на присоединение к группе, а затем запрос на синхронизацию группы. Координатор ответит соответствующим образом, и у каждого потребителя появятся новые задачи.</p><p>Любое состояние, необходимое потребителю, теперь придётся восстанавливать по данным из вновь назначенных разделов. Этот процесс, хоть и эффективен, имеет некоторые недостатки. Давайте рассмотрим некоторые из них.</p><h3 id="Проблема-№-1-“Останови-мир”-состояние-восстановления-Stop-the-World-Problem-1-–-Rebuilding-State"><a href="#Проблема-№-1-“Останови-мир”-состояние-восстановления-Stop-the-World-Problem-1-–-Rebuilding-State" class="headerlink" title="Проблема № 1 “Останови мир” - состояние восстановления (Stop-the-World Problem #1 – Rebuilding State)"></a>Проблема № 1 “Останови мир” - состояние восстановления (Stop-the-World Problem #1 – Rebuilding State)</h3><p><img src="/images/Kafka_Internals_Group_14.png" alt="Stop-the-World Problem #1 – Rebuilding State"></p><p>Первая проблема заключается в необходимости восстановления состояния. Если приложение-потребитель поддерживало состояние на основе событий в разделе, к которому оно было подключено, ему может потребоваться прочитать все события в разделе, чтобы восстановить это состояние после завершения балансировки. Как видно из нашего примера, иногда эта работа выполняется даже тогда, когда она не нужна. Если потребитель отменяет подключение к определённому разделу, а затем подключается к тому же разделу во время балансировки, может возникнуть значительная избыточная обработка.</p><h3 id="Проблема-№-2-“Останови-мир”-приостановленная-обработка-Stop-the-World-Problem-2-–-Paused-Processing"><a href="#Проблема-№-2-“Останови-мир”-приостановленная-обработка-Stop-the-World-Problem-2-–-Paused-Processing" class="headerlink" title="Проблема № 2 “Останови мир” - приостановленная обработка (Stop-the-World Problem #2 – Paused Processing)"></a>Проблема № 2 “Останови мир” - приостановленная обработка (Stop-the-World Problem #2 – Paused Processing)</h3><p><img src="/images/Kafka_Internals_Group_15.png" alt="Stop-the-World Problem #2 – Paused Processing"></p><p>Вторая проблема заключается в том, что нам нужно приостановить все процессы обработки во время перебалансировки, отсюда и название «Останови мир». Поскольку назначения разделов для всех потребителей отменяются в начале процесса, ничего не может произойти, пока процесс не завершится и разделы не будут переназначены. Во многих случаях, как в нашем примере, некоторые потребители сохранят некоторые из тех же разделов и теоретически могли бы продолжать работать с ними во время перебалансировки.</p><p>Давайте рассмотрим некоторые улучшения, которые были внесены для решения этих проблем.</p><h3 id="Избегайте-ненужного-восстановления-состояния-с-помощью-StickyAssignor-Avoid-Needless-State-Rebuild-with-StickyAssignor"><a href="#Избегайте-ненужного-восстановления-состояния-с-помощью-StickyAssignor-Avoid-Needless-State-Rebuild-with-StickyAssignor" class="headerlink" title="Избегайте ненужного восстановления состояния с помощью StickyAssignor (Avoid Needless State Rebuild with StickyAssignor)"></a>Избегайте ненужного восстановления состояния с помощью StickyAssignor (Avoid Needless State Rebuild with StickyAssignor)</h3><p><img src="/images/Kafka_Internals_Group_16.png" alt="Avoid Needless State Rebuild with StickyAssignor"></p><p>Во-первых, используя новый StickyAssignor, мы можем избежать ненужной повторной настройки состояния. Основное отличие StickyAssignor в том, что очистка состояния переносится на более поздний этап, после завершения переназначения. Таким образом, если потребителю переназначается тот же раздел, он может просто продолжить работу, не очищая и не восстанавливая состояние. В нашем примере состояние нужно будет восстановить только для раздела p2, который назначается новому потребителю.</p><h3 id="Избегайте-пауз-с-помощью-CooperativeStickyAssignor-Шаг-1-Avoid-Pause-with-CooperativeStickyAssignor-Step-1"><a href="#Избегайте-пауз-с-помощью-CooperativeStickyAssignor-Шаг-1-Avoid-Pause-with-CooperativeStickyAssignor-Step-1" class="headerlink" title="Избегайте пауз с помощью CooperativeStickyAssignor Шаг 1 (Avoid Pause with CooperativeStickyAssignor Step 1)"></a>Избегайте пауз с помощью CooperativeStickyAssignor Шаг 1 (Avoid Pause with CooperativeStickyAssignor Step 1)</h3><p><img src="/images/Kafka_Internals_Group_17.png" alt="Avoid Pause with CooperativeStickyAssignor Step 1"></p><p>Чтобы решить проблему приостановки обработки, мы внедрили CooperativeStickyAssignor. Этот распределитель работает в два этапа. На первом этапе определяется, какие назначения разделов необходимо отменить. Эти назначения отменяются в конце первого этапа балансировки. Разделы, которые не были отменены, могут продолжать обрабатываться.</p><p>Избегайте пауз с помощью CooperativeStickyAssignor Шаг 2 (Avoid Pause with CooperativeStickyAssignor Step 2)</p><p><img src="/images/Kafka_Internals_Group_18.png" alt="Avoid Pause with CooperativeStickyAssignor Step 2"></p><p>На втором этапе перебалансировки будут назначены отозванные разделы. В нашем примере был отозван только раздел 2, и он был назначен новому потребителю 3. В более сложной системе все потребители могут получить новые разделы, но факт остаётся фактом: разделы, которые не нужно было перемещать, могут продолжать обрабатываться без остановки системы.</p><h3 id="Избегайте-перебалансировки-при-статическом-членстве-в-группе-Avoid-Rebalance-with-Static-Group-Membership"><a href="#Избегайте-перебалансировки-при-статическом-членстве-в-группе-Avoid-Rebalance-with-Static-Group-Membership" class="headerlink" title="Избегайте перебалансировки при статическом членстве в группе (Avoid Rebalance with Static Group Membership)"></a>Избегайте перебалансировки при статическом членстве в группе (Avoid Rebalance with Static Group Membership)</h3><p><img src="/images/Kafka_Internals_Group_19.png" alt="Avoid Rebalance with Static Group Membership"></p><p>Как говорится, самая быстрая ребалансировка — это та, которая не происходит. В этом и заключается цель статического членства в группе. При статическом членстве в группе каждому экземпляру потребителя назначается group.instance.id. Кроме того, когда экземпляр потребителя корректно завершает работу, он не отправляет координатору запрос LeaveGroup, поэтому ребалансировка не запускается. Когда тот же экземпляр присоединяется к группе, координатор распознает его и позволит ему продолжить работу с существующими назначениями разделов. Опять же, ребалансировка не требуется.</p><p>Аналогичным образом, если экземпляр потребителя выйдет из строя, но будет перезапущен до истечения интервала ожидания, он сможет продолжить выполнение существующих задач.</p>]]></content>
    
    
    <summary type="html">Протокол группы потребителей. Масштабируемость и отказоустойчивость</summary>
    
    
    
    <category term="Kafka" scheme="https://goxpert.ru/categories/Kafka/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Kafka/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Consumer Group" scheme="https://goxpert.ru/categories/Kafka/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Consumer-Group/"/>
    
    
    <category term="Kafka, Consumer Group" scheme="https://goxpert.ru/tags/Kafka-Consumer-Group/"/>
    
  </entry>
  
  <entry>
    <title>Планировщик ОS</title>
    <link href="https://goxpert.ru/2024/06/02/os/os_scheduler/"/>
    <id>https://goxpert.ru/2024/06/02/os/os_scheduler/</id>
    <published>2024-06-02T15:32:20.263Z</published>
    <updated>2024-06-04T12:57:36.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Планировщик-операционной-системы"><a href="#Планировщик-операционной-системы" class="headerlink" title="Планировщик операционной системы"></a>Планировщик операционной системы</h1><p>Краткий пересказ <a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">перевода</a>:</p><ul><li>Многопоточность в программировании требует учета различных факторов, таких как переключение контекста и планирование работы. </li><li>Переключение контекста может снизить производительность, особенно при работе с привязкой к процессору. </li><li>Ограничение минимального временного интервала помогает сбалансировать количество потоков и производительность. </li><li>Пулы потоков могут быть полезны для управления количеством потоков и достижения наилучшей пропускной способности приложения. </li><li>Системы кэширования играют важную роль в производительности многопоточных приложений, и необходимо учитывать их механику. </li><li>При написании многопоточных приложений необходимо учитывать системы кэширования и принимать решения о планировании. </li></ul><h1 id="Введение"><a href="#Введение" class="headerlink" title="Введение"></a>Введение</h1><p>Дизайн и поведение планировщика Go позволяет вашим многопоточным программам Go быть более эффективными. Это происходит благодаря механическим симпатиям планировщика Go к планировщику операционной системы (OS). Однако, если дизайн и поведение вашего многопоточного программного обеспечения Go механически не соответствуют тому, как работают планировщики, ничто из этого не будет иметь значения. Важно иметь общее представление о том, как работают планировщики операционной системы и Go, чтобы правильно спроектировать ваше многопоточное программное обеспечение.</p><p>Эта статья, состоящая из нескольких частей, будет посвящена высокоуровневой механике и семантике планировщиков. Я предоставлю достаточно подробностей, чтобы вы могли наглядно представить, как все работает, и принимать более эффективные инженерные решения. Несмотря на то, что многое зависит от инженерных решений, которые вам необходимо принять для многопоточных приложений, механика и семантика составляют важнейшую часть необходимых вам базовых знаний.</p><h1 id="Планировщик-операционной-системы-1"><a href="#Планировщик-операционной-системы-1" class="headerlink" title="Планировщик операционной системы"></a>Планировщик операционной системы</h1><p>Планировщики операционной системы - это сложные программные продукты. Они должны учитывать компоновку и настройку оборудования, на котором они работают. Это включает, но не ограничивается наличием нескольких процессоров и ядер, кэшей процессора и NUMA. Без этих знаний планировщик не может быть максимально эффективным. Замечательно то, что вы все еще можете разработать хорошую мысленную модель того, как работает планировщик операционной системы, не углубляясь в эти темы.</p><p>Ваша программа - это просто серия машинных инструкций, которые необходимо выполнять последовательно одну за другой. Чтобы это произошло, операционная система использует концепцию потока. Задача Потока состоит в том, чтобы учитывать и последовательно выполнять набор назначенных ему инструкций. Выполнение продолжается до тех пор, пока у потока больше не останется инструкций для выполнения. Вот почему я называю поток “путем выполнения”.</p><p>Каждая запускаемая вами программа создает процесс, и каждому процессу присваивается начальный поток. Потоки имеют возможность создавать новые потоки. Все эти разные потоки выполняются независимо друг от друга, и решения о планировании принимаются на уровне потока, а не на уровне процесса. Потоки могут выполняться одновременно (каждый по очереди на отдельном ядре) или параллельно (каждый выполняется одновременно на разных ядрах). Потоки также поддерживают свое собственное состояние, чтобы обеспечить безопасное, локальное и независимое выполнение своих инструкций.</p><p>Планировщик операционной системы отвечает за то, чтобы ядра не простаивали, если есть потоки, которые могут выполняться. Он также должен создавать иллюзию, что все потоки, которые могут выполняться, выполняются одновременно. В процессе создания этой иллюзии планировщику необходимо запускать потоки с более высоким приоритетом по сравнению с потоками с более низким приоритетом. Однако потоки с более низким приоритетом нельзя ограничивать во времени выполнения. Планировщику также необходимо максимально минимизировать задержки при планировании, принимая быстрые и разумные решения.</p><p>Для этого многое зависит от алгоритмов, но, к счастью, отрасль может использовать десятилетия работы и опыта. Чтобы лучше понять все это, полезно описать и определить несколько важных концепций.</p><h1 id="Выполнение-инструкций"><a href="#Выполнение-инструкций" class="headerlink" title="Выполнение инструкций"></a>Выполнение инструкций</h1><p>Счетчик программ (PC), который иногда называют указателем команд (IP), - это то, что позволяет потоку отслеживать следующую команду для выполнения. В большинстве процессоров ПК указывает на следующую инструкцию, а не на текущую.</p><p><img src="/images/os_sched_1.jpg" alt="Рисунок 1"></p><p>Если вы когда-либо видели трассировку стека в программе Go, вы могли заметить эти маленькие шестнадцатеричные числа в конце каждой строки. Ищите +0x39 и +0x72 в листинге 1.</p><h3 id="Листинг-1"><a href="#Листинг-1" class="headerlink" title="Листинг 1"></a>Листинг 1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goroutine 1 [running]:</span><br><span class="line">   main.example(0xc000042748, 0x2, 0x4, 0x106abae, 0x5, 0xa)</span><br><span class="line">       stack_trace/example1/example1.go:13 +0x39                 &lt;- LOOK HERE</span><br><span class="line">   main.main()</span><br><span class="line">       stack_trace/example1/example1.go:8 +0x72                  &lt;- LOOK HERE</span><br></pre></td></tr></table></figure><p>Эти числа представляют смещение значения PC от вершины соответствующей функции. Значение +0x39 смещения PC представляет следующую инструкцию, которую поток выполнил бы внутри example функции, если бы программа не запаниковала. Значение 0+x72 смещения ПК - это следующая команда внутри main функции, если управление возвращалось к этой функции. Что более важно, команда, предшествующая этому указателю, сообщает вам, какая команда выполнялась.</p><p>Посмотрите на программу ниже в листинге 2, которая вызвала трассировку стека из листинга 1</p><h3 id="Листинг-2"><a href="#Листинг-2" class="headerlink" title="Листинг 2"></a>Листинг 2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/ardanlabs/gotraining/blob/master/topics/go/profiling/stack_trace/example1/example1.go</span><br><span class="line"></span><br><span class="line">07 func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">08     example(make([]string, 2, 4), <span class="string">&quot;hello&quot;</span>, 10)</span><br><span class="line">09 &#125;</span><br><span class="line"></span><br><span class="line">12 func example(slice []string, str string, i int) &#123;</span><br><span class="line">13    panic(<span class="string">&quot;Want stack trace&quot;</span>)</span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><p>Шестнадцатеричное число +0x39 представляет смещение ПК для инструкции внутри example функции, которое на 57 (базовые 10) байт ниже начальной инструкции для функции. В листинге 3 ниже вы можете увидеть objdump из example функции из двоичного файла. Найдите 12-ю инструкцию, которая указана внизу. Обратите внимание на строку кода выше, которая является вызовом этой инструкции panic.</p><h3 id="Листинг-3"><a href="#Листинг-3" class="headerlink" title="Листинг 3"></a>Листинг 3</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ go tool objdump -S -s <span class="string">&quot;main.example&quot;</span> ./example1</span><br><span class="line">TEXT main.example(SB) stack_trace/example1/example1.go</span><br><span class="line">func example(slice []string, str string, i int) &#123;</span><br><span class="line">  0x104dfa065488b0c2530000000MOVQ GS:0x30, CX</span><br><span class="line">  0x104dfa9483b6110CMPQ 0x10(CX), SP</span><br><span class="line">  0x104dfad762cJBE 0x104dfdb</span><br><span class="line">  0x104dfaf4883ec18SUBQ <span class="variable">$0x18</span>, SP</span><br><span class="line">  0x104dfb348896c2410MOVQ BP, 0x10(SP)</span><br><span class="line">  0x104dfb8488d6c2410LEAQ 0x10(SP), BP</span><br><span class="line">panic(<span class="string">&quot;Want stack trace&quot;</span>)</span><br><span class="line">  0x104dfbd488d059ca20000LEAQ runtime.types+41504(SB), AX</span><br><span class="line">  0x104dfc448890424MOVQ AX, 0(SP)</span><br><span class="line">  0x104dfc8488d05a1870200LEAQ main.statictmp_0(SB), AX</span><br><span class="line">  0x104dfcf4889442408MOVQ AX, 0x8(SP)</span><br><span class="line">  0x104dfd4e8c735fdffCALL runtime.gopanic(SB)</span><br><span class="line">  0x104dfd90f0bUD2              &lt;--- LOOK HERE PC(+0x39)</span><br></pre></td></tr></table></figure><p>Помните: ПК - это следующая инструкция, а не текущая. Листинг 3 - хороший пример инструкций на базе amd64, за последовательное выполнение которых отвечает поток для этой программы Go.</p><h2 id="Состояния-потоков-Thread-States"><a href="#Состояния-потоков-Thread-States" class="headerlink" title="Состояния потоков (Thread States)"></a>Состояния потоков (Thread States)</h2><p>Еще одной важной концепцией является состояние потока, которое определяет роль, которую планировщик выполняет в потоке. Поток может находиться в одном из трех состояний: Ожидающем(Waiting), Готовом к выполнению(Runnable) или Выполняющимся (Executing).</p><p>Ожидание(Waiting): это означает, что поток остановлен и ожидает чего-либо, чтобы продолжить. Это может быть по таким причинам, как ожидание аппаратного обеспечения (диск, сеть), операционной системы (системные вызовы) или вызовов синхронизации (атомарные, мьютексы). Эти типы задержек являются основной причиной низкой производительности.</p><p>Возможность выполнения (Готовность- Runnable): Это означает, что потоку требуется время на ядре, чтобы он мог выполнить назначенные ему машинные инструкции. Если у вас много потоков, которым требуется время, то потокам приходится ждать дольше, чтобы получить время. Кроме того, индивидуальный промежуток времени, который получает любой данный поток, сокращается, поскольку больше потоков конкурируют за время. Этот тип задержки планирования также может быть причиной низкой производительности.</p><p>Выполнение(Executing): Это означает, что поток помещен в ядро и выполняет свои машинные инструкции. Работа, связанная с приложением, выполняется. Это то, чего хотят все.</p><h2 id="Типы-работ-Types-Of-Work"><a href="#Типы-работ-Types-Of-Work" class="headerlink" title="Типы работ (Types Of Work)"></a>Типы работ (Types Of Work)</h2><p>Поток(Thread) может выполнять два типа работы. Первый называется привязанным к процессору(CPU-Bound), а второй - привязанным к вводу-выводу(IO-Bound).</p><p>Привязка к процессору(CPU-Bound): Это работа, которая никогда не создает ситуации, при которой поток может быть переведен в состояние ожидания. Это работа, при которой постоянно выполняются вычисления. Поток, вычисляющий число Пи(Pi=3.14…..N) до N-й цифры, будет привязан к процессору.</p><p>Привязка к вводу-выводу(IO-Bound): Это работа, которая переводит потоки в состояния ожидания(Waiting). Это работа, которая заключается в запросе доступа к ресурсу по сети или выполнении системных вызовов в операционной системе. Поток, которому требуется доступ к базе данных, будет привязан к вводу-выводу(IO-Bound). Я бы включил события синхронизации (мьютексы mutexes, атомарные atomic), которые заставляют поток ожидать, как часть этой категории.</p><h2 id="Переключение-контекста-Context-Switching"><a href="#Переключение-контекста-Context-Switching" class="headerlink" title="Переключение контекста (Context Switching)"></a>Переключение контекста (Context Switching)</h2><p>Если вы работаете в Linux, Mac или Windows, вы работаете в операционной системе с упреждающим планировщиком. Это означает несколько важных вещей.<br>Во-первых, это означает, что планировщик непредсказуем(unpredictable), когда дело доходит до того, какие потоки(Threads) будут выбраны для запуска в любой момент времени. Приоритеты потоков вместе с событиями events (например, получение данных по сети) делают невозможным определение того, что планировщик решит сделать и когда.</p><p>Во-вторых, это означает, что вы никогда не должны писать код, основанный на каком-то предполагаемом поведении, с которым вам посчастливилось столкнуться, но которое не гарантировано будет иметь место каждый раз. Легко позволить себе подумать, потому что я видел, как это происходило 1000 раз, это гарантированное поведение. Вы должны контролировать синхронизацию и оркестровку потоков, если вам нужен детерминизм в вашем приложении.</p><p>Физический акт замены потоков(swapping Threads) в ядре называется переключением контекста (context switch). Переключение контекста (context switch) происходит, когда планировщик отключает выполняющийся поток от ядра и заменяет его готовым к выполнению потоком(Runnable Thread). Поток, который был выбран из очереди запуска(the run queue), переходит в состояние выполнения(Executing). Извлеченный поток может вернуться в состояние, пригодное для выполнения (Runnable state) (если у него все еще есть возможность запуска), или в состояние ожидания (Waiting state) (если был заменен из-за запроса(request) типа, связанного с вводом-выводом of an IO-Bound type).</p><p>Переключение контекста считается дорогостоящим, поскольку требуется время для переключения потоков между ядром и из него. Величина задержки, возникающей при переключении контекста, зависит от различных факторов, но вполне разумно, чтобы это занимало от ~ 1000 до ~ 1500 наносекунд. Учитывая, что аппаратное обеспечение должно быть способно разумно выполнять (в среднем) 12 инструкций в наносекунду на ядро, переключение контекста может стоить вам от ~ 12 тыс. до ~ 18 тыс. команд с задержкой. По сути, ваша программа теряет способность выполнять большое количество инструкций во время переключения контекста.</p><p>Если у вас есть программа, ориентированная на работу с привязкой к вводу-выводу(IO-Bound work), то переключение контекста будет преимуществом. Как только поток переходит в состояние ожидания(Waiting state), другой поток в состоянии, пригодном для выполнения(Runnable state), занимает его место. Это позволяет ядру всегда выполнять работу. Это один из наиболее важных аспектов планирования. Не позволяйте ядру простаивать, если есть работа (потоки в готовом к выполнению состоянии Threads in a Runnable state), которую необходимо выполнить.</p><p>Если ваша программа ориентирована на работу с приязкой к ЦП (CPU-Bound work), то переключение контекста станет кошмаром производительности. Поскольку у Thead всегда есть работа, которую нужно выполнить, переключение контекста останавливает выполнение этой работы. Эта ситуация резко контрастирует с тем, что происходит с рабочей нагрузкой, связанной с вводом-выводом (IO-Bound workload)</p><h2 id="Чем-меньше-тем-лучше-Less-Is-More"><a href="#Чем-меньше-тем-лучше-Less-Is-More" class="headerlink" title="Чем меньше, тем лучше (Less Is More)"></a>Чем меньше, тем лучше (Less Is More)</h2><p>В первые дни, когда процессоры имели только одно ядро, планирование(scheduling) не было чрезмерно сложным. Поскольку у вас был один процессор с одним ядром, в любой момент времени мог выполняться только один поток. Идея заключалась в том, чтобы определить <strong>период планирования (scheduler period)</strong> и попытаться выполнить все доступные(готовые к выполнению) потоки(Runnable Threads) в течение этого периода времени. Нет проблем: возьмите период планирования и разделите его на количество потоков, которые необходимо выполнить.</p><p>В качестве примера, если вы определяете период планирования( scheduler period = 1s) равным 1000 мс (1 секунде) и у вас есть 10 потоков, то каждому потоку дается по 100 мс каждый. Если у вас есть 100 потоков, каждому потоку дается по 10 мс каждый. Однако, что происходит, когда у вас есть 1000 потоков? Выделение каждому потоку временного интервала в 1 мс не работает, потому что процент времени, которое вы тратите на переключение контекста, будет значительным по сравнению с количеством времени, которое вы тратите на работу приложения.</p><p>Что вам нужно, так это установить ограничение(limit) на то, насколько маленьким может быть данный временной отрезок. В последнем сценарии, если минимальный временной интервал составлял 10 мс и у вас было 1000 потоков, период планирования необходимо увеличить до 10000 мс (10 секунд). Что, если бы было 10 000 потоков, теперь вы смотрите на период планирования в 100000 мс (100 секунд). При 10 000 потоках с минимальным временным интервалом в 10 мс в этом простом примере для однократного запуска всех потоков требуется 100 секунд, если каждый поток использует свой полный временной интервал.</p><p>Имейте в виду, что это очень простой взгляд на мир. Есть еще много вещей, которые необходимо учитывать и обрабатывать планировщику при принятии решений о планировании (scheduling decisions). Вы контролируете количество потоков, используемых в вашем приложении. Когда требуется учитывать больше потоков и выполняется работа, связанная с вводом-выводом(IO-Bound work), возникает больше хаоса и недетерминированного поведения. На планирование и выполнение уходит больше времени.</p><p>Вот почему правило игры таково: “Чем меньше, тем лучше(Less is More дословно переводится кем меньше, тем больше, но это не правильно)”. Чем меньше потоков в состоянии готовым к выполненю (Runnable), тем меньше накладных расходов на планирование (scheduling overhead) и больше времени с течением времени получает каждый поток. Чем больше потоков находится в готовом к работе состоянии(Runnable state), тем меньше времени затрачивается на каждый поток с течением времени. Это означает, что со временем также выполняется меньшая часть вашей работы.</p><h2 id="Найдите-баланс-Find-The-Balance"><a href="#Найдите-баланс-Find-The-Balance" class="headerlink" title="Найдите баланс (Find The Balance)"></a>Найдите баланс (Find The Balance)</h2><p>Вам нужно найти баланс между количеством имеющихся у вас ядер и количеством потоков, необходимых для получения максимальной пропускной способности вашего приложения. Когда дело доходит до управления этим балансом, пулы потоков(Thread pools) были отличным решением. Во второй части я покажу вам, что в Go в этом больше нет необходимости. Я думаю, что это одна из приятных вещей, которые Go сделала для упрощения разработки многопоточных приложений.</p><p>До написания кода в Go я писал код на C ++ и C # в NT. В этой операционной системе использование пулов потоков <a href="https://en.wikipedia.org/wiki/Input/output_completion_port">IOCP</a> (<a href="https://habr.com/ru/articles/59282/">порты завершения</a> ввода-вывода - IO Completion Ports) было критически важным для написания многопоточного программного обеспечения. Как инженеру, вам нужно было выяснить, сколько пулов потоков вам нужно и максимальное количество потоков для любого данного пула, чтобы максимизировать пропускную способность при том количестве ядер, которое вам было предоставлено.</p><p>При написании веб-служб, взаимодействующих с базой данных, магическое количество потоков в 3 потока на ядро, казалось, всегда обеспечивало наилучшую пропускную способность на NT. Другими словами, 3 потока на ядро сводят к минимуму затраты на задержку при переключении контекста при максимальном увеличении времени выполнения на ядрах. При создании пула потоков IOCP я знал, что начинать нужно с минимум 1 потока и максимум с 3 потоков для каждого ядра, которое я определил на хост-машине.</p><p>Если бы я использовал 2 потока на ядро, выполнение всей работы заняло бы больше времени, потому что у меня было свободное время, когда я мог бы выполнить работу. Если я использовал 4 потока на ядро, это также занимало больше времени, потому что у меня была большая задержка при переключении контекста. Баланс в 3 потока на ядро, по какой-то причине, всегда казался магическим числом в NT.</p><p>Что, если ваша служба выполняет много разных типов работы? Это может привести к разным и непоследовательным задержкам. Возможно, это также создает множество различных событий системного уровня, которые необходимо обработать. Возможно, будет невозможно найти магическое число, которое работает постоянно при всех различных рабочих нагрузках. Когда дело доходит до использования пулов потоков для настройки производительности службы, найти правильную согласованную конфигурацию может быть очень сложно.</p><h2 id="Строки-кэша-Cache-Lines"><a href="#Строки-кэша-Cache-Lines" class="headerlink" title="Строки кэша (Cache Lines)"></a>Строки кэша (Cache Lines)</h2><p>Доступ к данным из основной памяти требует такой высокой задержки (от ~ 100 до ~ 300 тактов), что процессоры и ядра имеют локальные кэши для хранения данных рядом с аппаратными потоками, которым они нужны. Доступ к данным из кэшей обходится гораздо дешевле (от ~ 3 до ~ 40 тактов) в зависимости от того, к какому кэшу осуществляется доступ. Сегодня одним из аспектов производительности является то, насколько эффективно вы можете загружать данные в процессор, чтобы уменьшить задержки доступа к данным. При написании многопоточных приложений, изменяющих состояние, необходимо учитывать механику системы кэширования.</p><h3 id="Рисунок-2"><a href="#Рисунок-2" class="headerlink" title="Рисунок 2"></a>Рисунок 2</h3><p><img src="/images/os_sched_2.png" alt="Рисунок 2"></p><p>Обмен данными между процессором и основной памятью осуществляется с помощью <a href="https://www.youtube.com/watch?v=WDIkqP4JbkE">строк кэша</a>. Строка кэша - это 64-байтовый фрагмент памяти, которым обмениваются основная память и система кэширования. Каждому ядру предоставляется собственная копия любой необходимой ему строки кэша, что означает, что аппаратное обеспечение использует <a href="https://www.ardanlabs.com/blog/2017/06/design-philosophy-on-data-and-semantics.html">семантику значений</a>. Вот почему изменения в памяти в многопоточных приложениях могут привести к снижению производительности.</p><p>Когда несколько параллельно работающих потоков обращаются к одному и тому же значению данных или даже к значениям данных рядом друг с другом, они будут обращаться к данным в одной строке кэша. Любой поток, запущенный на любом ядре, получит свою собственную копию той же строки кэша.</p><h3 id="Рисунок-3"><a href="#Рисунок-3" class="headerlink" title="Рисунок 3"></a>Рисунок 3</h3><p><img src="/images/os_sched_3.png" alt="Рисунок 3"></p><p>Если один поток в данном ядре вносит изменения в свою копию строки кэша(cache line), то благодаря аппаратному обеспечению все остальные копии той же строки кэша должны быть помечены как “грязные”. Когда Поток пытается получить доступ на чтение или запись к грязной строке кэша, для получения новой копии строки кэша требуется доступ к основной памяти (от ~ 100 до ~ 300 тактов).</p><p>Возможно, на 2-ядерном процессоре это не имеет большого значения, но как насчет 32-ядерного процессора, выполняющего 32 параллельных потока, которые получают доступ к данным и изменяют их в одной строке кэша? Как насчет системы с двумя физическими процессорами по 16 ядер в каждом? Ситуация будет хуже из-за дополнительной задержки при передаче данных между процессорами. Приложение будет перегружать память, а производительность будет ужасной, и, скорее всего, вы не будете понимать, почему.</p><p>Это называется <a href="https://youtu.be/WDIkqP4JbkE">проблемой согласованности кэша cache-coherency problem</a> или <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B3%D0%B5%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%BA%D1%8D%D1%88%D0%B0">проблемой когерентности кэша</a>, а также приводит к таким проблемам, как ложный обмен данными. При написании многопоточных приложений, которые будут изменять общее состояние, необходимо учитывать системы кэширования.</p><h2 id="Сценарий-принятия-решения-о-планировании-Scheduling-Decision-Scenario"><a href="#Сценарий-принятия-решения-о-планировании-Scheduling-Decision-Scenario" class="headerlink" title="Сценарий принятия решения о планировании (Scheduling Decision Scenario)"></a>Сценарий принятия решения о планировании (Scheduling Decision Scenario)</h2><p>Представьте, что я попросил вас написать планировщик операционной системы на основе предоставленной мной высокоуровневой информации. Подумайте об одном сценарии, который вам нужно рассмотреть. Помните, это одна из многих интересных вещей, которые планировщик должен учитывать при принятии решения о планировании.</p><p>Вы запускаете свое приложение, и основной поток создается и выполняется на ядре 1. Когда поток начинает выполнять свои инструкции, извлекаются строки кэша, поскольку требуются данные. Теперь поток решает создать новый поток для некоторой параллельной обработки. Вот в чем вопрос.</p><p>Как только поток создан и готов к запуску, следует ли планировщику:</p><ol><li>Контекстное отключение основного потока(main Thread)  ядра 1? Это может повысить производительность, поскольку вероятность того, что этому новому потоку понадобятся те же данные, которые уже находятся в кэше, довольно высока. Но основной поток не получает своего полного временного интервала.</li><li>Должен ли (дочерний <strong>дополнение от</strong> <a href="https://goxpert.ru/2024/06/01/helloworld/index.html">меня</a>) поток ожидать, пока ядро 1 станет доступным, в ожидании завершения временного интервала основного потока? Поток не запущен, но задержка при выборке данных будет устранена после его запуска.</li><li>Должен ли поток ожидать следующего доступного ядра? Это означало бы, что строки кэша для выбранного ядра будут очищаться, извлекаться и дублироваться, вызывая задержку. Однако поток будет запускаться быстрее, и основной поток сможет завершить свой временной отрезок.</li></ol><p>Уже развлекаетесь? Это интересные вопросы, которые планировщик операционной системы должен учитывать при принятии решений о планировании. К счастью для всех, их задаю не я. Все, что я могу вам сказать, это то, что, если есть незанятое ядро, оно будет использоваться. Вы хотите, чтобы потоки запускались, когда они могут быть запущены.</p><p>Решение от автора <a href="https://goxpert.ru/2024/06/01/helloworld/index.html">сайта</a> оставить одно ядро незанятым, в то время как другие потоки выполняются</p><h2 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h2><p>В этой первой части поста рассказывается о том, что вы должны учитывать в отношении потоков и планировщика операционной системы при написании многопоточных приложений. Это то, что также учитывает планировщик Go. В следующем посте я опишу семантику планировщика Go и то, как они связаны с этой информацией. Затем, наконец, вы увидите все это в действии, запустив пару программ.</p>]]></content>
    
    
    <summary type="html">Как устроен планировкщик ОS</summary>
    
    
    
    <category term="ОС" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/"/>
    
    <category term="Планировщик ОS" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA-%D0%9ES/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Планировщик GO</title>
    <link href="https://goxpert.ru/2024/06/01/concurrency/go_scheduler/"/>
    <id>https://goxpert.ru/2024/06/01/concurrency/go_scheduler/</id>
    <published>2024-06-01T09:35:00.000Z</published>
    <updated>2024-06-05T12:52:32.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Планирование-в-Go-Часть-II-Go-Scheduler"><a href="#Планирование-в-Go-Часть-II-Go-Scheduler" class="headerlink" title="Планирование в Go : Часть II - Go Scheduler"></a>Планирование в Go : Часть II - Go Scheduler</h1><p>О чем будем говорить: <a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">перевод статьи</a></p><p>Перевод сделан <a href="/2024/06/01/helloworld/index.html">автором сайта goxpert.ru</a></p><ul><li>Go использует планировщик для управления выполнением программ и распределением ресурсов. </li><li>Планировщик учитывает тонкости работы операционной системы и аппаратного обеспечения. </li><li>Go-планировщик позволяет превратить работу с вводом-выводом/блокировкой в работу, связанную с процессором. </li><li>Использование Goroutines позволяет выполнять больше работы с течением времени, используя меньше потоков операционной системы. </li><li>Планировщик Go помогает повысить эффективность работы с кэш-памятью и NUMA. </li><li>Разработчикам важно понимать семантику Go-планировщика для принятия эффективных инженерных решений.</li></ul><h1 id="Введение"><a href="#Введение" class="headerlink" title="Введение"></a>Введение</h1><p>В первой части этой серии о планировании я объяснил аспекты планировщика операционной системы, которые, на мой взгляд, важны для понимания и оценки семантики Go scheduler. В этом посте я объясню на семантическом уровне, как работает Go scheduler, и сосредоточусь на поведении высокого уровня. Go scheduler - сложная система, и мелкие механические детали не важны. Важно иметь хорошую модель того, как все работает и как себя вести. Это позволит вам принимать более эффективные инженерные решения.</p><h3 id="Запуск-вашей-программы"><a href="#Запуск-вашей-программы" class="headerlink" title="Запуск вашей программы"></a>Запуск вашей программы</h3><p>Когда ваша программа Go запускается, ей присваивается логический процессор (P) для каждого виртуального ядра, которое идентифицировано на хост-компьютере. Если у вас процессор с несколькими аппаратными потоками на физическое ядро (<a href="https://en.wikipedia.org/wiki/Hyper-threading">Гиперпоточность</a>), каждый аппаратный поток будет представлен вашей программе Go как виртуальное ядро. Чтобы лучше понять это, взгляните на системный отчет для моего MacBook Pro.</p><p><img src="/images/go_sched1.png" alt="Рисунок 1"></p><p>Вы можете видеть, что у меня один процессор с 4 физическими ядрами. Чего в этом отчете нет, так это количества аппаратных потоков, приходящихся на одно физическое ядро. Процессор Intel Core i7 поддерживает технологию Hyper-Threading, что означает наличие 2 аппаратных потоков на каждое физическое ядро. Программа Go сообщит, что 8 виртуальных ядер доступны для параллельного выполнения потоков операционной системы.</p><p>Чтобы протестировать это, рассмотрим следующую программу:</p><h3 id="Листинг-1"><a href="#Листинг-1" class="headerlink" title="Листинг 1"></a>Листинг 1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// NumCPU returns the number of logical</span></span><br><span class="line">    <span class="comment">// CPUs usable by the current process.</span></span><br><span class="line">    fmt.Println(runtime.NumCPU())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Когда я запускаю эту программу на своем локальном компьютере, результатом вызова функции NumCPU() будет значение 8. Любой программе Go, которую я запускаю на своем компьютере, будет присвоено 8 баллов.</p><p>Каждому P назначается поток операционной системы (“M”). ‘M’ означает machine. Этот поток по-прежнему управляется операционной системой, и операционная система по-прежнему отвечает за размещение потока в ядре для выполнения, как описано в <a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">последнем сообщении</a>. Это означает, что когда я запускаю программу Go на своем компьютере, у меня есть 8 потоков, доступных для выполнения моей работы, каждый из которых по отдельности подключен к P.</p><p>Каждой программе Go также задается начальная подпрограмма(назовем ее  initial Goroutine или началная горутина) (“G”), которая является путем выполнения программы Go. Goroutine по сути является <a href="https://en.wikipedia.org/wiki/Coroutine">сопрограммой - корутиной</a>, но это Go, поэтому мы заменяем букву “C“ на “G” и получаем слово Goroutine. Вы можете рассматривать Goroutines как потоки уровня приложения, и они во многом похожи на потоки операционной системы. Точно так же, как потоки операционной системы включаются и выключаются из контекста в ядре, рабочие программы включаются и выключаются из контекста в M.</p><p>Последняя часть головоломки - это очереди запуска. В планировщике Go есть две разные очереди запуска: глобальная очередь запуска (GRQ) и локальная очередь запуска (LRQ). Каждому P присваивается LRQ, который управляет программами, назначенными для выполнения в контексте P. Эти программы по очереди включаются и выключаются в зависимости от контекста. M, назначенный для этого P. GRQ предназначен для программ, которым еще не назначен P. Существует процесс перемещения Goroutines из GRQ в LRQ, который мы обсудим позже.</p><p>На рисунке 2 представлено изображение всех этих компонентов вместе.<br><img src="/images/golang_scheduler2.png" alt="Рисунок2 "></p><h2 id="Сотрудничающий-планировщик-Cooperating-Scheduler"><a href="#Сотрудничающий-планировщик-Cooperating-Scheduler" class="headerlink" title="Сотрудничающий планировщик (Cooperating Scheduler)"></a>Сотрудничающий планировщик (Cooperating Scheduler)</h2><p>Как мы обсуждали в первом посте, планировщик операционной системы(OS scheduler) является упреждающим планировщиком(preemptive scheduler). По сути, это означает, что вы не можете предсказать, что планировщик собирается делать в любой момент времени. Решения принимает ядро, и все недетерминировано. Приложения, работающие поверх ОС, не имеют никакого контроля над тем, что происходит внутри ядра с помощью планирования, если только они не используют примитивы синхронизации, такие как атомарные инструкции и мьютексные вызовы. Другими словами, можно сделать в вытесняющем режиме, что-то запланированное только при помощи примитивов синхронизации (атомики, мьютексы, <a href="https://habr.com/ru/articles/261273/">семафоры(кстати, хорошая статья для с++ шников)</a>, вайтгрупы и т.д)</p><p>Планировщик Go является частью среды выполнения Go, а среда выполнения Go встроена в ваше приложение. Это означает, что планировщик Go выполняется в <a href="https://en.wikipedia.org/wiki/User_space">пространстве пользователя</a>, над ядром. Текущая реализация Go scheduler - это не упреждающий планировщик(preemptive scheduler вытесняющий планировщик), а <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">сотрудничающий(кооперативный)</a> планировщик. Наличие сотрудничающего планировщика означает, что планировщику нужны четко определенные события пользовательского пространства, которые происходят в безопасных точках кода для принятия решений о планировании.</p><p>Что замечательного в совместном планировщике Go, так это то, что он выглядит и ощущается упреждающим(feels preemptive - похож на вытесняющий). Вы не можете предсказать, что будет делать планировщик Go. Это связано с тем, что принятие решений для этого взаимодействующего планировщика находится не в руках разработчиков, а в среде выполнения Go(runtime packege). Важно рассматривать Go scheduler как планировщик с вытеснением, а поскольку планировщик недетерминирован( non-deterministic), это не является большой натяжкой.</p><h2 id="Состояния-Горутин-Goroutine-States"><a href="#Состояния-Горутин-Goroutine-States" class="headerlink" title="Состояния Горутин (Goroutine States)"></a>Состояния Горутин (Goroutine States)</h2><p>Точно так же, как потоки, горутины имеют те же три состояния высокого уровня. Они определяют роль, которую планировщик Go выполняет в любой заданной горутины. Горутина может находиться в одном из трех состояний: Ожидание(Goroutine States), Возможность выполнения или Готовность к выполнению(Runnable) или Выполнение(Executing).</p><p><strong>Ожидание(Waiting)</strong>: Это означает, что горутина остановлена и ожидает чего-либо, чтобы продолжить. Это может быть по таким причинам, как ожидание операционной системы (системные вызовы system calls или syscall) или вызовы синхронизации(synchronization calls или synccall) (атомарные операции - atomi и мьютексы mutex). Эти типы <a href="https://en.wikipedia.org/wiki/Latency_(engineering)">задержек(latencies)</a> являются основной причиной низкой производительности.</p><p><strong>Готовность к выполнению (Runnable)</strong>: Это означает, что горутине требуется время на M, чтобы она могла выполнить назначенные инструкции. Если у вас много рабочих горутин, которым нужно время, то им придется ждать дольше, чтобы получить время для выполнеия. Кроме того, индивидуальный промежуток времени, который получает любая конкретная горутина, сокращается по мере того, как все больше горутин соревнуются(compete) за время. Этот тип задержки планирования(scheduling latency) также может быть причиной низкой производительности( bad performance).</p><p><strong>Выполнение(Executing)</strong>: Это означает, что горутина была помещена в M и выполняет свои инструкции. Работа, связанная с приложением, выполняется. Это то, чего хотят все.</p><h2 id="Переключение-контекста-Context-Switching"><a href="#Переключение-контекста-Context-Switching" class="headerlink" title="Переключение контекста (Context Switching)"></a>Переключение контекста (Context Switching)</h2><p>Планировщику Go требуются четко определенные события пользовательского пространства, которые происходят в безопасных точках кода для контекстного переключения. Эти события и безопасные точки(safe points) проявляются в вызовах функций. Вызовы функций критически важны для работоспособности Go scheduler. Сегодня (с Go 1.11 или менее), если вы запускаете какие-либо жесткие циклы(tight loops), которые не выполняют вызовы функций, вы вызываете задержки в планировщике и сборку мусора. Критически важно, чтобы вызовы функций выполнялись в разумные сроки(reasonable timeframes).</p><ul><li>Примечание: Есть <a href="https://github.com/golang/go/issues/24543">предложение</a> для версии 1.12, которое было принято для применения некооперативных методов вытеснения внутри Go scheduler, позволяющих вытеснять жесткие циклы(tight loops).</li></ul><p>В ваших программах Go происходят четыре класса событий, которые позволяют планировщику принимать решения о планировании. Это не означает, что это всегда будет происходить в одном из этих событий. Это означает, что планировщик получает такую возможность.</p><ul><li>Использование ключевого слова go</li><li>Сборка мусора (Garbage collection)</li><li>Системные вызовы (System calls) например Netwokr Poller(asyc syscalls) или чтение файла</li><li>Синхронизация и оркестровка (Synchronization and Orchestration) </li></ul><h3 id="Использование-ключевого-слова-go"><a href="#Использование-ключевого-слова-go" class="headerlink" title="Использование ключевого слова go"></a>Использование ключевого слова go</h3><p>Ключевое слово go - это то, как вы создаете рабочие горутины. Как только новая рабочая горутина создана, это дает планировщику возможность принять решение о планировании.</p><h3 id="Сборка-мусора-Garbage-collection-GC"><a href="#Сборка-мусора-Garbage-collection-GC" class="headerlink" title="Сборка мусора (Garbage collection - GC)"></a>Сборка мусора (Garbage collection - GC)</h3><p>Поскольку GC запускается с использованием собственного набора горутин, для запуска этих горутин требуется время на M. Это приводит к тому, что GC создает большой хаос в планировании. Однако планировщик очень хорошо разбирается в том, что делает горутина, и использует этот интеллект для принятия разумных решений. Одним из разумных решений является переключение контекста горутины, которая хочет коснуться кучи(лезут в хип(heap)), с теми, которые не касаются кучи во время GC. Когда GC запущен, принимается множество решений о планировании.</p><h3 id="Системные-вызовы-System-calls-or-syscalls"><a href="#Системные-вызовы-System-calls-or-syscalls" class="headerlink" title="Системные вызовы (System calls or syscalls)"></a>Системные вызовы (System calls or syscalls)</h3><p>Если горутина выполняет системный вызов(syscalls), который заставляет блокировать M, то иногда планировщик способен контекстно переключать(context-switching) горутину в состояние  off(waiting) с M на новую горутину на ту же самой M. Однако иногда требуется новая M для продолжения выполнения гурутин, которые поставлены в очередь в P. Как это работает, будет объяснено более подробно в следующем разделе.</p><h3 id="Синхронизация-и-оркестровка-Synchronization-and-Orchestration"><a href="#Синхронизация-и-оркестровка-Synchronization-and-Orchestration" class="headerlink" title="Синхронизация и оркестровка (Synchronization and Orchestration)"></a>Синхронизация и оркестровка (Synchronization and Orchestration)</h3><p>Если атомарный вызов, мьютекс или операция над каналом вызовут блокировку гурутины, то планировщик может переключить контекст для запуска новой горутины. Как только горутина снова сможет выполняться, ее можно повторно поставить в очередь и, в конечном итоге, снова переключить контекст на M.</p><h2 id="Асинхронные-системные-вызовы-Asynchronous-System-Calls"><a href="#Асинхронные-системные-вызовы-Asynchronous-System-Calls" class="headerlink" title="Асинхронные системные вызовы (Asynchronous System Calls)"></a>Асинхронные системные вызовы (Asynchronous System Calls)</h2><p>Когда ваша операционная система, в которой вы работаете, имеет возможность обрабатывать системный вызов асинхронно, для более эффективной обработки системного вызова можно использовать так называемый сетевой опросник (network poller - NP). Это достигается с помощью kqueue (macOS), epoll (Linux) или iocp (Windows) в соответствующих операционных системах.</p><p>Системные вызовы на основе сети могут обрабатываться асинхронно многими операционными системами, которые мы используем сегодня. Отсюда и название network poller, поскольку его основное назначение - обработка сетевых операций. Используя сетевой опросник NP для сетевых системных вызовов, планировщик может запретить горутинам блокировать M при выполнении этих системных вызовов. Это помогает сохранить M доступным для выполнения других горутин в LRQ(Local Run Queue) P без необходимости создавать новые Ms. Это помогает снизить нагрузку на операционную систему при планировании.</p><p>Лучший способ увидеть, как это работает, - это просмотреть пример.</p><p>Рисунок 3<br><img src="/images/golang_scheduler3.png" alt="Рисунок3 "></p><p>На рисунке 3 показана наша базовая схема планирования. Goroutine-1(G1 горутина) выполняется на M, и еще 3 горутины ожидают в LRQ получения своего времени на M. Сетевой опросник(NetPoller) простаивает, ему нечего делать.</p><p>Рисунок 4<br><img src="/images/golang_scheduler4.png" alt="Рисунок4 "></p><p>На рисунке 4 Goroutine-1(G1) хочет выполнить сетевой системный вызов, поэтому Goroutine-1(G1) перемещается в сетевой опросник и обрабатывается как асинхронный сетевой системный вызов. Как только  Goroutine-1(G1) перемещается в сетевой опросник, M теперь доступен для выполнения другой гурутины из LRQ. В этом случае Goroutine-2(G2) переключается по контексту на M.</p><p>Рисунок 5<br><img src="/images/golang_scheduler5.png" alt="Рисунок5 "><br>На рисунке 5 сетевой опросник завершает асинхронный сетевой системный вызов, и Goroutine-1(G1) перемещается обратно в LRQ для P. Как только Goroutine-1(G1) может быть снова переключена по контексту на M, связанный с Go код, за который она отвечает, может выполняться снова. Большим преимуществом здесь является то, что для выполнения сетевых системных вызовов не требуется дополнительных Мс. Сетевой опросник имеет отделный поток операционной системы, и он обрабатывает эффективный цикл обработки событий (event loop)</p><h2 id="Синхронные-системные-вызовы-Synchronous-System-Calls"><a href="#Синхронные-системные-вызовы-Synchronous-System-Calls" class="headerlink" title="Синхронные системные вызовы (Synchronous System Calls)"></a>Синхронные системные вызовы (Synchronous System Calls)</h2><p>Что происходит, когда горутина хочет выполнить системный вызов, который не может быть выполнен асинхронно? В этом случае сетевой опросник не может быть использован, и горутина, выполняющая системный вызов, заблокирует M. Это прискорбно, но предотвратить это невозможно. Одним из примеров системного вызова, который нельзя выполнить асинхронно, являются системные вызовы на основе файлов(file-based system calls). Если вы используете CGO, могут возникнуть другие ситуации, когда вызов функций C также заблокирует M .</p><ul><li>Примечание: ОС Windows имеет возможность асинхронного выполнения системных вызовов на основе файлов. Технически при работе в Windows можно использовать сетевой опросник.</li></ul><p>Давайте рассмотрим, что происходит с синхронным системным вызовом (например, файловым вводом-выводом), который вызывает блокировку M.</p><p><img src="/images/golang_scheduler6.png" alt="Рисунок6 "></p><p>На рисунке 6 снова показана наша базовая схема планирования, но на этот раз Goroutine-1(G!) собирается выполнить синхронный системный вызов, который заблокирует M1.</p><p><img src="/images/golang_scheduler7.png" alt="Рисунок7 "></p><p>На рисунке 7 планировщик может определить, что Goroutine-1(G1) вызвала блокировку M. На этом этапе планировщик отсоединяет M1 от P, при этом блокирующая Goroutine-1(G1) все еще подключена. Затем планировщик вводит новый M2 для обслуживания P. На этом этапе в LRQ можно выбрать Goroutine-2(G2) и включить M2 с контекстным переключением. Если M уже существует из-за предыдущей замены, этот переход выполняется быстрее, чем создание нового M.</p><p><img src="/images/golang_scheduler8.png" alt="Рисунок8 "></p><p>На рисунке 8 системный вызов блокировки, выполненный Goroutine-1(G1), завершается. На этом этапе Goroutine-1(G1) может вернуться в LRQ и снова обслуживаться P. Затем M1 помещается сбоку для использования в будущем, если этот сценарий потребуется повторить</p><h1 id="Кража-работы-Work-Stealing"><a href="#Кража-работы-Work-Stealing" class="headerlink" title="Кража работы (Work Stealing)"></a>Кража работы (Work Stealing)</h1><p>Еще одним аспектом планировщика является то, что он забирает работу. В нескольких областях это помогает поддерживать эффективность планирования. Во-первых, последнее, чего вы хотите, - это чтобы M переходил в состояние ожидания, потому что, как только это произойдет, ОС контекстно отключит M от ядра. Это означает, что P не может выполнить какую-либо работу, даже если есть горутина в работоспособном(runnable - готовая к работе) состоянии, пока M не будет снова переключено по контексту в ядре. Кража работы также помогает сбалансировать графики работы по всем логическим процессорам Ps, чтобы работа была лучше распределена и выполнялась эффективнее.</p><p>Давайте рассмотрим пример. Let’s run through an example.</p><p><img src="/images/golang_scheduler9.png" alt="Рисунок9 "></p><p>На рисунке 9 у нас есть многопоточная программа Go с двумя P, обслуживающими четыре горутины каждая, и одной грутины(G9) в GRQ. Что произойдет, если один из P быстро выполнит все свои программы?</p><p><img src="/images/golang_scheduler10.png" alt="Рисунок10 "></p><p>На рисунке 10 у P1 больше нет программ для выполнения. Но есть программы в состоянии выполнения, как в LRQ для P2, так и в GRQ. Это момент, когда P1 нужно украсть работу.<br>Правила для <a href="https://golang.org/src/runtime/proc.go">кражи работы</a> следующие.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">runtime.schedule() &#123;</span><br><span class="line">    <span class="comment">// only 1/61 of the time, check the global runnable queue for a G.</span></span><br><span class="line">    <span class="comment">// только в одном 1 из 61 тиков проверяйте GRQ очередь на наличие G.</span></span><br><span class="line">    <span class="comment">// if not found, check the local queue.</span></span><br><span class="line">    <span class="comment">// если G не найдена, проверьте локальную очередь.</span></span><br><span class="line">    <span class="comment">// if not found,</span></span><br><span class="line">    <span class="comment">// если G не найдена в локальной, то</span></span><br><span class="line">    <span class="comment">//     try to steal from other Ps.</span></span><br><span class="line">    <span class="comment">//     попробуйте украсть у других Ps.</span></span><br><span class="line">    <span class="comment">//     if not, check the global runnable queue.</span></span><br><span class="line">    <span class="comment">//     если нет у Ps,то  опять проверьте GRQ очередь</span></span><br><span class="line">    <span class="comment">//     if not found, poll network.</span></span><br><span class="line">    <span class="comment">//      если нет в GPQ, то опросите сеть (NP)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Итак, основываясь на правилах, приведенных в листинге 2, P1 необходимо проверить P2 на наличие подпрограмм в своем LRQ и взять половину того, что он найдет.</p><p>Рисунок 11<br><img src="/images/golang_scheduler11.png" alt="Рисунок10 "></p><p>На рисунке 11 половина горутин взята из P2, и теперь P1 может выполнять эти программы.</p><p>Что произойдет, если P2 завершит обслуживание всех своих горутин, а у P1 в LRQ ничего не останется?</p><p>Рисунок 12<br><img src="/images/golang_scheduler12.png" alt="Рисунок12 "></p><p>На рисунке 12 P2 завершил всю свою работу, и теперь ему нужно немного украсть. Сначала он проверит LRQ P1, но не найдет никаких горутин. Затем он посмотрит на GRQ. Там он найдет Goroutine-9.</p><p>Рисунок 13<br><img src="/images/golang_scheduler13.png" alt="Рисунок13 "></p><p>На рисунке 13 P2 крадет Goroutine-9(G9) из GRQ и начинает выполнять работу. Что замечательно во всей этой краже работы, так это то, что это позволяет Ms оставаться занятой и не простаивать. Такое воровство работы внутренне рассматривается как раскручивание M. У этого раскручивания есть и другие преимущества, которые Джей Би Ди хорошо объясняет в своем блоге о <a href="https://rakyll.org/scheduler/">воровстве работы</a>.</p><p>Практический пример (Practical Example)</p><p>Теперь, когда механика и семантика на месте, я хочу показать вам, как все это объединяется, чтобы позволить Go scheduler выполнять больше работы с течением времени. Представьте себе многопоточное приложение, написанное на C, где программа управляет двумя потоками операционной системы(two OS Threads), которые передают сообщения друг другу</p><p>Рисунок 14<br><img src="/images/golang_scheduler14.png" alt="Рисунок14 "></p><p>На рисунке 14 показаны 2 потока(2 Threads T1 and T2), которые передают сообщение туда и обратно. Поток 1(T1) переключается по контексту на ядре 1(C1) и теперь выполняется(executing), что позволяет потоку 1(T1) отправить свое сообщение потоку 2(T2).</p><p>Примечание: Способ передачи сообщения не имеет значения. Важно состояние потоков по мере выполнения этой настройки.</p><p>Рисунок 15<br><img src="/images/golang_scheduler15.png" alt="Рисунок15 "></p><p>На рисунке 15 показано, что после того, как поток 1(T1) завершит отправку сообщения, ему теперь нужно дождаться ответа. Это приведет к тому, что поток 1(T1) отключится от ядра 1(C1) по контексту и перейдет в состояние ожидания(waiting state). Как только поток 2(T2) получает уведомление о сообщении, он переходит в состояние, пригодное для выполнения(runnable state). Теперь ОС может выполнить переключение контекста и запустить поток 2(T2), выполняющийся на ядре, которым, оказывается, является ядро 2(C2). Затем поток 2(T2) обрабатывает сообщение и отправляет новое сообщение обратно в поток 1(T1).</p><p>Рисунок 16<br><img src="/images/golang_scheduler16.png" alt="Рисунок16"></p><p>На рисунке 16 потоки снова переключают контекст, когда сообщение от потока 2(T2) принимается потоком 1(T1). Теперь поток 2(T2) контекстно переключается из состояния выполнения(executing state) в состояние ожидания( waiting state), а поток 1(T1) контекстно переключается из состояния ожидания(waiting state) в состояние, пригодное для выполнения(runnable state), и, наконец, обратно в состояние выполнения(executing state), что позволяет ему обработать и отправить новое сообщение обратно.</p><p>Все эти переключения контекста и изменения состояния требуют времени для выполнения, что ограничивает скорость выполнения работы. Поскольку каждый потенциал переключения контекста требует задержки ~ 1000 наносекунд, и, надеюсь, аппаратное обеспечение выполняет 12 инструкций в наносекунду, вы видите более или менее 12 тысяч инструкций, не выполняющихся во время этих переключений контекста. Поскольку эти потоки также перемещаются между разными ядрами, вероятность возникновения дополнительной задержки из-за пропусков строк кэша(cache-line misses) также высока.</p><p>Давайте возьмем тот же пример, но вместо него используем Goroutines и Go scheduler.</p><p>Рисунок 17<br><img src="/images/golang_scheduler17.png" alt="Рисунок17"></p><p>На рисунке 17 показаны две горутины, которые взаимодействуют друг с другом, передавая сообщение взад и вперед. G1 переключается по контексту на M1, который, оказывается, запущен на ядре 1(С1), что позволяет G1 выполнять свою работу. Работа заключается в том, чтобы G1 отправил свое сообщение на G2.</p><p>Рисунок 18<br><img src="/images/golang_scheduler18.png" alt="Рисунок18"><br>На рисунке 18, как только G1 завершит отправку сообщения, ему теперь нужно дождаться ответа. Это приведет к контекстному отключению G1 от M1 и переводу в состояние ожидания(waiting state). Как только G2 получает уведомление о сообщении, он переходит в состояние, пригодное для выполнения(runnable state). Теперь планировщик Go может выполнить переключение контекста и запустить G2 на M1, который все еще работает на ядре 1(C1). Затем G2 обрабатывает сообщение и отправляет новое сообщение обратно на G1.</p><p>Рисунок 19<br><img src="/images/golang_scheduler19.png" alt="Рисунок19"></p><p>На рисунке 19 все снова переключается по контексту, когда сообщение, отправленное G2, принимается G1. Теперь контекст G2 - переключается из состояния выполнения в состояние ожидания(executing state to a waiting state), а контекст G1 - переключается из состояния ожидания в состояние, пригодное для выполнения(waiting state to a runnable state), и, наконец, обратно в состояние выполнения(executing state), что позволяет ему обработать и отправить новое сообщение обратно.</p><p>На первый взгляд кажется, что ничего не изменилось. Все те же переключения контекста и изменения состояния происходят независимо от того, используете ли вы потоки или горутины. Однако существует существенное различие между использованием потоков и горутинами, которое может быть неочевидным на первый взгляд.</p><p>В случае использования горутин для всей обработки используется один и тот же поток(M1 крутится на T1) операционной системы и ядро(C1). Это означает, что с точки зрения операционной системы поток(T1) операционной системы никогда не переходит в состояние ожидания; ни разу. В результате все те инструкции, которые мы потеряли из-за переключения контекста при использовании потоков(T), не теряются при использовании горутин.</p><p>По сути, Go превратил  IO/Blocking work(работу по вводу-выводу/блокированию) в CPU-bound work (работу с привязкой к процессору) на уровне операционной системы(OS level). Поскольку все переключение контекста происходит на уровне приложения, мы не теряем те же ~ 12 тыс. инструкций (в среднем) на одно переключение контекста, которые мы теряли при использовании потоков(T). В Go те же самые переключения контекста обходятся вам в ~ 200 наносекунд или ~ 2,4 тыс. инструкций. Планировщик также помогает повысить эффективность кэш-памяти и <a href="http://frankdenneman.nl/2016/07/07/numa-deep-dive-part-1-uma-numa">NUMA</a>. Вот почему нам не нужно больше потоков, чем у нас есть виртуальных ядер. В Go со временем можно выполнять больше работы, потому что планировщик Go пытается использовать меньше потоков(T) и делать больше в каждом потоке(T), что помогает снизить нагрузку на ОС и оборудование.</p><h2 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h2><p>Планировщик Go действительно поражает тем, как его дизайн учитывает тонкости работы операционной системы и аппаратного обеспечения. Возможность превращать работу ввода-вывода / блокировки в работу с привязкой к процессору на уровне операционной системы - это то, где мы получаем большой выигрыш в увеличении мощности процессора с течением времени. Вот почему вам не нужно больше потоков ОС, чем у вас виртуальных ядер. Вы можете разумно рассчитывать на выполнение всей вашей работы (с привязкой к процессору и вводу-выводу / блокировке) всего одним потоком ОС на виртуальное ядро. Это возможно для сетевых приложений и других приложений, которым не нужны системные вызовы, блокирующие потоки операционной системы.</p><p>Как разработчику, вам все еще необходимо понимать, что делает ваше приложение с точки зрения видов выполняемой вами работы. Вы не можете создавать неограниченное количество программ и ожидать потрясающей производительности. Меньше всегда значит больше, но, понимая семантику Go-scheduler, вы можете принимать более эффективные инженерные решения. В следующем посте я рассмотрю идею использования параллелизма консервативными способами для повышения производительности при сохранении баланса между сложностью, которую вам, возможно, потребуется добавить в код.</p>]]></content>
    
    
    <summary type="html">Как устроен планировкщик GO</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Планировщик" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"/>
    
    <category term="Планировщик" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Планировщик GO другой взгляд</title>
    <link href="https://goxpert.ru/2024/06/01/concurrency/go_scheduler_more/"/>
    <id>https://goxpert.ru/2024/06/01/concurrency/go_scheduler_more/</id>
    <published>2024-06-01T09:35:00.000Z</published>
    <updated>2024-06-05T07:29:36.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Планирование-в-Go-другой-взляд"><a href="#Планирование-в-Go-другой-взляд" class="headerlink" title="Планирование в Go другой взляд"></a>Планирование в Go другой взляд</h1><p>Возможно, вы слышали о планировщике Goroutine раньше, но насколько хорошо мы на самом деле знаем, как он работает? Как он связывает goroutines с потоками?</p><p>О чем будем говорить: <a href="https://blog.devtrovert.com/p/goroutine-scheduler-revealed-youll">перевод статьи</a></p><ul><li>Статья обсуждает параллелизм и распараллеливаемость в программировании на языке Go. </li><li>Go предоставляет планировщик Goroutine для упрощения параллелизма. </li><li>Goroutine действует как самая маленькая исполнительная единица Go и сопоставляется с потоками ядра. </li><li>Программы Goroutines существуют в трех основных состояниях: ожидание, работоспособное и запуск. </li><li>Планировщик Go сопоставляет M подпрограмм с N потоками ядра, формируя модель M:N. </li><li>Параллелизм означает одновременную обработку множества задач, не всегда одновременно. </li><li>Распараллеливаемость означает выполнение многих задач одновременно, часто с использованием более одного ядра процессора. </li><li>Планировщик Go работает с потоками, используя логические объекты вместо физических. </li><li>Ограничение потоков по умолчанию в Go составляет до 10 000 потоков. </li></ul><h3 id="Поехали"><a href="#Поехали" class="headerlink" title="Поехали"></a>Поехали</h3><p><img src="/images/golang_scheduler_more1.png" alt="За кулисами Goroutines"></p><h2 id="Серия-параллелизмов"><a href="#Серия-параллелизмов" class="headerlink" title="Серия параллелизмов"></a>Серия параллелизмов</h2><p><a href="https://blog.devtrovert.com/p/goroutines-think-you-know-go-basics">Goroutines 102: базовое пошаговое руководство</a></p><p><a href="https://blog.devtrovert.com/p/go-channels-explained-more-than-just">Объясненные каналы Go: больше, чем просто руководство для начинающих.</a></p><p><a href="https://blog.devtrovert.com/p/select-and-for-range-channel-i-bet">Выберите &amp; для канала диапазона в Go: разбивка</a></p><p>Раскрыт планировщик Goroutine: больше никогда не увидите Goroutines в прежнем виде</p><p>Не беспокойтесь о понимании изображения выше прямо сейчас, поскольку мы собираемся начать с самых основ.</p><p>Goroutines распределяются по потокам, которые планировщик Goroutine обрабатывает за сценой. Из наших предыдущих выступлений мы кое-что знаем о goroutines:</p><ul><li><p>Goroutines с точки зрения необработанной скорости выполнения не обязательно быстрее потоков, поскольку для их запуска требуется реальный поток.</p></li><li><p>Реальное преимущество goroutines заключается в таких областях, как переключение контекста, объем памяти, стоимость создания и демонтажа.</p></li></ul><p>Возможно, вы слышали о планировщике Goroutine раньше, но насколько хорошо мы на самом деле знаем, как он работает? Как он связывает goroutines с потоками?</p><p>Теперь работа планировщика разбивается шаг за шагом.</p><h1 id="1-Планировщик-Goroutine-M-N"><a href="#1-Планировщик-Goroutine-M-N" class="headerlink" title="1. Планировщик Goroutine M: N"></a>1. Планировщик Goroutine M: N</h1><p>Команда Go действительно упростила для нас параллелизм, просто подумайте об этом: создать goroutine так же просто, как добавить к функции префикс с go ключевым словом.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> doWork()</span><br></pre></td></tr></table></figure><p>Но за этим простым шагом стоит более глубокая система работы.</p><p>С самого начала Go не просто предоставлял нам потоки. Вместо этого в середине есть помощник, планировщик Goroutine, который является ключевой частью среды выполнения Go.</p><p><img src="/images/golang_scheduler_more2.png" alt="Планировщик Goroutine"></p><p>Так что же это за метка M: N?</p><p>Это указывает на роль планировщика Go в сопоставлении M goroutines с N потоками ядра, формируя модель M: N. У вас может быть больше потоков операционной системы, чем ядер, точно так же, как goroutines может быть больше, чем потоков операционной системы.</p><p>Прежде чем мы углубимся в изучение планировщика, давайте проясним два термина, которые часто путают: параллелизм и параллелизм.</p><p>Конкурентный параллелизм(Concurrency): речь идет о одновременной обработке множества задач, все они перемещаются, но не всегда в одно и то же время.</p><p>Параллелизм(Parallelism): это означает, что многие задачи выполняются в одно и то же время, часто с использованием более чем одного ядра процессора.</p><p><img src="/images/golang_scheduler_more3.png" alt="Concurrency vs Parallelism"></p><h1 id="2-Модель-PMG"><a href="#2-Модель-PMG" class="headerlink" title="2. Модель PMG"></a>2. Модель PMG</h1><p>Прежде чем мы распутаем внутреннюю работу, давайте разберем, что означают P, M и G .</p><p>G (goroutine)<br>Goroutine действует как наименьшая исполнительная единица Go, сродни облегченному потоку.</p><p>Во время выполнения Go это представлено struct{} с именем g. После установки он находит свое место в локальной очереди выполнения логического процессора P (или очереди Gs), и оттуда P передает его фактическому потоку ядра (M).</p><p>Goroutines обычно существуют в трех основных состояниях:</p><ul><li><p>Ожидание(Waiting): На данном этапе goroutine находится в состоянии покоя, возможно, он приостановлен для выполнения такой операции, как канал или блокировка, или, возможно, он остановлен системным вызовом.</p></li><li><p>Возможность выполнения или Готовый к выполнению (Runnable): goroutine полностью готова к запуску, но еще не запущена, она ожидает своей очереди для запуска в потоке (M).</p></li><li><p>Запущеная горутина (Running or Executing): теперь goroutine активно выполняется в потоке (M). Это продолжается до тех пор, пока его задача не будет выполнена, если только планировщик не прервет это или что-то еще не преградит ему путь</p></li></ul><p><img src="/images/golang_scheduler_more4.png" alt="Goroutine States"></p><p>Goroutines НЕ используются только один раз, а затем отбрасываются.</p><p>Вместо этого, когда запускается новая goroutine, среда выполнения Go погружается в пул goroutine, чтобы выбрать одну, но если ничего не найдено, она создает новую. Затем эта новая goroutine присоединяется к очереди выполнения P.</p><h2 id="P-логический-процессор"><a href="#P-логический-процессор" class="headerlink" title="P (логический процессор)"></a>P (логический процессор)</h2><p>В планировщике Go, когда мы упоминаем “процессор”, мы имеем в виду логическую сущность, а не физическую.</p><p>По умолчанию число P равно количеству доступных ядер, вы можете проверить или изменить количество этих процессоров с помощью runtime.GOMAXPROCS(int).</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(<span class="number">0</span>) <span class="comment">// get the current allowed number of logical processors</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: 8 (depends on your machine)</span></span><br></pre></td></tr></table></figure><p>Если вы подумаете об изменении этого, лучше всего сделать это один раз при запуске вашего приложения, если вы измените его во время выполнения, это вызовет STW (stopTheWorld), все приостановлено до изменения размера процессора.</p><p>Каждый P содержит свой собственный список запускаемых goroutines, называемый локальной очередью запуска, который может вместить до 256 goroutines.</p><p><img src="/images/golang_scheduler_more5.png" alt="Scheduler — P (логический процессор)"></p><p>Если в очереди P достигнуто максимальное количество goroutines (256), появляется общая очередь, называемая глобальной очередью запуска, но мы вернемся к этому позже.</p><p>“Итак, что на самом деле показывает это число ‘P”?”</p><p>Это указывает на количество goroutines, которые могут работать одновременно — представьте, что они работают бок о бок.</p><h2 id="M-Машинный-поток-—-поток-операционной-системы"><a href="#M-Машинный-поток-—-поток-операционной-системы" class="headerlink" title="M (Машинный поток — поток операционной системы)"></a>M (Машинный поток — поток операционной системы)</h2><p>Типичная программа Go способна использовать до 10 000 потоков.</p><p>И да, я говорю о потоках, а не о goroutines. Если вы превысите это ограничение, вы рискуете завершить работу своего приложения Go.</p><p>“Когда создается поток?”</p><p>Подумайте об этой ситуации: goroutine находится в работоспособном состоянии и требует потока.</p><p>Что произойдет, если все потоки уже заблокированы, возможно, из-за системных вызовов или операций без вытеснения? В этом случае вмешивается планировщик и создает новый поток для этой goroutine.</p><p>(Следует отметить одну вещь: если поток просто занят дорогостоящими вычислениями или длительно выполняющейся задачей, это не считается зависанием или блокировкой)</p><p>Если вы хотите изменить ограничение потока по умолчанию, вы можете использовать runtime/debug.SetMaxThreads() функцию, это позволяет вам установить максимальное количество потоков операционной системы, которое может использовать ваша программа Go.</p><p>Также полезно знать, что потоки используются повторно, поскольку создание или удаление потоков требует больших ресурсов.</p><h1 id="3-Как-работает-MPG"><a href="#3-Как-работает-MPG" class="headerlink" title="3. Как работает MPG"></a>3. Как работает MPG</h1><p>Давайте разберемся, как M, P и G работают вместе, шаг за шагом, с помощью маркированных пунктов.</p><p>Я не буду здесь вдаваться в каждую мельчайшую деталь, но углублюсь в следующих историях. Если это вас заинтересовало, пожалуйста, подпишитесь.</p><p><img src="/images/golang_scheduler_more6.png" alt="Как работает Go Scheduler"></p><ol><li><p>Инициируйте goroutine(Initiate a goroutine): с помощью go func() команды среда выполнения Go либо создает новую goroutine, либо выбирает существующую из пула.</p></li><li><p>Расположение очереди(Queue positioning): goroutine ищет свое место в очереди, и если локальные очереди всех логических процессоров (P) заполнены, эта goroutine помещается в глобальную очередь.</p></li><li><p>Сопряжение потоков(Thread-Pairing): здесь в игру вступает M. Он захватывает(grabs) P и начинает обработку goroutine из локальной очереди P, поскольку M взаимодействует с этой goroutine, связанный с ней P становится занятым и недоступным для других Ms.</p></li><li><p>Акт кражи(The act of stealing): если очередь P исчерпана, M пытается “позаимствовать(borrow)” половину запущенных goroutines из очереди другого P . В случае неудачи он проверяет глобальную очередь, за которой следует сетевой опросник (посмотрите на раздел схемы процесса кражи ниже).</p></li><li><p>Распределение ресурсов(Resource allocation): После того, как M выбирает goroutine (G), он обеспечивает все необходимые ресурсы для запуска G.</p></li></ol><p>“Как насчет того, что поток заблокирован?”</p><p>Если goroutine запускает системный вызов, который требует времени (например, чтение файла), M ожидает.</p><p>Но планировщику не нравится, когда кто-то просто сидит и ждет, он отсоединяет остановленную M от ее P и подключает другую, работоспособную (runable т.е готовую к выполнению) goroutine из очереди к новой или существующей M, которая затем объединяется с P</p><p><img src="/images/golang_scheduler_more7.png" alt="Заблокированные потоки - Blocked Threads"></p><h2 id="Процесс-кражи-Stealing-Process"><a href="#Процесс-кражи-Stealing-Process" class="headerlink" title="Процесс кражи (Stealing Process)"></a>Процесс кражи (Stealing Process)</h2><p>Когда поток (M) завершает свои задачи и ему больше нечего делать, он не сидит сложа руки.</p><p>Вместо этого он активно ищет больше работы, просматривая другие процессоры и беря на себя половину их задач, давайте разберем это:</p><p><img src="/images/golang_scheduler_more8.png" alt="Заблокированные потоки - Blocked Threads"></p><ol><li><p>Каждые 61 тик M проверяет глобальную очередь выполнения, чтобы убедиться в честности( fairness - справведлиновсть) выполнения. Если в глобальной очереди найдена работоспособная(runnable - готовая к выполнению) goroutine, остановитесь.</p></li><li><p>Этот поток M теперь проверяет свою локальную очередь запуска, связанную с его процессором P, на наличие любых запускаемых(runable - готовых к выполнению) goroutines для работы.</p></li><li><p>Если поток обнаруживает, что его очередь(локальная) пуста, он затем просматривает глобальную очередь, чтобы увидеть, есть ли там какие-либо задачи(any tasks waiting), ожидающие своего завершения.</p></li><li><p>Затем поток проверяет с помощью сетевого опроса(network poller(NP) т.е поток обращается к NP) наличие любых заданий(any network-related jobs), связанных с сетью.</p></li><li><p>Если поток по-прежнему не нашел никаких задач после проверки сетевого опроса(NP), он переходит в режим активного поиска(active search mode), который мы можем рассматривать как состояние вращения(spinning state).</p></li><li><p>В этом состоянии поток пытается “позаимствовать - borrow” задачи из очередей других процессоров.</p></li><li><p>После всех этих шагов, если поток по-прежнему не нашел никакой работы, он прекращает активный поиск. </p></li><li><p>Теперь, если поступают новые задачи и есть свободный процессор без каких-либо поисковых потоков, другому потоку может быть предложено начать работу.</p></li></ol><p>Следует отметить, что глобальная очередь фактически проверяется дважды: один раз через каждые 61 тик для проверки достоверности и еще раз, если локальная очередь пуста.</p><ul><li>“Если M привязан к своему P, как он может принимать задачи от других процессоров? Меняет ли M свой P?”</li></ul><p>Ответ - нет.</p><p>Даже если M берет задачу из очереди другого P, она выполняет эту задачу с использованием своего исходного процессора. Таким образом, пока M берет на себя новые задачи, он остается верным своему процессору.</p><ul><li>“Почему 61?”</li></ul><p>При разработке алгоритмов, особенно алгоритмов хеширования, простые числа часто выбираются из-за отсутствия у них делителей, отличных от 1, и самих себя.</p><p>Это может снизить вероятность появления шаблонов или закономерностей, которые могут привести к “коллизиям” или другому нежелательному поведению.</p><p>Если они слишком короткие, система может тратить ресурсы на частую проверку глобальной очереди запуска. Если слишком длинные, программы goroutine могут чрезмерно долго ждать выполнения.</p><h1 id="Сетевой-опросник-Network-Poller"><a href="#Сетевой-опросник-Network-Poller" class="headerlink" title="Сетевой опросник (Network Poller)"></a>Сетевой опросник (Network Poller)</h1><p>Мы мало обсуждали этот сетевой опросник, но он представлен на схеме процесса кражи.</p><p>Как и планировщик Go, сетевой опросник является компонентом среды выполнения Go и отвечает за обработку вызовов, связанных с сетью (например, сетевого ввода-вывода).</p><p>Давайте сравним 2 типа системных вызовов:</p><ul><li><p>Системные вызовы, связанные с сетью (Network-related Syscalls): когда goroutine выполняет операцию сетевого ввода-вывода(network I/O operation), вместо блокирования потока она регистрируется в сетевом опроснике(NP). NP ожидает асинхронного завершения операции, и после завершения goroutine снова становится работоспособной(runnable готовый к выполнению) и может продолжить свое выполнение в потоке.</p></li><li><p>Другие системные вызовы (Other Syscalls): если они потенциально блокируются и не обрабатываются сетевым опросником, они могут заставить goroutine перенести свое выполнение в поток операционной системы. Блокируется только этот конкретный поток операционной системы, и планировщик Go runtime scheduler может выполнять другие goroutines в разных потоках.</p></li></ul><p><a href="https://habr.com/ru/articles/804145/">Кстати нашел еще один перевод на хабре</a> автор перевел и картинки</p>]]></content>
    
    
    <summary type="html">Раскрыт планировщик Goroutine. больше никогда не увидите Goroutines в прежнем виде</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Планировщик" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"/>
    
    <category term="Планировщик" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Планировщик GO - Concurrency</title>
    <link href="https://goxpert.ru/2024/06/01/concurrency/go_concurrency/"/>
    <id>https://goxpert.ru/2024/06/01/concurrency/go_concurrency/</id>
    <published>2024-06-01T09:35:00.000Z</published>
    <updated>2024-06-05T17:12:58.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Планирование-в-Go-часть-III-Параллелизм-Concurrency"><a href="#Планирование-в-Go-часть-III-Параллелизм-Concurrency" class="headerlink" title="Планирование в Go: часть III - Параллелизм (Concurrency)"></a>Планирование в Go: часть III - Параллелизм (Concurrency)</h1><p>О чем будем говорить: <a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html">перевод статьи</a></p><p>Перевод сделан <a href="/2024/06/01/helloworld/index.html">автором сайта goxpert.ru</a></p><ul><li>Статья обсуждает использование параллелизма в программировании на языке Go.</li><li>Параллелизм может повысить производительность для рабочих нагрузок, связанных с процессором. </li><li>Важно определить, подходит ли рабочая нагрузка для параллелизма и выбрать правильный тип рабочей нагрузки. </li><li>Примеры алгоритмов и рабочих нагрузок демонстрируют различия в семантике и инженерные решения, которые необходимо учитывать. </li><li>При использовании рабочих нагрузок, связанных с вводом-выводом, параллелизм не всегда приводит к значительному повышению производительности. </li></ul><h1 id="Введение"><a href="#Введение" class="headerlink" title="Введение"></a>Введение</h1><p>Когда я решаю проблему, особенно если это новая проблема, я изначально не думаю о том, подходит ли параллелизм или нет. Сначала я ищу последовательное решение и убеждаюсь, что оно работает. Затем, после удобочитаемости и технических обзоров, я начну задавать вопрос, является ли параллелизм разумным и практичным. Иногда очевидно, что параллелизм подходит, а в других случаях это не так однозначно.</p><p>В первой части этой серии я объяснил механику и семантику планировщика операционной системы, которые, на мой взгляд, важны, если вы планируете писать многопоточный код. Во второй части я объяснил семантику планировщика Go, которая, по моему мнению, важна для понимания того, как писать параллельный код в Go. В этом посте я начну сводить механику и семантику планировщиков OS и Go воедино, чтобы обеспечить более глубокое понимание того, что такое параллелизм, а что нет.</p><p>Целями этого поста являются:</p><ul><li>Дайть рекомендации по семантике, которую вы должны учитывать, чтобы определить, подходит ли рабочая нагрузка для использования параллелизма.</li><li>Показать вам, как различные типы рабочих нагрузок меняют семантику и, следовательно, технические решения, которые вы захотите принять.</li></ul><p>Что такое конкурирующий параллелизм (What is Concurrency)</p><p>Конкурирующий параллелизм(Concurrency) означает выполнение “не по порядку”. Берем набор инструкций, которые в противном случае выполнялись бы последовательно, и находим способ выполнять их не по порядку и при этом давать тот же результат. Для стоящей перед вами задачи должно быть очевидно, что выполнение вне очереди повысит ценность. Когда я говорю “ценность”, я имею в виду достаточный прирост производительности для снижения затрат на сложность. В зависимости от вашей проблемы выполнение вне очереди может быть невозможным или даже иметь смысл.</p><p>Также важно понимать, что сoncurrency - это не то же самое, что параллелизм( <a href="https://blog.golang.org/concurrency-is-not-parallelism">concurrency is not the same as parallelism</a> ). Параллелизм(parallelism) означает выполнение двух или более инструкций одновременно. Это концепция, отличная от Конкурирующего параллелизма(concurrency). Параллелизм(Parallelism) возможен только тогда, когда вам доступны по крайней мере две аппаратных нити операционной системы (OS) и у вас есть по крайней мере 2 горутины, каждая из которых выполняет инструкции независимо в каждом аппаратной ните OS.</p><p>Рисунок 1: Параллелизм против параллелизма</p><p><img src="/images/golang_concurrency1.png" alt="Рисунок 1"></p><p>На рисунке 1 вы видите схему двух логических процессоров (P), каждый из которых имеет свой независимый поток операционной системы (M), подключенный к независимому аппаратному потоку (ядру - Core) на компьютере. Вы можете видеть, что две горутины (G1 и G2) выполняются параллельно, выполняя свои инструкции в соответствующей апаратной ните операционной системы одновременно. В каждом логическом процессоре три горутины по очереди совместно используют соответствующий поток операционной системы(OS thread). Все эти горутины работают одновременно, выполняя свои инструкции в произвольном порядке и распределяя время в потоке операционной системы(OS thread).</p><p>Проблема в том, что иногда использование конкурирующий параллелизма(concurrency) без параллелизма(parallelism) может фактически снизить пропускную способность. Что также интересно, так это то, что иногда использование конкурируещего параллелизма с параллелизмом не дает вам большего прироста производительности, чем вы могли бы ожидать в противном случае.</p><p>Рабочие нагрузки(Workloads)</p><p>Как узнать, когда выполнение вне очереди может быть возможным или иметь смысл? Понимание типа рабочей нагрузки, с которой сталкивается вы решаю вашу проблему(задачу), - отличное место для начала. Существует два типа рабочих нагрузок, которые важно понимать, когда речь заходит о конкурирующем параллелизме.</p><p>Привязка к процессору(CPU-Bound): Это рабочая нагрузка, которая никогда не создает ситуации, когда рабочие программы естественным образом переходят в состояния ожидания и выходят из них. Это работа, при которой постоянно выполняются вычисления. Поток, вычисляющий число Pi до N-й цифры, будет привязан к процессору.</p><p>Привязка к вводу-выводу(IO-Bound): Это рабочая нагрузка, из-за которой рабочие программы естественным образом переходят в состояния ожидания. Это работа, которая заключается в запросе доступа к ресурсу по сети, или выполнении системных вызовов в операционной системе, или ожидании наступления события. Подпрограмма, которой необходимо прочитать файл, будет привязана к вводу-выводу. Я бы включил события синхронизации (мьютексы, атомарные), которые заставляют горутину ждать, как часть этой категории.</p><p>При рабочих нагрузках с привязкой к процессору вам нужен параллелизм, чтобы использовать конкурирующий параллелизм. Один поток операционной системы / аппаратного обеспечения, обрабатывающий несколько горутин, неэффективен, поскольку горутины не переходят в состояния ожидания(waiting states) и из них не выходят в рамках своей рабочей нагрузки. Наличие большего количества горутин, чем потоков операционной системы / оборудования, может замедлить выполнение рабочей нагрузки из-за затрат на задержку (времени, которое требуется) при включении и выключении горутин в потоке операционной системы. Переключение контекста создает событие “Остановить мир Stop The World” для вашей рабочей нагрузки, поскольку ни одна из ваших рабочих нагрузок не выполняется во время переключения, когда это могло бы быть в противном случае.</p><p>При рабочих нагрузках, связанных с вводом-выводом, вам не нужен параллелизм для использования конкурирующего параллелизма. Один поток операционной системы / оборудования может эффективно обрабатывать несколько горутин, поскольку горутины естественным образом переходят в состояния ожидания(waiting states) и выходят из них в рамках своей рабочей нагрузки. Наличие большего количества рабочих горутин, чем потоков операционной системы / оборудования, может ускорить выполнение рабочей нагрузки, поскольку затраты на задержку при включении и выключении рабочих горутин в потоке операционной системы не приводят к возникновению события “Остановить мир”. Ваша рабочая нагрузка естественным образом прекращается, и это позволяет другой горутине эффективно использовать тот же поток операционной системы / оборудования вместо того, чтобы позволять потоку операционной системы / оборудования бездействовать.</p><p>Откуда вы знаете, сколько горутин на аппаратный поток обеспечивает наилучшую пропускную способность? Слишком мало горутин - и у вас больше времени простоя. Слишком много горутин - и у вас больше времени задержки переключения контекста. Вам стоит подумать над этим, но это выходит за рамки данного конкретного поста.</p><p>На данный момент важно просмотреть некоторый код, чтобы укрепить вашу способность определять, когда рабочая нагрузка может использовать конкурирующий параллелизм(concurrency), когда нет, и нужен ли обчный параллелизм(parallelism) или нет.</p><h2 id="Добавление-чисел-Adding-Numbers"><a href="#Добавление-чисел-Adding-Numbers" class="headerlink" title="Добавление чисел (Adding Numbers)"></a>Добавление чисел (Adding Numbers)</h2><p>Листинг 1<br><a href="https://play.golang.org/p/r9LdqUsEzEz">https://play.golang.org/p/r9LdqUsEzEz</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">36</span>  <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(numbers []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="number">37</span>     <span class="keyword">var</span> v <span class="keyword">int</span></span><br><span class="line"><span class="number">38</span>     <span class="keyword">for</span> _, n := <span class="keyword">range</span> numbers &#123;</span><br><span class="line"><span class="number">39</span>         v += n</span><br><span class="line"><span class="number">40</span>     &#125;</span><br><span class="line"><span class="number">41</span>     <span class="keyword">return</span> v</span><br><span class="line"><span class="number">42</span> &#125;</span><br></pre></td></tr></table></figure><p>В листинге 1 в строке 36 объявлена функция с именем add, которая принимает набор целых чисел и возвращает сумму набора. Оно начинается в строке 37 с объявления v переменной, содержащей сумму. Затем в строке 38 функция линейно обходит коллекцию, и каждое число добавляется к текущей сумме в строке 39. Наконец, в строке 41 функция возвращает вызывающей стороне окончательную сумму.</p><p>Вопрос: является ли add функция рабочей нагрузкой, подходящей для выполнения не по порядку? Я полагаю, что ответ положительный. Набор целых чисел может быть разбит на меньшие списки, и эти списки могут обрабатываться одновременно. Как только все меньшие списки будут суммированы, набор сумм можно будет сложить вместе, чтобы получить тот же ответ, что и в последовательной версии.</p><p>Однако на ум приходит другой вопрос. Сколько списков меньшего размера следует создать и обрабатывать независимо, чтобы получить максимальную пропускную способность? Чтобы ответить на этот вопрос, вы должны знать, какую рабочую нагрузку add выполняет. Функция add выполняет нагрузку, связанную с ЦП, потому что алгоритм выполняет чистую математику, и ничто из того, что он делает, не приведет к переходу подпрограммы в естественное состояние ожидания. Это означает, что использование одной подпрограммы для каждого потока операционной системы / оборудования - это все, что необходимо для хорошей пропускной способности.</p><p>В листинге 2 ниже приведена моя параллельная версия add.</p><p>Примечание: Есть несколько способов и опций, которыми вы можете воспользоваться при написании параллельной версии add. На данный момент не зацикливайтесь на моей конкретной реализации. Если у вас есть более читаемая версия, которая работает так же или лучше, я был бы рад, если бы вы поделились ею.</p><p>Листинг 2<br><a href="https://play.golang.org/p/r9LdqUsEzEz">https://play.golang.org/p/r9LdqUsEzEz</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">44</span> <span class="function"><span class="keyword">func</span> <span class="title">addConcurrent</span><span class="params">(goroutines <span class="keyword">int</span>, numbers []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="number">45</span>     <span class="keyword">var</span> v <span class="keyword">int64</span></span><br><span class="line"><span class="number">46</span>     totalNumbers := <span class="built_in">len</span>(numbers)</span><br><span class="line"><span class="number">47</span>     lastGoroutine := goroutines - <span class="number">1</span></span><br><span class="line"><span class="number">48</span>     stride := totalNumbers / goroutines</span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="number">50</span>     <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="number">51</span>     wg.Add(goroutines)</span><br><span class="line"><span class="number">52</span></span><br><span class="line"><span class="number">53</span>     <span class="keyword">for</span> g := <span class="number">0</span>; g &lt; goroutines; g++ &#123;</span><br><span class="line"><span class="number">54</span>         <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(g <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="number">55</span>             start := g * stride</span><br><span class="line"><span class="number">56</span>             end := start + stride</span><br><span class="line"><span class="number">57</span>             <span class="keyword">if</span> g == lastGoroutine &#123;</span><br><span class="line"><span class="number">58</span>                 end = totalNumbers</span><br><span class="line"><span class="number">59</span>             &#125;</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="number">61</span>             <span class="keyword">var</span> lv <span class="keyword">int</span></span><br><span class="line"><span class="number">62</span>             <span class="keyword">for</span> _, n := <span class="keyword">range</span> numbers[start:end] &#123;</span><br><span class="line"><span class="number">63</span>                 lv += n</span><br><span class="line"><span class="number">64</span>             &#125;</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="number">66</span>             atomic.AddInt64(&amp;v, <span class="keyword">int64</span>(lv))</span><br><span class="line"><span class="number">67</span>             wg.Done()</span><br><span class="line"><span class="number">68</span>         &#125;(g)</span><br><span class="line"><span class="number">69</span>     &#125;</span><br><span class="line"><span class="number">70</span></span><br><span class="line"><span class="number">71</span>     wg.Wait()</span><br><span class="line"><span class="number">72</span></span><br><span class="line"><span class="number">73</span>     <span class="keyword">return</span> <span class="keyword">int</span>(v)</span><br><span class="line"><span class="number">74</span> &#125;</span><br></pre></td></tr></table></figure><p>В листинге 2 представлена addConcurrent функция, которая является параллельной версией add функции. Параллельная версия использует 26 строк кода в отличие от 5 строк кода для непараллельной версии. Кода много, поэтому я выделю только важные строки для понимания.</p><p>Строка 48: Каждая подпрограмма получит свой собственный уникальный, но меньший список номеров для добавления. Размер списка рассчитывается путем взятия размера коллекции и деления его на количество подпрограмм.</p><p>Строка 53: Для выполнения работы по добавлению создается пул подпрограмм.</p><p>Строка 57-59: Последняя подпрограмма добавит оставшийся список чисел, которых может быть больше, чем в других подпрограммах.</p><p>Строка 66: Сумма меньших списков суммируется в окончательную сумму.</p><p>Параллельная версия определенно сложнее последовательной, но стоит ли того сложность? Лучший способ ответить на этот вопрос - создать бенчмарк. Для этих тестов я использовал коллекцию из 10 миллионов чисел с отключенным сборщиком мусора. Существует последовательная версия, которая использует add функцию, и параллельная версия, которая использует addConcurrent функцию.</p><p>Листинг 3</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSequential</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        add(numbers)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcurrent</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        addConcurrent(runtime.NumCPU(), numbers)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>В листинге 3 показаны тестовые функции. Вот результаты, когда для всех программ доступен только один поток операционной системы / оборудования. Последовательная версия использует 1 программу, а параллельная версия использует runtime.NumCPU или 8 программ на моей машине. В этом случае параллельная версия использует параллелизм без параллелизма.</p><p>Листинг 4</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">10 Million Numbers using 8 goroutines with 1 core</span><br><span class="line">2.9 GHz Intel 4 Core i7</span><br><span class="line">Concurrency WITHOUT Parallelism</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">$ GOGC=off go <span class="built_in">test</span> -cpu 1 -run none -bench . -benchtime 3s</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/ardanlabs/gotraining/topics/go/testing/benchmarks/cpu-bound</span><br><span class="line">BenchmarkSequential          1000   5720764 ns/op : ~10% Faster</span><br><span class="line">BenchmarkConcurrent          1000   6387344 ns/op</span><br><span class="line">BenchmarkSequentialAgain     1000   5614666 ns/op : ~13% Faster</span><br><span class="line">BenchmarkConcurrentAgain     1000   6482612 ns/op</span><br></pre></td></tr></table></figure><p>Примечание: Запуск бенчмарка на вашем локальном компьютере сложен. Существует множество факторов, которые могут привести к тому, что ваши бенчмарки будут неточными. Убедитесь, что ваш компьютер простаивает настолько, насколько это возможно, и запустите бенчмарки несколько раз. Вы хотите убедиться, что видите согласованность результатов. Если инструмент тестирования дважды запускает бенчмарк, это дает ему наиболее согласованные результаты.</p><p>Тест, приведенный в листинге 4, показывает, что последовательная версия примерно на 10-13 процентов быстрее параллельной, когда для всех программ доступен только один поток операционной системы / оборудования. Это то, чего я ожидал, поскольку параллельная версия имеет накладные расходы на переключение контекста в этом единственном потоке операционной системы и управление подпрограммами.</p><p>Вот результаты, когда для каждой подпрограммы доступен отдельный поток операционной системы / оборудования. Последовательная версия использует 1 подпрограмму, а параллельная версия использует runtime.NumCPU или 8 подпрограмм на моей машине. В этом случае параллельная версия использует параллелизм с параллелизмом.</p><p>Листинг 5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">10 Million Numbers using 8 goroutines with 8 cores</span><br><span class="line">2.9 GHz Intel 4 Core i7</span><br><span class="line">Concurrency WITH Parallelism</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">$ GOGC=off go <span class="built_in">test</span> -cpu 8 -run none -bench . -benchtime 3s</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/ardanlabs/gotraining/topics/go/testing/benchmarks/cpu-bound</span><br><span class="line">BenchmarkSequential-8            1000   5910799 ns/op</span><br><span class="line">BenchmarkConcurrent-8            2000   3362643 ns/op : ~43% Faster</span><br><span class="line">BenchmarkSequentialAgain-8       1000   5933444 ns/op</span><br><span class="line">BenchmarkConcurrentAgain-8       2000   3477253 ns/op : ~41% Faster</span><br></pre></td></tr></table></figure><p>Тест, приведенный в листинге 5, показывает, что параллельная версия примерно на 41-43 процента быстрее последовательной версии, когда для каждой подпрограммы доступен отдельный поток операционной системы / оборудования. Это то, чего я ожидал, поскольку все программы теперь работают параллельно, восемь программ выполняют свою параллельную работу одновременно.</p><p>Сортировка<br>Важно понимать, что не все рабочие нагрузки с привязкой к процессору подходят для параллелизма. В первую очередь это верно, когда очень дорого разбивать работу и / или объединять все результаты. Пример этого можно увидеть на примере алгоритма сортировки, называемого пузырьковой сортировкой. Посмотрите на следующий код, который реализует пузырьковую сортировку в Go.</p><p>Листинг 6<br><a href="https://play.golang.org/p/S0Us1wYBqG6">https://play.golang.org/p/S0Us1wYBqG6</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(numbers []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   n := <span class="built_in">len</span>(numbers)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">       <span class="keyword">if</span> !sweep(numbers, i) &#123;</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweep</span><span class="params">(numbers []<span class="keyword">int</span>, currentPass <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> idx <span class="keyword">int</span></span><br><span class="line">   idxNext := idx + <span class="number">1</span></span><br><span class="line">   n := <span class="built_in">len</span>(numbers)</span><br><span class="line">   <span class="keyword">var</span> swap <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> idxNext &lt; (n - currentPass) &#123;</span><br><span class="line">       a := numbers[idx]</span><br><span class="line">       b := numbers[idxNext]</span><br><span class="line">       <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">           numbers[idx] = b</span><br><span class="line">           numbers[idxNext] = a</span><br><span class="line">           swap = <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">       idx++</span><br><span class="line">       idxNext = idx + <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> swap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   org := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>&#125;</span><br><span class="line">   fmt.Println(org)</span><br><span class="line">   bubbleSort(org)</span><br><span class="line">   fmt.Println(org)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В листинге 6 приведен пример пузырьковой сортировки, написанный в Go. Этот алгоритм сортировки просматривает коллекцию целых чисел, меняя значения на каждом проходе. В зависимости от порядка расположения списка может потребоваться несколько проходов по коллекции, прежде чем все будет отсортировано.</p><p>Вопрос: является ли bubbleSort функция рабочей нагрузкой, подходящей для выполнения не по порядку? Я полагаю, что ответ отрицательный. Набор целых чисел можно разбить на меньшие списки, и эти списки можно сортировать одновременно. Однако после выполнения всей параллельной работы не существует эффективного способа объединить меньшие списки вместе. Вот пример параллельной версии пузырьковой сортировки.</p><p>Листинг 8</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSortConcurrent</span><span class="params">(goroutines <span class="keyword">int</span>, numbers []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    totalNumbers := <span class="built_in">len</span>(numbers)</span><br><span class="line">    lastGoroutine := goroutines - <span class="number">1</span></span><br><span class="line">    stride := totalNumbers / goroutines</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(goroutines)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> g := <span class="number">0</span>; g &lt; goroutines; g++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(g <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            start := g * stride</span><br><span class="line">            end := start + stride</span><br><span class="line">            <span class="keyword">if</span> g == lastGoroutine &#123;</span><br><span class="line">                end = totalNumbers</span><br><span class="line">            &#125;</span><br><span class="line">            bubbleSort(numbers[start:end])</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(g)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="comment">// Ugh, we have to sort the entire list again.</span></span><br><span class="line">    bubbleSort(numbers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В листинге 8 представлена bubbleSortConcurrent функция, которая является параллельной версией bubbleSort функции. Она использует несколько подпрограмм для одновременной сортировки частей списка. Однако у вас остается список отсортированных значений в виде фрагментов. Учитывая список из 36 номеров, разделенных на группы по 12, это будет результирующий список, если весь список не будет отсортирован еще раз в строке 25.</p><p>Листинг 9</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Before:</span><br><span class="line">  25 51 15 57 87 10 10 85 90 32 98 53</span><br><span class="line">  91 82 84 97 67 37 71 94 26  2 81 79</span><br><span class="line">  66 70 93 86 19 81 52 75 85 10 87 49</span><br><span class="line"></span><br><span class="line">After:</span><br><span class="line">  10 10 15 25 32 51 53 57 85 87 90 98</span><br><span class="line">   2 26 37 67 71 79 81 82 84 91 94 97</span><br><span class="line">  10 19 49 52 66 70 75 81 85 86 87 93</span><br></pre></td></tr></table></figure><p>Поскольку природа пузырьковой сортировки заключается в просмотре списка, вызов bubbleSort в строке 25 сведет на нет любые потенциальные выгоды от использования параллелизма. При пузырьковой сортировке использование параллелизма не приводит к увеличению производительности.</p><h2 id="Чтение-файлов"><a href="#Чтение-файлов" class="headerlink" title="Чтение файлов"></a>Чтение файлов</h2><p>Были представлены две рабочие нагрузки, связанные с процессором, но как насчет рабочей нагрузки, связанной с вводом-выводом? Отличается ли семантика, когда программы естественным образом переходят в состояния ожидания и выходят из них? Рассмотрим рабочую нагрузку, связанную с вводом-выводом, которая считывает файлы и выполняет текстовый поиск.</p><p>Эта первая версия представляет собой последовательную версию вызываемой функции find.</p><p>Листинг 10<br><a href="https://play.golang.org/p/8gFe5F8zweN">https://play.golang.org/p/8gFe5F8zweN</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span> <span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(topic <span class="keyword">string</span>, docs []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="number">43</span>     <span class="keyword">var</span> found <span class="keyword">int</span></span><br><span class="line"><span class="number">44</span>     <span class="keyword">for</span> _, doc := <span class="keyword">range</span> docs &#123;</span><br><span class="line"><span class="number">45</span>         items, err := read(doc)</span><br><span class="line"><span class="number">46</span>         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">47</span>             <span class="keyword">continue</span></span><br><span class="line"><span class="number">48</span>         &#125;</span><br><span class="line"><span class="number">49</span>         <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line"><span class="number">50</span>             <span class="keyword">if</span> strings.Contains(item.Description, topic) &#123;</span><br><span class="line"><span class="number">51</span>                 found++</span><br><span class="line"><span class="number">52</span>             &#125;</span><br><span class="line"><span class="number">53</span>         &#125;</span><br><span class="line"><span class="number">54</span>     &#125;</span><br><span class="line"><span class="number">55</span>     <span class="keyword">return</span> found</span><br><span class="line"><span class="number">56</span> &#125;</span><br></pre></td></tr></table></figure><p>В листинге 10 вы видите последовательную версию find функции. В строке 43 объявляется переменная с именем found для подсчета количества раз, когда указанное topic встречается внутри данного документа. Затем в строке 44 документы повторяются, и каждый документ считывается в строке 45 с помощью read функции. Наконец, в строке 49-53 Contains функция из strings пакета используется для проверки, можно ли найти тему внутри коллекции элементов, прочитанных из документа. Если тема найдена, found переменная увеличивается на единицу.</p><p>Вот реализация read функции, которая вызывается find.</p><p>Листинг 11<br><a href="https://play.golang.org/p/8gFe5F8zweN">https://play.golang.org/p/8gFe5F8zweN</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span> <span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(doc <span class="keyword">string</span>)</span> <span class="params">([]item, error)</span></span> &#123;</span><br><span class="line"><span class="number">34</span>     time.Sleep(time.Millisecond) <span class="comment">// Simulate blocking disk read.</span></span><br><span class="line"><span class="number">35</span>     <span class="keyword">var</span> d document</span><br><span class="line"><span class="number">36</span>     <span class="keyword">if</span> err := xml.Unmarshal([]<span class="keyword">byte</span>(file), &amp;d); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">37</span>         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line"><span class="number">38</span>     &#125;</span><br><span class="line"><span class="number">39</span>     <span class="keyword">return</span> d.Channel.Items, <span class="literal">nil</span></span><br><span class="line"><span class="number">40</span> &#125;</span><br></pre></td></tr></table></figure><p>read Функция из листинга 11 начинается с time.Sleep вызова в течение одной миллисекунды. Этот вызов используется для моделирования задержки, которая могла бы возникнуть, если бы мы выполнили реальный системный вызов для чтения документа с диска. Постоянство этой задержки важно для точного измерения производительности последовательной версии find по сравнению с параллельной версией. Затем в строках 35-39 макет XML-документа, хранящийся в глобальной переменной, file преобразуется в значение struct для обработки. Наконец, коллекция элементов возвращается вызывающему абоненту в строке 39.</p><p>Теперь, когда установлена последовательная версия, вот параллельная версия.</p><p>Примечание: Есть несколько способов и опций, которыми вы можете воспользоваться при написании параллельной версии find. На данный момент не зацикливайтесь на моей конкретной реализации. Если у вас есть более читаемая версия, которая работает так же или лучше, я был бы рад, если бы вы поделились ею.</p><p>Листинг 12<br><a href="https://play.golang.org/p/8gFe5F8zweN">https://play.golang.org/p/8gFe5F8zweN</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">58</span> <span class="function"><span class="keyword">func</span> <span class="title">findConcurrent</span><span class="params">(goroutines <span class="keyword">int</span>, topic <span class="keyword">string</span>, docs []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="number">59</span>     <span class="keyword">var</span> found <span class="keyword">int64</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="number">61</span>     ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="built_in">len</span>(docs))</span><br><span class="line"><span class="number">62</span>     <span class="keyword">for</span> _, doc := <span class="keyword">range</span> docs &#123;</span><br><span class="line"><span class="number">63</span>         ch &lt;- doc</span><br><span class="line"><span class="number">64</span>     &#125;</span><br><span class="line"><span class="number">65</span>     <span class="built_in">close</span>(ch)</span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">67</span>     <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="number">68</span>     wg.Add(goroutines)</span><br><span class="line"><span class="number">69</span></span><br><span class="line"><span class="number">70</span>     <span class="keyword">for</span> g := <span class="number">0</span>; g &lt; goroutines; g++ &#123;</span><br><span class="line"><span class="number">71</span>         <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="number">72</span>             <span class="keyword">var</span> lFound <span class="keyword">int64</span></span><br><span class="line"><span class="number">73</span>             <span class="keyword">for</span> doc := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="number">74</span>                 items, err := read(doc)</span><br><span class="line"><span class="number">75</span>                 <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">76</span>                     <span class="keyword">continue</span></span><br><span class="line"><span class="number">77</span>                 &#125;</span><br><span class="line"><span class="number">78</span>                 <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line"><span class="number">79</span>                     <span class="keyword">if</span> strings.Contains(item.Description, topic) &#123;</span><br><span class="line"><span class="number">80</span>                         lFound++</span><br><span class="line"><span class="number">81</span>                     &#125;</span><br><span class="line"><span class="number">82</span>                 &#125;</span><br><span class="line"><span class="number">83</span>             &#125;</span><br><span class="line"><span class="number">84</span>             atomic.AddInt64(&amp;found, lFound)</span><br><span class="line"><span class="number">85</span>             wg.Done()</span><br><span class="line"><span class="number">86</span>         &#125;()</span><br><span class="line"><span class="number">87</span>     &#125;</span><br><span class="line"><span class="number">88</span></span><br><span class="line"><span class="number">89</span>     wg.Wait()</span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">91</span>     <span class="keyword">return</span> <span class="keyword">int</span>(found)</span><br><span class="line"><span class="number">92</span> &#125;</span><br></pre></td></tr></table></figure><p>В листинге 12 представлена findConcurrent функция, которая является параллельной версией find функции. Параллельная версия использует 30 строк кода в отличие от 13 строк кода для непараллельной версии. Моей целью при реализации параллельной версии было контролировать количество подпрограмм, которые используются для обработки неизвестного количества документов. Моим выбором был шаблон объединения, при котором канал используется для подпитки пула подпрограмм.</p><p>Кода много, поэтому я выделю только важные строки для понимания.</p><p>Строки 61-64: Канал создается и заполняется всеми документами для обработки.</p><p>Строка 65: Канал закрыт, поэтому пул подпрограмм естественным образом завершается, когда обрабатываются все документы.</p><p>Строка 70: Создан пул подпрограмм.</p><p>Строка 73-83: Каждая подпрограмма в пуле получает документ из канала, считывает документ в память и проверяет содержимое на предмет соответствия теме. При обнаружении совпадения локальная найденная переменная увеличивается.</p><p>Строка 84: Сумма подсчетов отдельных подпрограмм суммируется в итоговый подсчет.</p><p>Параллельная версия определенно сложнее последовательной, но стоит ли того сложность? Лучший способ ответить на этот вопрос еще раз - создать бенчмарк. Для этих тестов я использовал коллекцию из 1 тысячи документов с отключенным сборщиком мусора. Существует последовательная версия, которая использует find функцию, и параллельная версия, которая использует findConcurrent функцию.</p><p>Листинг 13</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSequential</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        find(<span class="string">&quot;test&quot;</span>, docs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcurrent</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        findConcurrent(runtime.NumCPU(), <span class="string">&quot;test&quot;</span>, docs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В листинге 13 показаны тестовые функции. Вот результаты, когда для всех программ доступен только один поток операционной системы / оборудования. Последовательная использует 1 программу, а параллельная версия использует runtime.NumCPU или 8 программ на моей машине. В этом случае параллельная версия использует параллелизм без параллелизма.</p><p>Листинг 14</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> Thousand Documents using <span class="number">8</span> goroutines with <span class="number">1</span> core</span><br><span class="line"><span class="number">2.9</span> GHz Intel <span class="number">4</span> Core i7</span><br><span class="line">Concurrency WITHOUT Parallelism</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">$ GOGC=off <span class="keyword">go</span> test -cpu <span class="number">1</span> -run none -bench . -benchtime <span class="number">3</span>s</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/ardanlabs/gotraining/topics/<span class="keyword">go</span>/testing/benchmarks/io-bound</span><br><span class="line">BenchmarkSequential             <span class="number">3</span><span class="number">1483458120</span> ns/op</span><br><span class="line">BenchmarkConcurrent            <span class="number">20</span> <span class="number">188941855</span> ns/op : ~<span class="number">87</span>% Faster</span><br><span class="line">BenchmarkSequentialAgain        <span class="number">2</span><span class="number">1502682536</span> ns/op</span><br><span class="line">BenchmarkConcurrentAgain       <span class="number">20</span> <span class="number">184037843</span> ns/op : ~<span class="number">88</span>% Faster</span><br></pre></td></tr></table></figure><p>Тест, приведенный в листинге 14, показывает, что параллельная версия примерно на 87-88 процентов быстрее последовательной версии, когда для всех программ доступен только один поток операционной системы / оборудования. Это то, чего я ожидал, поскольку все программы эффективно используют единый поток операционной системы / оборудования. Естественное переключение контекста, происходящее для каждой подпрограммы в read вызове, позволяет со временем выполнять больше работы в одном потоке операционной системы / оборудования.</p><p>Вот эталон при использовании параллелизма с параллелизмом.</p><p>Листинг 15</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">10 Thousand Documents using 8 goroutines with 1 core</span><br><span class="line">2.9 GHz Intel 4 Core i7</span><br><span class="line">Concurrency WITH Parallelism</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">$ GOGC=off go <span class="built_in">test</span> -run none -bench . -benchtime 3s</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/ardanlabs/gotraining/topics/go/testing/benchmarks/io-bound</span><br><span class="line">BenchmarkSequential-8               31490947198 ns/op</span><br><span class="line">BenchmarkConcurrent-8              20 187382200 ns/op : ~88% Faster</span><br><span class="line">BenchmarkSequentialAgain-8          31416126029 ns/op</span><br><span class="line">BenchmarkConcurrentAgain-8         20 185965460 ns/op : ~87% Faster</span><br></pre></td></tr></table></figure><p>Тест, приведенный в листинге 15, показывает, что добавление дополнительных потоков операционной системы / оборудования не обеспечивает повышения производительности.</p><h2 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h2><p>Целью этого поста было дать рекомендации по семантике, которую вы должны учитывать, чтобы определить, подходит ли рабочая нагрузка для использования параллелизма. Я попытался привести примеры различных типов алгоритмов и рабочих нагрузок, чтобы вы могли увидеть различия в семантике и различные инженерные решения, которые необходимо учитывать.</p><p>Вы можете ясно видеть, что при рабочих нагрузках, связанных с вводом-выводом, параллелизм не был необходим для значительного увеличения производительности. Что противоположно тому, что вы видели при работе с привязкой к процессору. Когда дело доходит до такого алгоритма, как пузырьковая сортировка, использование параллелизма усложнило бы работу без какого-либо реального повышения производительности. Важно определить, подходит ли ваша рабочая нагрузка для параллелизма, а затем определить тип рабочей нагрузки, который вы должны использовать с правильной семантикой.</p>]]></content>
    
    
    <summary type="html">Как устроен планировкщик GO - Concurrency</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Планировщик" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"/>
    
    <category term="Планировщик" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Когерентность кэша</title>
    <link href="https://goxpert.ru/2024/06/01/os/cpu_cache/"/>
    <id>https://goxpert.ru/2024/06/01/os/cpu_cache/</id>
    <published>2024-06-01T09:22:00.000Z</published>
    <updated>2024-06-05T05:49:28.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Что-такое-когерентность-кэша"><a href="#Что-такое-когерентность-кэша" class="headerlink" title="Что такое когерентность кэша?"></a>Что такое когерентность кэша?</h1><p>Когерентность кэша (англ. cache coherence) — свойство кэшей, означающее целостность данных, хранящихся в локальных кэшах для разделяемого ресурса. Когерентность кэшей — частный случай когерентности памяти.</p><p>Когда процессы в системе используют кэширование общих ресурсов, например, памяти, могут возникнуть проблемы с противоречивостью данных. Это особенно справедливо в отношении процессоров в многопроцессорной системе. Когеренция кэшей предназначена для управления такими конфликтами путём поддержания согласованности данных в разных кэшах.</p><p><img src="/images/Non_Coherent.gif" alt="Некогерентные кэши: значение одной ячейки памяти различно для двух кэшей"></p><p><img src="/images/Coherent.gif" alt="Когерентные кэши"></p><p>Когерентность определяет поведение чтений и записей в одно и то же место памяти. Кэш называется когерентным, если выполняются следующие условия:</p><ul><li>информирование о записи: изменение данных в любом из кэшей должно быть распространено на другие копии этих данных (этой линии кэша) в соседних кэшах;</li><li>сериализация транзакций: операции чтения и записи в одну и ту же ячейку памяти должны быть видимы для всех процессоров в одинаковом порядке.</li></ul><p>В этих условиях предполагается, что операции чтения и записи происходят мгновенно. Однако этого не происходит на практике из-за задержек памяти и других особенностей архитектуры. Изменения, сделанные процессором<br>P1, могут быть не видны процессору P2, если чтение произошло через очень маленький промежуток времени после записи.<br>Модель консистентности памяти определяет, когда записанное значение будет видно при чтении из другого потока.</p><p><img src="/images/Cache_Coherency_Generic.png" alt="Рисунок 1"></p><p>На Рисуноке 1 несколько кэшей для разделяемого ресурса памяти. Если процесс в верхней части имеет копию блока памяти из предыдущего чтения, а нижний клиент изменяет блок памяти, копия данных в кэше верхнего процесса становится устаревшей, если не используются какие-либо уведомления об изменении или проверки изменений.</p><h2 id="Механизмы-когерентности-кэшей"><a href="#Механизмы-когерентности-кэшей" class="headerlink" title="Механизмы когерентности кэшей"></a>Механизмы когерентности кэшей</h2><p>Три основных механизма обеспечения когерентности кэшей — с использованием справочника (directory), отслеживание (snooping) и перехват (snarfing).</p><p>При использовании справочника информация о состоянии блока физической памяти содержится только в одном месте, называемом справочником (при этом физически справочник может быть распределён по узлам системы).</p><p>В механизме отслеживания каждый кэш, который содержит копию данных некоторого блока физической памяти, имеет также соответствующую копию служебной информации о его состоянии. Централизованная система записей отсутствует. Обычно кэши расположены на общей (разделяемой) шине и контроллеры всех кэшей наблюдают за шиной (просматривают её) для определения того, не содержат ли они копию соответствующего блока.</p><p>При применении перехвата, когда из какого-либо одного кэша данные переписываются в оперативную память, контроллеры остальных получают сигнал об этом изменении («перехватывают» информацию об изменении данных) и, если необходимо, изменяют соответствующие данные в своих кэшах.</p><p>Системы распределенной разделяемой памяти[англ.] используют похожие механизмы для поддержания согласованности между блоками памяти в слабосвязанных системах.</p>]]></content>
    
    
    <summary type="html">Когерентность кэша (англ. cache coherence) — свойство кэшей, означающее целостность данных, хранящихся в локальных кэшах для разделяемого ресурса</summary>
    
    
    
    <category term="ОС" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/"/>
    
    <category term="CPU cache" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/CPU-cache/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Отладка cети с помощью eBPF</title>
    <link href="https://goxpert.ru/2024/06/01/os/ebpf_network/"/>
    <id>https://goxpert.ru/2024/06/01/os/ebpf_network/</id>
    <published>2024-06-01T09:16:00.000Z</published>
    <updated>2024-06-09T06:36:42.454Z</updated>
    
    <content type="html"><![CDATA[<p>Перевод сделан <a href="/2024/06/01/helloworld/index.html">автором сайта goxpert.ru</a></p><h3 id="Краткое-содежание-перевода"><a href="#Краткое-содежание-перевода" class="headerlink" title="Краткое содежание перевода"></a>Краткое содежание <a href="https://developers.redhat.com/blog/2018/12/03/network-debugging-with-ebpf">перевода</a></h3><ul><li>Сети могут вызывать проблемы, и устранение неполадок требует использования инструментов, таких как сетевые пространства имен, виртуальные машины, tc и netfilter. </li><li>eBPF - это новая технология, которая добавляет улучшения в BPF и позволяет записывать данные в память и редактировать пакеты. </li><li>eBPF используется для устранения сложных сетевых неполадок и может быть подключена через XDP или tc. </li><li>Пример использования eBPF включает изменение флагов TCP и обработку пакетов, покидающих виртуальную машину. </li><li>eBPF становится все более популярным и внедряется непосредственно в сетевые адаптеры оборудования. </li><li>Хотя eBPF не является панацеей, она является мощным инструментом для сетевой отладки и заслуживает внимания.</li></ul><h2 id="Введение-Introduction"><a href="#Введение-Introduction" class="headerlink" title="Введение (Introduction)"></a>Введение (Introduction)</h2><p>Работать с сетями интересно, но часто они также являются источником проблем. Устранение неполадок в сети может быть сложным, а воспроизведение плохого поведения, происходящего в полевых условиях, также может быть болезненным.</p><p>К счастью, есть несколько инструментов, которые приходят на помощь: сетевые пространства имен( <a href="https://ifeanyi.co/posts/linux-namespaces-part-4/">network namespaces</a> ), виртуальные машины, tcи netfilter. Простые сетевые настройки могут быть воспроизведены с помощью сетевых пространств имен и veth устройств, в то время как более сложные настройки требуют подключения виртуальных машин к программному мосту и использования стандартных сетевых инструментов, таких как iptables или tc, для имитации некорректного поведения. Если у вас возникла проблема с ответами ICMP, генерируемыми из-за сбоя SSH-сервера, iptables -A INPUT -p tcp –dport 22 -j REJECT –reject-with icmp-host-unreachable использование правильного пространства имен или виртуальной машины может помочь.</p><p>В этой статье описывается использование eBPF ( <a href="https://lwn.net/Articles/740157/">extended BPF</a> ), расширенной версии Berkeley Packet Filter, для устранения сложных сетевых неполадок. eBPF - довольно новая технология, и проект все еще находится на ранней стадии, документация и SDK еще не готовы. Но это должно улучшиться, особенно с учетом того, что XDP (экспресс-путь передачи данных - eXpress Data Path) поставляется в <a href="https://developers.redhat.com/blog/2018/11/15/red-hat-enterprise-linux-8-beta-is-here/">Red Hat Enterprise Linux 8</a>, который вы можете загрузить и запустить прямо сейчас.</p><p>Хотя eBPF и не является серебряной пулей, я думаю, что это очень мощный инструмент для сетевой отладки, и он заслуживает внимания. Я уверен, что он сыграет действительно важную роль в будущем сетей.</p><h2 id="Проблема-The-problem"><a href="#Проблема-The-problem" class="headerlink" title="Проблема (The problem)"></a>Проблема (The problem)</h2><p>Я отлаживал проблему с сетью <a href="https://developers.redhat.com/search?t=Open+vSwitch">Open vSwitch</a> (OVS), повлиявшую на очень сложную установку: некоторые TCP-пакеты были скремблированы(разрознены) и доставлялись не по порядку, а пропускная способность между виртуальными машинами падала с устойчивых 6 Гбит / с до колеблющихся 2-4 Гбит / с. После некоторого анализа выяснилось, что первый TCP-пакет каждого соединения с установленным флагом PSH отправлялся не по порядку: только первый и только по одному на каждое соединение.</p><p>Я попытался повторить настройку с двумя виртуальными машинами, и после множества справочных страниц и поисков в Интернете я обнаружил, что оба iptables и nftables не могут изменять флаги TCP, хотя tc могли, но это может только перезаписать флаги, нарушая новые подключения и TCP в целом.</p><p>Вероятно, я мог бы справиться с этим, используя комбинацию iptables mark, conntrack и tc, но потом я подумал: это могло бы быть работой для eBPF.</p><h2 id="Что-такое-eBPF-What-is-eBPF"><a href="#Что-такое-eBPF-What-is-eBPF" class="headerlink" title="Что такое eBPF? (What is eBPF?)"></a>Что такое eBPF? (What is eBPF?)</h2><p>eBPF - это расширенная версия фильтра пакетов Berkeley. Он добавляет множество улучшений в BPF; в первую очередь, он позволяет записывать данные в память, а не просто считывать их, поэтому он также может редактировать пакеты в дополнение к их фильтрации.</p><p>eBPF часто называют BPF, в то время как BPF называется cBPF (классический BPF), поэтому слово BPF может использоваться для обозначения обоих, в зависимости от контекста: здесь я всегда имею в виду расширенную версию.</p><p>Изначально eBPF использует очень простую виртуальную машину с байт-кодом, которая может выполнять небольшие фрагменты байт-кода и редактировать некоторые буферы в памяти. eBPF поставляется с некоторыми ограничениями, предотвращающими его злонамеренное использование:</p><ul><li>Циклы запрещены, поэтому программа завершит работу через определенное время.</li><li>Он не может получить доступ к памяти, кроме стека и резервного буфера.</li><li>Могут вызываться только функции ядра из белого списка.</li></ul><p>Загруженная программа может быть загружена в ядро многими способами, выполняя <a href="http://www.brendangregg.com/ebpf.html">множество операций отладки и трассировки</a>. В данном случае нас интересует, как eBPF работает с сетевой подсистемой. Есть два способа использования программы eBPF:</p><ul><li>Подключается через XDP к самому раннему пути RX физической или виртуальной сетевой карты</li><li>Подключается через tc к qdisc точно так же, как обычное действие, при входе или выходе</li></ul><p>Чтобы создать программу eBPF для подключения, достаточно написать некоторый код на C и преобразовать его в байт-код. Ниже простой пример использования XDP:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="keyword">int</span> xdp_main(<span class="keyword">struct</span> xdp_md *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    void *data_end = (void *)(uintptr_t)ctx-&gt;data_end;</span><br><span class="line">    void *data = (void *)(uintptr_t)ctx-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> ethhdr *eth = data;</span><br><span class="line">    <span class="keyword">struct</span> iphdr *iph = (<span class="keyword">struct</span> iphdr *)(eth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">struct</span> icmphdr *icmph = (<span class="keyword">struct</span> icmphdr *)(iph + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sanity check needed by the eBPF verifier */</span></span><br><span class="line">    <span class="comment">/* верификатору eBPF требуется проверка работоспособности */</span></span><br><span class="line">    <span class="keyword">if</span> (icmph + <span class="number">1</span> &gt; data_end)</span><br><span class="line">        <span class="keyword">return</span> XDP_PASS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* matched a pong packet */</span></span><br><span class="line">    / * соответствует пакету pong */</span><br><span class="line">    <span class="keyword">if</span> (eth-&gt;h_proto != ntohs(ETH_P_IP) ||</span><br><span class="line">        iph-&gt;protocol != IPPROTO_ICMP ||</span><br><span class="line">        icmph-&gt;<span class="keyword">type</span> != ICMP_ECHOREPLY)</span><br><span class="line">        <span class="keyword">return</span> XDP_PASS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iph-&gt;ttl) &#123;</span><br><span class="line">        <span class="comment">/* save the old TTL to recalculate the checksum */</span></span><br><span class="line">        <span class="comment">/* сохраните старый TTL для пересчета контрольной суммы */</span></span><br><span class="line">        uint16_t *ttlproto = (uint16_t *)&amp;iph-&gt;ttl;</span><br><span class="line">        uint16_t old_ttlproto = *ttlproto;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set the TTL to a pseudorandom number 1 &lt; x &lt; TTL */</span></span><br><span class="line">        <span class="comment">/* установите для TTL псевдослучайное число 1 &lt; x &lt; TTL */</span></span><br><span class="line">        iph-&gt;ttl = bpf_get_prandom_u32() % iph-&gt;ttl + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* recalculate the checksum; otherwise, the IP stack will drop it */</span></span><br><span class="line">        <span class="comment">/* пересчитайте контрольную сумму; в противном случае стек IP-адресов удалит ее */</span></span><br><span class="line">        csum_replace2(&amp;iph-&gt;check, old_ttlproto, *ttlproto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char _license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure><p>Приведенный выше фрагмент, лишенный include инструкций, помощников и всего ненужного кода, представляет собой программу XDP, которая изменяет TTL полученных эхо-ответов ICMP, а именно pongs, на случайное число. Основная функция получает struct xdp_md, который содержит два указателя на начало и конец пакета.</p><p>Чтобы скомпилировать наш код в байт-код eBPF, необходим компилятор с его поддержкой. Clang поддерживает его и создает байт-код eBPF, указывая bpf в качестве целевого во время компиляции:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -target bpf -c xdp_manglepong.c -o xdp_manglepong.o</span><br></pre></td></tr></table></figure><p>Приведенная выше команда создает файл, который выглядит как обычный объектный файл, но при проверке вы увидите, что указанный тип компьютера будет Linux eBPF, а не собственный тип операционной системы:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h xdp_manglepong.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7</span>f <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              <span class="number">2</span><span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">  Machine:                           Linux BPF  &lt;--- HERE (ЗДЕСЬ)</span></span><br><span class="line"><span class="string">  [...]</span></span><br></pre></td></tr></table></figure><p>После упаковки в обычный объектный файл, eBPF программа готова к загрузке и подключению к устройству через XDP. Это можно сделать с помощью ip из iproute2 пакета, используя следующий синтаксис:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip -force link set dev wlan0 xdp object xdp_manglepong.o verbose</span></span><br></pre></td></tr></table></figure><p>Эта команда определяет целевой интерфейс wlan0, и с помощью -force опции она перезапишет любой существующий, уже загруженный код eBPF. После загрузки байт-кода eBPF система ведет себя следующим образом:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ping -c10 192.168.85.1</span><br><span class="line">PING 192.168.85.1 (192.168.85.1) 56(84) байт данных.</span><br><span class="line">64 байта из 192.168.85.1: icmp_seq = 1 ttl = 41 time = 0,929 мс</span><br><span class="line">64 байта из 192.168.85.1: icmp_seq = 2 ttl = 7 time = 0,954 мс</span><br><span class="line">64 байта из 192.168.85.1: icmp_seq = 3 ttl = 17 time = 0.944 мс</span><br><span class="line">64 байта из 192.168.85.1: icmp_seq = 4 ttl = 64 time = 0.948 мс</span><br><span class="line">64 байта из 192.168.85.1: icmp_seq = 5 ttl = 9 time = 0.803 мс</span><br><span class="line">64 байта из 192.168.85.1: icmp_seq = 6 ttl = 22 time = 0,780 мс</span><br><span class="line">64 байта из 192.168.85.1: icmp_seq = 7 ttl = 32 time = 0.847 мс</span><br><span class="line">64 байта из 192.168.85.1: icmp_seq = 8 ttl = 50 time = 0,750 мс</span><br><span class="line">64 байта из 192.168.85.1: icmp_seq = 9 ttl = 24 time = 0,744 мс</span><br><span class="line">64 байта из 192.168.85.1: icmp_seq = 10 ttl = 42 time = 0.791 мс</span><br><span class="line"></span><br><span class="line">--- статистика пинга 192.168.85.1 ---</span><br><span class="line">10 переданных пакетов, 10 принятых, потеря пакетов 0%, время 125 мс </span><br><span class="line">rtt min / avg / max / mdev = 0.744/0.849/0.954/0.082 мс</span><br></pre></td></tr></table></figure><p>Каждый полученный пакет проходит через eBPF, который в конечном итоге выполняет некоторое преобразование и решает отбросить или пропустить пакет.</p><h2 id="Как-eBPF-может-помочь-How-eBPF-can-help"><a href="#Как-eBPF-может-помочь-How-eBPF-can-help" class="headerlink" title="Как eBPF может помочь (How eBPF can help)"></a>Как eBPF может помочь (How eBPF can help)</h2><p>Возвращаясь к исходной сетевой проблеме, мне нужно было изменить некоторые флаги TCP, только по одному на соединение, и ни iptables ни tc не разрешать это делать. Написать код на C для этого сценария было бы очень просто: настройте две виртуальные машины, соединенные мостом OVS, и просто подключите eBPF к одному из двух виртуальных устройств виртуальной машины.</p><p>Это выглядит как хорошее решение, но вы должны учитывать, что XDP поддерживает только обработку принятых пакетов, и подключение eBPF по rx пути принимающей виртуальной машины никак не повлияет на коммутатор.</p><p>Чтобы должным образом решить эту проблему, eBPF должен быть загружен с помощью tc и подключен по выходному пути внутри виртуальной машины, поскольку tc программы eBPF могут загружаться и подключаться к qdisc точно так же, как любое другое действие. Для обработки пакетов, покидающих хост, необходим выходной qdisc, к которому нужно подключить eBPF.</p><p>При загрузке программы eBPF между XDP и tc API есть небольшие различия: имя раздела по умолчанию отличается, аргумент функции main имеет другой структурный тип, и возвращаемые значения отличаются, но это не является большой проблемой. Ниже приведен фрагмент программы, которая выполняет искажение TCP при подключении к tc действию:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#define RATIO <span class="number">10</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;action&quot;</span>)</span><br><span class="line"><span class="keyword">int</span> bpf_main(<span class="keyword">struct</span> __sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    void *data = (void *)(uintptr_t)skb-&gt;data;</span><br><span class="line">    void *data_end = (void *)(uintptr_t)skb-&gt;data_end;</span><br><span class="line">    <span class="keyword">struct</span> ethhdr *eth = data;</span><br><span class="line">    <span class="keyword">struct</span> iphdr *iph = (<span class="keyword">struct</span> iphdr *)(eth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">struct</span> tcphdr *tcphdr = (<span class="keyword">struct</span> tcphdr *)(iph + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sanity check needed by the eBPF verifier */</span></span><br><span class="line">    <span class="comment">/* верификатору eBPF требуется проверка работоспособности */</span></span><br><span class="line">    <span class="keyword">if</span> ((void *)(tcphdr + <span class="number">1</span>) &gt; data_end)</span><br><span class="line">        <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip non-TCP packets */</span></span><br><span class="line">    <span class="comment">/* пропускает пакеты, отличные от TCP */</span></span><br><span class="line">    <span class="keyword">if</span> (eth-&gt;h_proto != __constant_htons(ETH_P_IP) || iph-&gt;protocol != IPPROTO_TCP)</span><br><span class="line">        <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* incompatible flags, or PSH already set */</span></span><br><span class="line">    <span class="comment">/* флаги несовместимости или PSH уже установлены */</span></span><br><span class="line">    <span class="keyword">if</span> (tcphdr-&gt;syn || tcphdr-&gt;fin || tcphdr-&gt;rst || tcphdr-&gt;psh)</span><br><span class="line">        <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bpf_get_prandom_u32() % RATIO == <span class="number">0</span>)</span><br><span class="line">        tcphdr-&gt;psh = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char _license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure><p>Компиляция в байт-код выполняется, как в предыдущем примере XDP, следующим образом:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -целевой bpf -c tcp_psh.c -o tcp_psh.o</span><br></pre></td></tr></table></figure><p>Но загрузка отличается:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tc qdisc add dev eth0 clsact</span></span><br><span class="line"><span class="comment"># tc filter add dev eth0 egress matchall action bpf object-file tcp_psh.o</span></span><br></pre></td></tr></table></figure><p>На этом этапе eBPF загружен в нужное место, а пакеты, покидающие виртуальную машину, искажены. Проверив полученные пакеты от второй виртуальной машины, вы можете увидеть следующее:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># tcpdump -tnni eth0 -Q in</span><br><span class="line">[<span class="number">1579537.890082</span>] device eth0 entered promiscuous mode</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on eth0, link-<span class="keyword">type</span> EN10MB (Ethernet), capture size <span class="number">262144</span> bytes</span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">809667041</span>:<span class="number">809681521</span>, ack <span class="number">3046223642</span>, length <span class="number">14480</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">14480</span>:<span class="number">43440</span>, ack <span class="number">1</span>, length <span class="number">28960</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">43440</span>:<span class="number">101360</span>, ack <span class="number">1</span>, length <span class="number">57920</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [P.], seq <span class="number">101360</span>:<span class="number">131072</span>, ack <span class="number">1</span>, length <span class="number">29712</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">131072</span>:<span class="number">145552</span>, ack <span class="number">1</span>, length <span class="number">14480</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">145552</span>:<span class="number">174512</span>, ack <span class="number">1</span>, length <span class="number">28960</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">174512</span>:<span class="number">210712</span>, ack <span class="number">1</span>, length <span class="number">36200</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">210712</span>:<span class="number">232432</span>, ack <span class="number">1</span>, length <span class="number">21720</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">232432</span>:<span class="number">246912</span>, ack <span class="number">1</span>, length <span class="number">14480</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [P.], seq <span class="number">246912</span>:<span class="number">262144</span>, ack <span class="number">1</span>, length <span class="number">15232</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">262144</span>:<span class="number">276624</span>, ack <span class="number">1</span>, length <span class="number">14480</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">276624</span>:<span class="number">305584</span>, ack <span class="number">1</span>, length <span class="number">28960</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">305584</span>:<span class="number">363504</span>, ack <span class="number">1</span>, length <span class="number">57920</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [P.], seq <span class="number">363504</span>:<span class="number">393216</span>, ack <span class="number">1</span>, length <span class="number">29712</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">393216</span>:<span class="number">407696</span>, ack <span class="number">1</span>, length <span class="number">14480</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">407696</span>:<span class="number">436656</span>, ack <span class="number">1</span>, length <span class="number">28960</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">436656</span>:<span class="number">494576</span>, ack <span class="number">1</span>, length <span class="number">57920</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [P.], seq <span class="number">494576</span>:<span class="number">524288</span>, ack <span class="number">1</span>, length <span class="number">29712</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">524288</span>:<span class="number">538768</span>, ack <span class="number">1</span>, length <span class="number">14480</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">538768</span>:<span class="number">567728</span>, ack <span class="number">1</span>, length <span class="number">28960</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">567728</span>:<span class="number">625648</span>, ack <span class="number">1</span>, length <span class="number">57920</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [.], seq <span class="number">625648</span>:<span class="number">627096</span>, ack <span class="number">1</span>, length <span class="number">1448</span></span><br><span class="line">IP <span class="number">192.168</span><span class="number">.123</span><span class="number">.1</span><span class="number">.39252</span> &gt; <span class="number">192.168</span><span class="number">.123</span><span class="number">.2</span><span class="number">.5201</span>: Flags [P.], seq <span class="number">627096</span>:<span class="number">655360</span>, ack <span class="number">1</span>, length <span class="number">28264</span></span><br></pre></td></tr></table></figure><p>tcpdump подтверждает, что новый код eBPF работает, и примерно в 1 из каждых 10 TCP-пакетов установлен флаг PSH. Используя всего 20 строк кода на C, мы выборочно искажали TCP-пакеты, покидающие виртуальную машину, воспроизводя ошибку, возникшую в полевых условиях, и все это без перекомпиляции какого-либо драйвера и даже без перезагрузки! Это значительно упростило проверку <a href="https://github.com/openvswitch/ovs/commit/9b4f08cdcaf253175edda088683bdd3db9e4c097">исправления Open vSwitch</a> способом, который невозможно было выполнить с помощью других инструментов.</p><h2 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h2><p>eBPF - довольно новая технология, и сообщество придерживается твердого мнения по поводу ее внедрения. Также стоит отметить, что проекты на основе eBPF, такие как <a href="https://lwn.net/Articles/747551/">bpfilter</a>, становятся все более популярными, и, как следствие, различные поставщики оборудования начинают внедрять поддержку eBPF непосредственно в свои сетевые карты(NIC).</p><p>Хотя eBPF не является серебряной пулей, и им не следует злоупотреблять, я думаю, что это очень мощный инструмент для сетевой отладки, и он заслуживает внимания. Я уверен, что он сыграет действительно важную роль в будущем сетей.</p><h2 id="Дополнительные-ресурсы"><a href="#Дополнительные-ресурсы" class="headerlink" title="Дополнительные ресурсы"></a>Дополнительные ресурсы</h2><p><a href="https://developers.redhat.com/search?t=Open+vSwitch">Статьи об Open vSwitch</a><br><a href="https://developers.redhat.com/search?t=Open+Virtual+Network">Статьи об открытой виртуальной сети</a><br><a href="https://developers.redhat.com/blog/2017/12/13/introducing-stapbpf-systemtaps-new-bpf-backend/">Представляем stapbpf - новый серверный модуль BPF от SystemTap</a></p><p>Последнее обновление: 14 января 2022 г.</p><p><img src="/images/ebpf.png" alt="Вот вам и eBPF"></p>]]></content>
    
    
    <summary type="html">Общие вопросы по сети</summary>
    
    
    
    <category term="ОС" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/"/>
    
    <category term="Cеть" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/C%D0%B5%D1%82%D1%8C/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Сеть</title>
    <link href="https://goxpert.ru/2024/06/01/os/netwokr/"/>
    <id>https://goxpert.ru/2024/06/01/os/netwokr/</id>
    <published>2024-06-01T09:16:00.000Z</published>
    <updated>2024-06-02T19:47:14.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Основные-отличия-TCP-и-UDP"><a href="#Основные-отличия-TCP-и-UDP" class="headerlink" title="Основные отличия TCP и UDP:"></a>Основные отличия TCP и UDP:</h1><p>Надёжность. TCP использует тайм-ауты, требует подтверждения получения данных и повторно отправляет данные при необходимости. У протокола UDP такого нет, а данные нередко теряются на этапе доставки к хосту-получателю.</p><p>Упорядоченность. TCP гарантированно передаёт пакеты данных в той последовательности, которая была задана изначально. В UDP такие возможности не реализованы.</p><p>Скорость. UDP значительно быстрее TCP.</p><p>Метод передачи данных. TCP предполагает потоковую передачу данных, границы фрагментов данных не обозначены. UDP использует метод датаграмм, когда получатель проверяет целостность пакетов лишь при получении сообщения.</p><p>TCP больше подходит для длительных сеансов, а UDP — для коротких.</p><p><a href="/images/TCPvsUDP.pdf">статья TCP vs UDP</a></p><p>Современный мир завязан на системах связи, когда различные устройства «общаются» между собой посредством «правил», или протоколов модели OSI (Open Systems Interconnection model), определяющей методы взаимодействия. В тексте рассмотрим два самых популярных протокола транспортного уровня — TCP и UDP — и сравним их.</p><p>Прежде всего напомним, что такое сетевые протоколы. Сетевые протоколы — это правила взаимодействия устройств в сети, благодаря которым различные девайсы могут работать друг с другом, несмотря на конструктивные различия. На транспортном уровне происходит прием данных с сетевого уровня и передача их на сеансовый уровень.</p><h1 id="TCP-—-протокол-транспортного-уровня"><a href="#TCP-—-протокол-транспортного-уровня" class="headerlink" title="TCP — протокол транспортного уровня"></a>TCP — протокол транспортного уровня</h1><p>Первым из рассматриваемых протоколов будет TCP, или Transmission Control Protocol, который используется для транспортировки сообщений между устройствами в сети.</p><p>В сети файлы не передаются целиком, а дробятся и передаются в виде относительно небольших сообщений. Далее они передаются другому устройству — получателю, где повторно собираются в файл.</p><p>Например, человек хочет скачать картинку. Сервер обрабатывает запрос и высылает в ответ требуемое изображение. Ему, в свою очередь, необходим путь или канал, по которому он будет передавать информацию. Поэтому сервер обращается к сетевому сокету для установки требуемого соединения и отправки картинки. Сервер дробит данные, инкапсулирует их в блоки, которые передаются на уровень TCP получателя при помощи IP-протокола. Далее получатель подтверждает факт передачи.</p><p>У протокола TCP есть несколько особенностей:</p><ul><li>Система нумерации сегментов. TCP отслеживает передаваемые и принимаемые сегменты, присваивая номера каждому из них. Байтам данных, которые должны быть переданы, присваивается определенный номер байта, в то время как сегментам присваиваются порядковые номера.</li><li>Управление потоком. Функция ограничивает скорость, с которой отправитель передает данные. Это делается для обеспечения надежности доставки, в том числе чтобы компьютер не генерировал пакетов больше, чем может принять другое устройство. Если говорить простым языком, то получатель постоянно сообщает отправителю о том, какой объем данных может быть получен.</li><li>Контроль ошибок. Функция реализуется для повышения надежности путем проверки байтов на целостность.</li><li>Контроль перегрузки сети. Протокол TCP учитывает уровень перегрузки в сети, определяемый объемом данных, отправленных узлом</li></ul><h1 id="Примеры-применения-сетевого-протокола-TCP"><a href="#Примеры-применения-сетевого-протокола-TCP" class="headerlink" title="Примеры применения сетевого протокола TCP"></a>Примеры применения сетевого протокола TCP</h1><p>Протокол TCP гарантирует доставку, а также обеспечивает целостность данных, передаваемых в сети. Поэтому он применяется для передачи данных, которые чувствительны к нарушению целостности, — например, текстов, файлов и т.п. Вот несколько протоколов, которые работают по TCP: </p><ul><li>SSH, FTP, Telnet: в данных протоколах TCP используется для обмена файлами.</li><li>SMTP, POP, IMAP: протоколы, где TCP отвечает за передачу сообщений электронной почты.</li><li>HTTP/HTTPS: протоколы, где TCP отвечает за загрузку страниц из интернета.<br>Эти примеры работают на уровне приложений стека TCP/IP и передают данные вниз к TCP, на транспортный уровень</li></ul><h1 id="Строение-протокола-TCP"><a href="#Строение-протокола-TCP" class="headerlink" title="Строение протокола TCP"></a>Строение протокола TCP</h1><p><img src="/images/tcp1.png" alt="Структура пакета протокола TCP/IP."></p><p>В каждый пакет данных TCP добавляет заголовок общим объемом в 20 байт (или октетов), в котором содержатся 10 обязательных полей:</p><ul><li>Порт источника — порт устройства-отправителя.</li><li>Порт назначения — порт принимающего устройства.</li><li>Порядковый номер. Устройство, инициирующее TCP-соединение, должно выбрать случайный начальный порядковый номер, который затем увеличивается в соответствии с количеством переданных байтов.</li><li>Номер подтверждения. Принимающее устройство увеличивает этот номер с нуля в соответствии с количеством полученных байтов.</li><li>Сдвиг данных TCP. Данный параметр определяет размер заголовка, чтобы система могла понять, где начинаются данные.</li><li>Зарезервированные данные — зарезервированное поле, значение которого всегда равно нулю.</li><li>Флаги управления. TCP использует девять флагов для управления потоком данных в определенных ситуациях — например, при инициировании сброса сессии.</li><li>Размер окна — самая важная часть заголовка TCP. Это поле используется получателем для указания отправителю объема данных, которые он может принять.</li><li>Контрольная сумма. Отправитель генерирует контрольную сумму и передает ее в заголовке каждого пакета. Принимающее устройство может использовать контрольную сумму для проверки ошибок в полученном файле.</li><li>Срочный указатель — это предлагаемая протоколом возможность помечать некоторые байты данных тегом «Срочно» для их пересылки и обработки вне очереди.</li><li>Поле опции. Может использоваться для расширения протокола или его тестирования.</li></ul><h2 id="Ускоряем-работу-протокола-TCP-при-хорошем-соединении-или-выжимаем-максимум"><a href="#Ускоряем-работу-протокола-TCP-при-хорошем-соединении-или-выжимаем-максимум" class="headerlink" title="Ускоряем работу протокола TCP при хорошем соединении или выжимаем максимум"></a>Ускоряем работу протокола TCP при хорошем соединении или выжимаем максимум</h2><p>TCP используется при передаче данных в таких протоколах, как HTTP, Telnet, FTP, SMTP. При использовании протокола нужно учесть, что при увеличении потери пакетов время, затрачиваемое на доставку файла, увеличивается.</p><p>Чтобы достичь максимальной пропускной способности TCP-соединения, можно выполнить следующие шаги:</p><p>Увеличить размер окна. Размер окна, или TCP Window Size, — это количество данных, которое может быть передано в данный момент без подтверждения. Это значение устанавливается в начале соединения между устройствами. Однако это значение можно изменить заранее, введя команду regedit в поиске и перейдя по следующему пути: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\AFD\Parameters\DefaultSendWindow</span><br></pre></td></tr></table></figure><p>Увеличение параметра приведет к тому, что уменьшится количество проверок полученных данных и увеличится эффективность использования полосы пропускания. Также, перейдя по пути:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters</span><br></pre></td></tr></table></figure><p>можно добавить значение Tcp1323Opts, которое отвечает за изменение размера окна и управление временной меткой.</p><p>Изменение значения SackOpts. SACK, или селективное подтверждение, крайне важно для подключений с большим размером окна. Без этой функции проверка полученных данных выполняется только по последнему номеру последовательности полученных данных. Но с включением этой функции появляется возможность подтверждать получение отдельных блоков. Чтобы изменить данный параметр, можно перейти по пути:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</span><br></pre></td></tr></table></figure><p>и выбрать параметр SackOpts. </p><p>Изменение значения TcpMaxDupAcks. Данный параметр отвечает за количество полученных подтверждений о передаче. Стандартное значение состоит из одного подтверждения и двух дубликатов. Параметр можно изменить, перейдя по пути:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</span><br></pre></td></tr></table></figure><p>и выбрав TcpMaxDupAcks. Это позволит вам назначать количество требуемых подтверждений для запуска быстрой повторной передачи, что в результате скажется на скорости передачи данных.</p><p>Стоит отметить, что данными манипуляциями выигрываются доли секунд, поэтому сильно прироста скорости вы не увидите.</p><h2 id="UDP-—-протокол-транспортного-уровня"><a href="#UDP-—-протокол-транспортного-уровня" class="headerlink" title="UDP — протокол транспортного уровня"></a>UDP — протокол транспортного уровня</h2><p>Если нам очень важна скорость передачи, а вот потеря пакетов не так критична (как, например, в голосовом или видеотрафике), то лучше использовать UDP, или User Datagram Protocol. В отличие от TCP он обеспечивает передачу данных без получения подтверждения от пользователя. Проще говоря, просто отправляет пакеты и не ждет ничего в ответ. Из-за этого достигается высокая скорость в ущерб надежности.</p><p>Чаще всего UDP применяется в чувствительных ко времени службах, где потерять пакеты лучше, чем ждать. Звонки в Skype или Google Meet, стриминг видео, онлайн-трансляции используют этот протокол из-за того, что они чувствительны ко времени и рассчитаны на определенный уровень потерь. Вся голосовая связь через интернет работает по протоколу UDP. Также UDP очень часто используется в онлайн-играх. Аналогичная история с DNS-серверами, поскольку они должны быть быстрыми и эффективными.</p><h2 id="Примеры-использования-протокола-UDP"><a href="#Примеры-использования-протокола-UDP" class="headerlink" title="Примеры использования протокола UDP"></a>Примеры использования протокола UDP</h2><p>Примерами протоколов, использующих UDP-протокол, являются:</p><ul><li>DNS — протокол, преобразующий домены в IP-адреса, чтобы сделать возможной загрузку интернет-ресурса через браузер.</li><li>SNMP — протокол, позволяющий системному администратору проводить мониторинг, контролировать производительность сети и изменять конфигурацию подключенных устройств.</li><li>DHCP — протокол, отвечающий за автоматическое назначение IP-адреса клиенту.</li></ul><p><img src="/images/tcp2.png" alt="Структура пакета протокола UDP."></p><h1 id="Разница-между-TCP-и-UDP"><a href="#Разница-между-TCP-и-UDP" class="headerlink" title="Разница между TCP и UDP"></a>Разница между TCP и UDP</h1><p>Ключевым различием между TCP и UDP является скорость, поскольку TCP сравнительно медленнее UDP. В целом, UDP является быстрым, простым и эффективным протоколом, однако повторная передача потерянных пакетов данных возможна только в TCP. </p><p>Еще одно заметное различие между TCP и UDP заключается в том, что первый обеспечивает упорядоченную доставку данных от пользователя к серверу (и наоборот). UDP, в свою очередь, не проверяет готовность получателя и может доставлять пакеты вразнобой.</p><h1 id="TCP-vs-UDP"><a href="#TCP-vs-UDP" class="headerlink" title="TCP vs UDP"></a>TCP vs UDP</h1><p>Рассмотрим разницу характеристик протоколов TCP и UDP.</p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>Состояние соединения</td><td>Требуется установленное соединение для передачи данных (соединение должно быть закрыто после завершения передачи)</td><td>Протокол без соединения, без требований к открытию, поддержанию или прерыванию соединения</td></tr><tr><td>Гарантия доставки</td><td>Может гарантировать доставку данных получателю</td><td>Не гарантирует доставку данных получателю</td></tr><tr><td>Повторная передача данных</td><td>Повторная передача нескольких кадров в случае потери одного из них</td><td>Отсутствие повторной передачи потерянных пакетов</td></tr><tr><td>Проверка ошибок</td><td>Полная проверка ошибок</td><td>Базовый механизм проверки ошибок. Использует вышестоящие протоколы для проверки целостности</td></tr><tr><td>Метод передачи</td><td>Данные считываются как поток байтов; сообщения передаются по границам сегментов</td><td>UDP-пакеты с определенными границами; отправляются по отдельности и проверяются на целостность по прибытии</td></tr><tr><td>Сферы применения</td><td>Используется для передачи сообщений электронной почты, HTML-страниц браузеров</td><td>Видеоконференции, потоковое вещание, DNS, VoIP, IPTV</td></tr></tbody></table><h2 id="Отличия-TCP-и-UDP-при-использовании-в-VPN"><a href="#Отличия-TCP-и-UDP-при-использовании-в-VPN" class="headerlink" title="Отличия TCP и UDP при использовании в VPN"></a>Отличия TCP и UDP при использовании в VPN</h2><p>Также нередко возникает вопрос, касающийся использования данных протоколов при VPN-соединениях. К примеру, в OpenVPN существует возможность выбора между TCP- и UDP-протоколами. </p><p>Условимся, что VPN заворачивает передаваемые данные в еще один протокол (на самом деле все намного сложнее). Если ваш VPN-туннель использует в качестве транспортного протокола TCP, то передача данных по UDP-протоколу теряет свои преимущества. Как минимум на определенном участке пути. Поэтому для VPN-туннеля советуют использовать UDP-протокол, ведь TCP будет штатно работать внутри UDP-туннеля.</p><h1 id="Итог-сравнения-протоколов-TCP-и-UDP"><a href="#Итог-сравнения-протоколов-TCP-и-UDP" class="headerlink" title="Итог сравнения протоколов TCP и  UDP"></a>Итог сравнения протоколов TCP и  UDP</h1><p>Каждый протокол хорош под свои задачи, недаром они являются одними из самых распространенных в интернете. В завершение сравнения TCP и UDP можно выделить, что TCP применяется там, где важно доставить все данные в определенном порядке. Зона применения UDP, в свою очередь, — это голосовой и видеотрафик, где доставка всех пакетов не является обязательной. </p><p>Также серьезным отличием TCP от UDP является размер заголовков. У TCP он составляет 20-60 байт, а у UDP — всего 8 байт. Это показывает, насколько сложнее устроен протокол TCP, ведь он приоритизирует трафик и проверяет блоки данных на наличие ошибок.</p>]]></content>
    
    
    <summary type="html">Общие вопросы по сети</summary>
    
    
    
    <category term="ОС" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/"/>
    
    <category term="Cеть" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/C%D0%B5%D1%82%D1%8C/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>namespaces</title>
    <link href="https://goxpert.ru/2024/06/01/os/namespaces/"/>
    <id>https://goxpert.ru/2024/06/01/os/namespaces/</id>
    <published>2024-06-01T09:16:00.000Z</published>
    <updated>2024-06-09T09:52:27.582Z</updated>
    
    <content type="html"><![CDATA[<p>Перевод сделан <a href="/2024/06/01/helloworld/index.html">автором сайта goxpert.ru</a></p><h3 id="Краткое-содежание-перевода"><a href="#Краткое-содежание-перевода" class="headerlink" title="Краткое содежание перевода"></a>Краткое содежание <a href="https://ifeanyi.co/posts/linux-namespaces-part-1/">перевода</a></h3><ul><li>Пространство имен в Linux является абстракцией от ресурсов операционной системы. </li><li>Пространства имен инкапсулируют системные ресурсы, связанные с различными аспектами системы. </li><li>Пространства имен являются необходимым условием для запуска любого процесса в системе. </li><li>Коробки позволяют добавлять и удалять содержимое без влияния на другие коробки. </li><li>Пространства имен могут содержать одну и ту же копию ресурсов, что может привести к изменениям, видимым во всех других пространствах имен. </li><li>Контейнеры являются обычными процессами с разными пространствами имен, отличными от других процессов. </li><li>Изоляция в контейнерах достигается с помощью пространств имен, чем меньше количество совместно используемых ресурсов, тем более изолированным является процесс. </li><li>В оставшейся части поста будет рассмотрена реализация программы isolate, которая запускает командный процесс в новом процессе, изолированном от остальной системы. </li></ul><h2 id="Глубокое-погружение-в-пространства-имен-Linux"><a href="#Глубокое-погружение-в-пространства-имен-Linux" class="headerlink" title="Глубокое погружение в пространства имен Linux"></a>Глубокое погружение в пространства имен Linux</h2><p>В этой серии постов мы внимательно рассмотрим один из основных компонентов <a href="https://www.docker.com/resources/what-container">контейнера</a> - пространства имен. В процессе мы создадим более простой клон docker run команды - нашу собственную программу, которая примет в качестве входных данных команду (вместе с ее аргументами, если таковые имеются) и запустит процесс в контейнере для ее запуска, изолированный от остальной системы, подобно тому, как вы сделали бы docker run это из <a href="https://docs.docker.com/engine/reference/run/">image - образа</a>.</p><h3 id="Что-такое-пространство-имен-What-is-a-namespace"><a href="#Что-такое-пространство-имен-What-is-a-namespace" class="headerlink" title="Что такое пространство имен?(What is a namespace?)"></a>Что такое пространство имен?(What is a namespace?)</h3><p><a href="http://man7.org/linux/man-pages/man7/namespaces.7.html">Пространство имен Linux</a> - это абстракция над ресурсами операционной системы. Мы можем представить пространство имен как коробку. Внутри этого блока находятся системные ресурсы, которые в точности зависят от типа блока (пространства имен - namespaces). В настоящее время существует 7 типов пространств имен Cgroup, IPC, Network, Mount, PID, User, UTS.</p><p>Например, Network пространство имен инкапсулирует системные ресурсы, связанные с сетью, такие как сетевые интерфейсы (например, wlan0, eth0), таблицы маршрутов(route tables) и т.д., Mount пространство имен инкапсулирует файлы и каталоги в системе, PID содержит идентификаторы процессов и так далее. Итак, два экземпляра Network пространства имен A и B (соответствующие двум блокам одного типа в нашей аналогии) могут содержать разные ресурсы - возможно, A содержит wlan0, тогда как B содержит eth0 и другую копию таблицы маршрутов(route table).</p><p>Пространства имен - это не какая-то дополнительная функция или библиотека, которую вам нужно установить apt, они предоставляются самим ядром Linux и уже являются необходимым условием для запуска любого процесса в системе. В любой данный момент любой процесс P принадлежит ровно одному экземпляру каждого типа пространства имен - поэтому, когда ему нужно сказать, обновить таблицу маршрутов в системе, Linux показывает ему копию таблицы маршрутов пространства имен, к которому он принадлежит в этот момент.</p><h3 id="Для-чего-это-нужно-What-is-it-good-for"><a href="#Для-чего-это-нужно-What-is-it-good-for" class="headerlink" title="Для чего это нужно? (What is it good for?)"></a>Для чего это нужно? (What is it good for?)</h3><p>Абсолютно ни для чего… шучу. Одна хорошая вещь с ящиками заключается в том, что вы можете добавлять и удалять содержимое из одного ящика, и это не повлияет на содержимое других ящиков. Здесь та же идея с пространствами имен - процесс P может сойти с ума и выплнить sudo rm -rf / но другой процесс, Q который принадлежит другому Mount пространству имен, не пострадает, поскольку они используют разные копии этих файлов.</p><p>Однако обратите внимание, что ресурс, инкапсулированный в пространство имен, не обязательно означает, что это уникальная копия. В ряде случаев, либо по замыслу, либо из-за бреши в системе безопасности, два или более пространств имен будут содержать одну и ту же копию, например, одного и того же файла, так что изменения, внесенные в этот файл в одном Mount пространстве имен, фактически будут видны во всех других Mount пространствах имен, которые также ссылаются на него. По этой причине мы удаляем нашу аналогию с ящиками, поскольку элемент не может одновременно существовать в двух разных ящиках 😞.</p><h3 id="Неразделенность-это-забота-Unsharing-is-caring"><a href="#Неразделенность-это-забота-Unsharing-is-caring" class="headerlink" title="Неразделенность - это забота (Unsharing is caring)"></a>Неразделенность - это забота (Unsharing is caring)</h3><p>Мы можем видеть пространства имен, к которым принадлежит процесс! В типичном для Linux виде они отображаются в виде файлов в каталоге /proc/$pid/ns для данного процесса с идентификатором процесса $pid:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /proc/$$/ns</span><br><span class="line">total <span class="number">0</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> iffy iffy <span class="number">0</span> May <span class="number">18</span> <span class="number">12</span>:<span class="number">53</span> cgroup -&gt; cgroup:[<span class="number">4026531835</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> iffy iffy <span class="number">0</span> May <span class="number">18</span> <span class="number">12</span>:<span class="number">53</span> ipc -&gt; ipc:[<span class="number">4026531839</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> iffy iffy <span class="number">0</span> May <span class="number">18</span> <span class="number">12</span>:<span class="number">53</span> mnt -&gt; mnt:[<span class="number">4026531840</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> iffy iffy <span class="number">0</span> May <span class="number">18</span> <span class="number">12</span>:<span class="number">53</span> net -&gt; net:[<span class="number">4026531957</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> iffy iffy <span class="number">0</span> May <span class="number">18</span> <span class="number">12</span>:<span class="number">53</span> pid -&gt; pid:[<span class="number">4026531836</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> iffy iffy <span class="number">0</span> May <span class="number">18</span> <span class="number">12</span>:<span class="number">53</span> user -&gt; user:[<span class="number">4026531837</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> iffy iffy <span class="number">0</span> May <span class="number">18</span> <span class="number">12</span>:<span class="number">53</span> uts -&gt; uts:[<span class="number">4026531838</span>]</span><br></pre></td></tr></table></figure><p>Вы можете открыть второй терминал и запустить ту же команду, и она должна выдать вам точно такой же результат - это потому, что, как мы упоминали ранее, процесс должен принадлежать некоторому пространству имен, и если мы явно не укажите, какие именно, Linux добавит их в качестве элемента в пространства имен по умолчанию.</p><p>Давайте немного разберемся в этом. Во втором терминале мы можем запустить что-то вроде:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">iffy</span><br><span class="line">$ sudo unshare -u bash</span><br><span class="line">$ ls -l /proc/$$/ns</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">0</span> May <span class="number">18</span> <span class="number">13</span>:<span class="number">04</span> cgroup -&gt; cgroup:[<span class="number">4026531835</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">0</span> May <span class="number">18</span> <span class="number">13</span>:<span class="number">04</span> ipc -&gt; ipc:[<span class="number">4026531839</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">0</span> May <span class="number">18</span> <span class="number">13</span>:<span class="number">04</span> mnt -&gt; mnt:[<span class="number">4026531840</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">0</span> May <span class="number">18</span> <span class="number">13</span>:<span class="number">04</span> net -&gt; net:[<span class="number">4026531957</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">0</span> May <span class="number">18</span> <span class="number">13</span>:<span class="number">04</span> pid -&gt; pid:[<span class="number">4026531836</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">0</span> May <span class="number">18</span> <span class="number">13</span>:<span class="number">04</span> user -&gt; user:[<span class="number">4026531837</span>]</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">0</span> May <span class="number">18</span> <span class="number">13</span>:<span class="number">04</span> uts -&gt; uts:[<span class="number">4026532474</span>]</span><br><span class="line">$ hostname</span><br><span class="line">iffy</span><br><span class="line">$ hostname coke</span><br><span class="line">$ hostname</span><br><span class="line">coke</span><br></pre></td></tr></table></figure><p>Команда unshare запускает программу (необязательно) в новом пространстве имен. -u Флаг сообщает ей о запуске bash в новом UTS пространстве имен. Обратите внимание, как наш новый bash процесс указывает на другой uts файл, в то время как все остальные остаются прежними.</p><ul><li>Для создания новых пространств имен обычно требуется доступ суперпользователя. С этого момента мы будем предполагать, что оба unshare или наша реализация выполняются с sudo.</li></ul><p>Одно из следствий того, что мы только что сделали, заключается в том, что теперь мы можем изменять систему hostname изнутри нашего нового bash процесса, и это не повлияет ни на один другой процесс в системе. Вы можете убедиться в этом, запустив hostname в первой оболочке или новой и увидев, что имя хоста там не изменилось.</p><h3 id="Но-например-что-такое-контейнер-But-like-what-is-a-container-though"><a href="#Но-например-что-такое-контейнер-But-like-what-is-a-container-though" class="headerlink" title="Но, например, что такое контейнер? (But like, what is a container though?)"></a>Но, например, что такое контейнер? (But like, what is a container though?)</h3><p>Надеюсь, теперь у вас есть некоторое представление о том, что может делать пространство имен. Вы могли бы предположить, что контейнеры - это в основе своей обычные процессы с пространствами имен, отличными от других процессов, и вы были бы правы. На самом деле контейнер без кавычек(квот) не обязательно должен принадлежать уникальному пространству имен для каждого типа - он может использовать некоторые из них совместно.</p><p>Например, когда вы docker run –net=host redis, все, что вы делаете, это говорите docker не создавать новое Network пространство имен для redis процесса, и, как мы видели, Linux добавит этот процесс в качестве члена пространства имен по умолчанию Network, как и любой другой обычный процесс. Итак, процесс redis точно такой же, как и все остальные, с точки зрения сетевого взаимодействия. Сетевое взаимодействие здесь не является чем-то особенным,docker run давайте сделаем эту настройку для большинства пространств имен. Возникает вопрос о том, что вообще такое контейнер? Является ли процесс, который разделяет все пространства имен, кроме одного, все еще контейнером? _(ツ)_/<br>Обычно контейнеры поставляются с концепцией изоляции, достигаемой с помощью пространств имен - чем меньше количество пространств имен и ресурсов, совместно используемых процессом, тем более изолированным является процесс, и это все, что действительно имеет значение.</p><h3 id="Программа-Isolate-Isolate"><a href="#Программа-Isolate-Isolate" class="headerlink" title="Программа Isolate (Isolate)"></a>Программа Isolate (Isolate)</h3><p>В оставшейся части этого поста мы заложим основу для нашей программы, которую мы назовем isolate. isolate принимает команду в качестве аргументов и выполняет эту команду в новом процессе, изолированном от остальной системы и находящемся в своих собственных пространствах имен. В следующих публикациях мы рассмотрим добавление поддержки отдельных пространств имен, когда isolate запустим в процессе управления.</p><p>С точки зрения области применения мы сосредоточимся на User, Mount, PID и Network пространствах имен. Остальные относительно тривиальны для реализации после того, как мы закончим (фактически, здесь мы добавляем UTS поддержку в начальной реализации) и, Cgroup например, интересны только с точки зрения, выходящей за рамки этой серии (изучение cgroups - <a href="http://man7.org/linux/man-pages/man7/cgroups.7.html">другого ингредиента в контейнерах</a>, который используется для контроля того, какой объем ресурсов разрешено использовать процессу).</p><p>Пространства имен могут очень быстро усложняться, поэтому при изучении каждого пространства имен мы можем использовать множество различных путей, но мы не можем использовать их все. Мы обсудим только те пути, которые имеют отношение к программе, которую мы создаем. Каждый пост будет начинаться с некоторых экспериментов с данным пространством имен в терминале в попытке понять взаимодействия, связанные с настройкой этого пространства имен. После этого у нас уже будет представление о том, чего мы хотим достичь, и затем мы приступим к соответствующей реализации в isolate.</p><p>Чтобы не засорять посты кодом, мы не будем включать такие вещи, как вспомогательные функции, которые не являются необходимыми для понимания реализации. Вы можете найти полный исходный код здесь, на <a href="https://github.com/iffyio/isolate">Github</a>.</p><h3 id="Реализация-Implementation"><a href="#Реализация-Implementation" class="headerlink" title="Реализация (Implementation)"></a>Реализация (Implementation)</h3><p>Исходный код этого поста можно найти <a href="https://github.com/iffyio/isolate/tree/part-1">здесь</a>.</p><p>Наша isolate реализация изначально будет представлять собой простую программу, которая считывает путь к команде из stdin и клонирует новый процесс, который выполняет команду с указанными аргументами. Клонированный командный процесс будет выполняться в своем собственном UTS пространстве имен точно так же, как мы делали с unshare ранее. В последующих публикациях мы увидим, что пространства имен не обязательно работают (или даже обеспечивают изоляцию) “из коробки”, и нам нужно будет выполнить некоторые настройки после их создания (но перед выполнением фактической команды), чтобы команда действительно выполнялась изолированно.</p><p>Эта комбинация создания и настройки пространства имен потребует некоторого взаимодействия между основным isolate процессом и дочерним командным процессом. В результате частью основной работы здесь будет настройка канала связи между обоими процессами - мы будем использовать <a href="https://www.tldp.org/LDP/lpg/node11.html">Linux pipe</a> из-за его простоты с учетом нашего варианта использования.</p><p>Нам нужно сделать три вещи:</p><ol><li>Создайте основной isolate процесс, который считывает данные из stdin.</li><li>Клонируйте новый процесс, который выполнит команду в новом UTS пространстве имен.</li><li>Настройте канал таким образом, чтобы командный процесс начинал выполнение команды только после получения сигнала от основного процесса о том, что настройка пространства имен завершена.</li></ol><p>Вот основной процесс:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">params</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> **argv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse_args</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv,</span></span></span><br><span class="line"><span class="params"><span class="function">                       struct params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_ARG() do &#123; argc--; argv++; &#125; while (0)</span></span><br><span class="line">    <span class="comment">// Skip binary path</span></span><br><span class="line">    <span class="built_in">NEXT_ARG</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Nothing to do!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    params-&gt;argv = argv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> NEXT_ARG</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKSIZE (1024*1024)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> cmd_stack[STACKSIZE];</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">params</span> <span class="title">params</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;params, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct params));</span><br><span class="line">    <span class="built_in">parse_args</span>(argc, argv, &amp;params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create pipe to communicate between main and command process.</span></span><br><span class="line">    <span class="comment">// Создание пайпа для связи между основным и командным процессом.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(params.fd) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to create pipe: %m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clone command process.</span></span><br><span class="line">    <span class="comment">// Клонирование командного процесса.</span></span><br><span class="line">    <span class="keyword">int</span> clone_flags = SIGCHLD | CLONE_NEWUTS ;</span><br><span class="line">    <span class="keyword">int</span> cmd_pid = <span class="built_in">clone</span>(cmd_exec, cmd_stack + STACKSIZE, clone_flags, &amp;params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd_pid &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to clone: %m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the writable end of the pipe.</span></span><br><span class="line">    <span class="comment">// Получить доступный к записи конец пайпа.</span></span><br><span class="line">    <span class="keyword">int</span> pipe = params.fd[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some namespace setup will take place here ...</span></span><br><span class="line">    <span class="comment">// Тут будут размещаться некоторые настройки namespace ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Signal to the command process we&#x27;re done with setup.</span></span><br><span class="line">    <span class="comment">// Сигнал командному процессу, что мы закончили с настройкой.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(pipe, <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to write to pipe: %m&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">close</span>(pipe))</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to close pipe: %m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitpid</span>(cmd_pid, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to wait pid %d: %m\n&quot;</span>, cmd_pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Обратите внимание на clone_flags, которые мы передаем в наш вызов clone. Видите, как просто создать процесс в его собственном namespace? Всё, что нам нужно сделать, это установить флаг для типа namespace (CLONE_NEWUTS флаг соответствует UTS namespace), а Linux позаботится об остальном.</p><p>Далее процесс команды ожидает сигнала перед её запуском:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_exec</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Kill the cmd process if the isolate process dies.</span></span><br><span class="line">    <span class="comment">// Убить процесс cmd если процесс isolate умирает.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prctl</span>(PR_SET_PDEATHSIG, SIGKILL))</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;cannot PR_SET_PDEATHSIG for child process: %m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">params</span> *<span class="title">params</span> =</span> (struct params*) arg;</span><br><span class="line">    <span class="comment">// Wait for &#x27;setup done&#x27; signal from the main process.</span></span><br><span class="line">    <span class="comment">// Ожидание сигнала &#x27;настройка завершена&#x27; от основного процесса.    </span></span><br><span class="line">    <span class="built_in">await_setup</span>(params-&gt;fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> **argv = params-&gt;argv;</span><br><span class="line">    <span class="keyword">char</span> *cmd = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;===========%s============\n&quot;</span>, cmd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execvp</span>(cmd, argv) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to exec %s: %m\n&quot;</span>, cmd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">die</span>(<span class="string">&quot;¯\\_(ツ)_/¯&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Наконец, мы может попробовать это запустить:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./isolate sh</span><br><span class="line">===========sh============</span><br><span class="line">$ ls</span><br><span class="line">isolate  isolate.c  isolate.o  Makefile</span><br><span class="line">$ hostname</span><br><span class="line">iffy</span><br><span class="line">$ hostname coke</span><br><span class="line">$ hostname</span><br><span class="line">coke</span><br><span class="line"> <span class="comment"># Verify in a new terminal that hostname hasn&#x27;t been updated</span></span><br><span class="line"> <span class="comment"># Проверьте в новом окне терминала, что имя хоста не изменилось</span></span><br></pre></td></tr></table></figure><p>В настоящее время isolate - это немного больше, чем программа, которая просто разветвляет команду (у нас есть UTS то, что работает для нас). В следующем посте мы сделаем еще один шаг вперед, рассмотрев User пространства имен и заставим isolate запустить команду в ее собственном User пространстве имен. Там мы увидим, что нам действительно нужно проделать некоторую работу, чтобы иметь полезное пространство имен, в котором может выполняться команда.</p><p><img src="/images/isolate.png" alt="Вот вам и namespaces"></p>]]></content>
    
    
    <summary type="html">Глубокое погружение в пространства имен Linux</summary>
    
    
    
    <category term="ОС" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/"/>
    
    <category term="Namespaces" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/Namespaces/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>namespaces,часть 2</title>
    <link href="https://goxpert.ru/2024/06/01/os/namespaces2/"/>
    <id>https://goxpert.ru/2024/06/01/os/namespaces2/</id>
    <published>2024-06-01T09:16:00.000Z</published>
    <updated>2024-06-09T11:35:32.517Z</updated>
    
    <content type="html"><![CDATA[<p>Перевод сделан <a href="/2024/06/01/helloworld/index.html">автором сайта goxpert.ru</a></p><h3 id="Краткое-содежание-перевода"><a href="#Краткое-содежание-перевода" class="headerlink" title="Краткое содежание перевода"></a>Краткое содежание <a href="https://ifeanyi.co/posts/linux-namespaces-part-2/">перевода</a></h3><ul><li>Пользовательские пространства имен предоставляют возможность изолировать процессы от других процессов и пространств имен. </li><li>Linux предоставляет сопоставление идентификаторов через файловую систему /proc/pid/uid_map и /proc/pid/gid_map. </li><li>Файлы карт содержат различное содержимое в зависимости от процесса чтения. </li><li>Создание пользовательского пространства имен требует доступа суперпользователя, но они также могут владеть другими пространствами имен. </li><li>Пространства имен владельцев важны для определения привилегий процессов при выполнении привилегированных действий над ресурсами, инкапсулированными в пространствах имен. </li><li>Идентификаторы сопоставляются между пространствами имен, и процесс может выполнять операции, требующие проверки прав доступа, путем обхода сопоставлений в дереве пространства имен. </li><li>Управление пользовательскими пространствами имен сопряжено с множеством сложностей, но реализация довольно проста. </li></ul><h2 id="Глубокое-погружение-в-пространства-имен-Linux-часть-2"><a href="#Глубокое-погружение-в-пространства-имен-Linux-часть-2" class="headerlink" title="Глубокое погружение в пространства имен Linux, часть 2"></a>Глубокое погружение в пространства имен Linux, часть 2</h2><p>В <a href="/2024/06/01/os/namespaces/index.html">предыдущем посте</a> мы окунулись в воды пространства имен и в процессе увидели, насколько просто запустить процесс с изолированным UTS пространством имен. В этом посте мы проливаем свет на User пространство имен.</p><p><a href="http://man7.org/linux/man-pages/man7/user_namespaces.7.html">Пространства имен пользователей(User namespaces) </a> изолируют, среди других ресурсов, связанных с безопасностью, идентификаторы пользователей и групп в системе. В этом посте мы сосредоточимся исключительно на ресурсах user и group ID (UID и GID соответственно), поскольку они играют фундаментальную роль в проведении проверок разрешений и других действий, связанных с безопасностью, во всей системе.</p><p>В Linux эти идентификаторы (IDs) представляют собой просто целые числа, которые идентифицируют пользователей и группы в системе, и каждому процессу присваивается несколько из них, чтобы определить, к каким операциям / ресурсам этот процесс может получить доступ, а к каким нет - способность процесса наносить ущерб зависит от разрешений, связанных с присвоенными ему идентификаторами</p><h3 id="Пользовательские-пространства-имен-User-Namespaces"><a href="#Пользовательские-пространства-имен-User-Namespaces" class="headerlink" title="Пользовательские пространства имен (User Namespaces)"></a>Пользовательские пространства имен (User Namespaces)</h3><ul><li>Мы проиллюстрируем возможности пользовательских пространств имен, используя только идентификаторы пользователей(user IDs). Точно такие же взаимодействия применимы к идентификаторам групп (group IDs), которые будут рассмотрены позже в этом посте.</li></ul><p>Пространство имен пользователя имеет свою собственную копию идентификаторов пользователя и группы. Затем изоляция позволяет процессу ассоциироваться с другим набором идентификаторов в зависимости от пространства имен пользователя, к которому он принадлежит в любой данный момент. Например, процесс $pid может выполняться как root (UID 0) в пользовательском пространстве имен P и внезапно продолжить выполнение как proxy (UID 13) после переключения в другое пользовательское пространство имен Q.</p><p>Пользовательские пространства имен могут быть вложенными! Это означает, что экземпляр пользовательского пространства имен (родительский) может иметь ноль или более дочерних пространств имен, а каждое дочернее пространство имен, в свою очередь, может иметь свои собственные дочерние пространства имен и так далее … (до ограничения в 32 вложенных уровня). При создании нового пользовательского пространства имен C Linux устанавливает текущее пользовательское пространство имен P процесса, который создает C, в качестве C родительского, и впоследствии это не может быть изменено. В результате все пользовательские пространства имен имеют ровно одного родителя, образуя древовидную структуру пространств имен. И, как и в случае с деревьями, исключение находится вверху, где у нас есть корневое (или начальное, или стандартное) пространство имен - если вы уже не творите какую-то контейнерную магию, это, скорее всего, пользовательское пространство имен, к которому принадлежат все ваши процессы, поскольку при запуске системы это однопользовательское пространство имен.</p><ul><li>В этом посте мы будем использовать командные строки P$ и C$ для обозначения оболочки, которая в данный момент запущена в родительском P и дочернем C пользовательских пространствах имен соответственно.</li></ul><h3 id="Сопоставления-идентификаторов-пользователей-User-ID-Mappings"><a href="#Сопоставления-идентификаторов-пользователей-User-ID-Mappings" class="headerlink" title="Сопоставления идентификаторов пользователей (User ID Mappings)"></a>Сопоставления идентификаторов пользователей (User ID Mappings)</h3><p>Пространство имен пользователя по сути содержит набор идентификаторов(IDs) и некоторую информацию, связывающую эти идентификаторы с набором идентификаторов других пользовательских пространств имен - этот дуэт определяет полное представление процесса об идентификаторах, доступных в системе. Давайте посмотрим, как это может выглядеть:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P$ whoami</span><br><span class="line">iffy</span><br><span class="line">P$ id</span><br><span class="line">uid=1000(iffy) gid=1000(iffy)</span><br></pre></td></tr></table></figure><p>В другом окне терминала давайте запустим оболочку с помощью unshare (флаг -U создает процесс в новом пользовательском пространстве имен - user namespace):</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P$ whoami</span><br><span class="line">iffy</span><br><span class="line">P$ unshare -U bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enter a new shell that runs within a nested user namespace</span></span><br><span class="line"><span class="comment"># Входим в новый шелл, который запускается во вложенном user namespace</span></span><br><span class="line"></span><br><span class="line">C$ whoami</span><br><span class="line">nobody</span><br><span class="line">C$ id</span><br><span class="line">uid=65534(nobody) gid=65534(nogroup) </span><br><span class="line">C$ ls -l my_file</span><br><span class="line">-rw-r--r-- 1 nobody nogroup 0 May 18 16:00 my_file</span><br></pre></td></tr></table></figure><p>Подождите, кто? Теперь, когда мы находимся во вложенной оболочке в C текущий пользователь становится nobody? Мы могли бы догадаться, что, поскольку C это новое пространство имен пользователя, процесс может иметь другое представление идентификаторов, поэтому мы, возможно, не ожидали, что оно останется iffy, но nobody это неинтересно 😒. С другой стороны, это здорово, потому что мы получили изоляцию, о которой просили. Наш процесс теперь имеет другое (хотя и неполное) представление идентификаторов в системе - в настоящее время он видит всех как nobody и каждую группу как nogroup.</p><p>Информация, связывающая UID из одного пространства имен в другое, называется сопоставлением идентификаторов пользователей(User ID Mappings). Он представляет таблицы поиска от идентификаторов в текущем пространстве имен пользователя до идентификаторов в других пространствах имен пользователей, и каждое пространство имен пользователя связано ровно с одним отображением UID (в дополнение к одному отображению GID для идентификаторов групп).</p><p>Это отображение нарушено в нашей unshare оболочке. Оказывается, что новые пользовательские пространства имен начинаются с пустого отображения, и в результате в Linux по умолчанию используется ужасный nobody пользователь. Нам нужно исправить это, прежде чем мы сможем выполнять какую-либо полезную работу внутри нашего нового пространства имен. Например, в настоящее время системные вызовы (например, setuid), которые пытаются работать с UID, завершаются неудачей. Но не бойтесь! следуя традиции “все-как-файл”, Linux предоставляет это отображение через /proc файловую систему по адресу /proc/$pid/uid_map (/proc/$pid/gid_map для GID), где $pid - идентификатор процесса. Мы будем называть эти два файла файлами карт.</p><h3 id="Файлы-карт-Map-files"><a href="#Файлы-карт-Map-files" class="headerlink" title="Файлы карт (Map files)"></a>Файлы карт (Map files)</h3><p>Файлы Map(Map files) - это особые файлы в системе. насколько особые? ну, такие, которые возвращают разное содержимое всякий раз, когда вы читаете из них, в зависимости от того, из какого процесса вы читаете. Например, файл map /proc/$pid/uid_map возвращает сопоставление из UIDS в пользовательском пространстве имен, к которому $pid принадлежит процесс, с UIDS в пользовательском пространстве имен процесса чтения, и в результате содержимое, возвращаемое процессу, X может отличаться от того, что возвращается процессу, Y даже если они одновременно читают один и тот же файл map.</p><p>В частности, процесс, X который считывает файл карты UID, /proc/$pid/uid_map получает набор строк. Каждая строка отображает непрерывный диапазон UIDs в пользовательское пространство C процесса $pid, соответствующего диапазону UID в другом пространстве имен.</p><p>Каждая строка имеет формат $fromID $toID $length, где:</p><ul><li>$fromID является начальным UID диапазона для пользовательского пространства имен process $pid</li><li>$length это длина диапазона.</li><li>Перевод $toID зависит от процесса чтения X. Если X принадлежит другому пользовательскому пространству имен U, то $toID это начальный UID диапазона, в U которому $fromID соответствует. В противном случае, $toID это начальный UID диапазона в P, родительском пользовательском пространстве имен C.</li></ul><p>Например, если процесс считывает файл /proc/1409/uid_map и среди полученных строк есть 15 22 5, то UIDS с 15 по 19 в пользовательском пространстве имен процесса 1409 сопоставляются с UIDS 22-26 в отдельном пользовательском пространстве имен процесса чтения.</p><p>С другой стороны, если процесс считывает из файла /proc/$$/uid_map (или файла сопоставления для любого процесса, который принадлежит тому же пользовательскому пространству имен, что и он) и получает 15 22 5, то UIDS с 15 по 19 в его пользовательском пространстве имен C сопоставляются с UIDS с 22 по 26 в C родительском пользовательском пространстве имен.</p><p>Давайте попробуем это:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">P$ <span class="built_in">echo</span> $$</span><br><span class="line">1442</span><br><span class="line"><span class="comment"># In a new user namespace...</span></span><br><span class="line"><span class="comment"># В новом user namespace...</span></span><br><span class="line">C$ <span class="built_in">echo</span> $$</span><br><span class="line">1409</span><br><span class="line"><span class="comment"># C has no mappings to its parent since it is new</span></span><br><span class="line"><span class="comment"># C не имеет маппингов со своим родителем, так как он новый</span></span><br><span class="line">C$ cat /proc/1409/uid_map</span><br><span class="line"><span class="comment"># Empty</span></span><br><span class="line"><span class="comment"># While root namespace P has dummy mappings for all</span></span><br><span class="line"><span class="comment"># UIDs to the same UID in its non-existent parent</span></span><br><span class="line"><span class="comment"># Пусто</span></span><br><span class="line"><span class="comment"># Пока корневой namespace P имеет фиктивные маппинги для всех</span></span><br><span class="line"><span class="comment"># UIDs в те же UID в несуществующем родителе</span></span><br><span class="line">P$ cat /proc/1442/uid_map</span><br><span class="line">         0          0 4294967295</span><br><span class="line"><span class="comment"># UIDs 0 through 4294967294 in P is mapped</span></span><br><span class="line"><span class="comment"># to 4294967295 - the special no user ID - in C.</span></span><br><span class="line"><span class="comment"># UIDs с 0 до 4294967294 в P маппятся</span></span><br><span class="line"><span class="comment"># в 4294967295 - специальный no user ID - в C.</span></span><br><span class="line">C$ cat /proc/1422/uid_map</span><br><span class="line">         0 4294967295 4294967295</span><br></pre></td></tr></table></figure><p>Ладно, это было не очень интересно, поскольку это были два крайних случая, но это говорит нам о нескольких вещах:</p><ol><li>Вновь созданное пространство имен пользователя фактически будет содержать пустые файлы map.</li><li>UID 4294967295 не сопоставлен и непригоден для использования даже в root пространстве имен. Linux обрабатывает этот UID специально, чтобы показать, что идентификатора пользователя нет.</li></ol><h3 id="Написание-файлов-UID-Map-Writing-UID-Map-files"><a href="#Написание-файлов-UID-Map-Writing-UID-Map-files" class="headerlink" title="Написание файлов UID Map (Writing UID Map files)"></a>Написание файлов UID Map (Writing UID Map files)</h3><p>Чтобы исправить наше недавно созданное пространство имен пользователя C, нам просто нужно предоставить желаемые сопоставления, записав их в файл map для любого процесса, который принадлежит C (мы не можем обновить этот файл после записи в него). Запись в этот файл говорит Linux о двух вещах:</p><ol><li>Какие UID доступны процессам , принадлежащим этому целевому пользовательскому пространству имен C.</li><li>Какие UID в текущем пользовательском пространстве имен соответствуют UID в C.</li></ol><p>Например, если мы из родительского пользовательского пространства имен P запишем следующее в файл карты пользователя для дочернего пространства имен C:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1000 1</span><br><span class="line">3    0 1</span><br></pre></td></tr></table></figure><p>по сути, мы говорим Linux, что:</p><ol><li>Что касается процессов в C, то единственными UIDS, которые существуют в системе, являются UIDS 0 и 3 - например, системный вызов setuid(9) всегда завершается ошибкой с чем-то вроде недопустимого идентификатора пользователя.</li><li>UIDS 1000 и 0 in P соответствуют UIDS 0 и 3 in C - например, если процесс, запущенный как UID 1000 в P, переключается на C, он увидит, что его UID стал root 0 после переключения.</li></ol><h3 id="Пространства-имен-владельцев-и-привилегии-Owner-Namespaces-And-Privileges"><a href="#Пространства-имен-владельцев-и-привилегии-Owner-Namespaces-And-Privileges" class="headerlink" title="Пространства имен владельцев и привилегии (Owner Namespaces And Privileges)"></a>Пространства имен владельцев и привилегии (Owner Namespaces And Privileges)</h3><p>В <a href="/2024/06/01/os/namespaces/index.html">предыдущем посте</a> мы упоминали, что при создании новых пространств имен требовался доступ суперпользователя. В пользовательских пространствах имен этого требования нет. На самом деле, они также уникальны тем, что могут владеть другими пространствами имен.</p><p>Всякий раз, когда создается непользовательское пространство имен N, Linux определяет текущее пользовательское пространство имен P процесса, создающего N, владельцем пространства имен N. Если P создается вместе с другими пространствами имен в том же clone системном вызове, Linux гарантирует, что P будет создано первым и назначено владельцем других пространств имен.</p><p>Пространства имен владельцев важны, потому что процесс, запрашивающий выполнение привилегированного действия над ресурсом, инкапсулированным непользовательским пространством имен, будет проверять свои привилегии UID на соответствие пользовательскому пространству имен владельца, а не корневому пользовательскому пространству имен. Например, скажем, P является родительским пользовательским пространством имен дочерних C, а P и C владеют собственными сетевыми пространствами имен M и N соответственно, то процесс может не иметь привилегий на создание сетевых устройств, инкапсулированных в M, но может быть в состоянии сделать это для N.</p><p>Значение пространств имен владельцев для нас заключается в том, что мы можем отказаться от sudo требования при выполнении команд с помощью unshare or isolate , если мы также запрашиваем создание пользовательского пространства имен - например, unshare -u bash потребует sudo, но unshare -Uu bash - не будет тебовать sudo:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UID 1000 is a non-privileged user in the root user namespace P.</span></span><br><span class="line"><span class="comment"># UID 1000 -- это непривилегированный пользователь в корневом user namespace P.</span></span><br><span class="line">P$ id</span><br><span class="line">uid=1000(iffy) gid=1000(iffy)</span><br><span class="line"><span class="comment"># And as a result cannot create a network device in the root</span></span><br><span class="line"><span class="comment"># network namespace.</span></span><br><span class="line"><span class="comment"># И в результате не удаётся создать сетевое устройство в корневом</span></span><br><span class="line"><span class="comment"># network namespace.</span></span><br><span class="line">P$ ip link add <span class="built_in">type</span> veth</span><br><span class="line">RTNETLINK answers: Operation not permitted</span><br><span class="line"><span class="comment"># Let&#x27;s try our luck again, this time from a</span></span><br><span class="line"><span class="comment"># different user and network namespace</span></span><br><span class="line"><span class="comment"># Давайте ещё раз попытаем счастья, на этот раз с</span></span><br><span class="line"><span class="comment"># другими user и network namespace</span></span><br><span class="line">P$ unshare -nU bash <span class="comment"># <span class="doctag">NOTE:</span> no sudo ЗАМЕТКА: без sudo</span></span><br><span class="line">C$ ip link add <span class="built_in">type</span> veth</span><br><span class="line">RTNETLINK answers: Operation not permitted</span><br><span class="line"><span class="comment"># Hmm still no dice. This makes sense since only</span></span><br><span class="line"><span class="comment"># UID 0 (root) is allowed to create network devices and</span></span><br><span class="line"><span class="comment"># currently we&#x27;re nobody. Let&#x27;s fix that.</span></span><br><span class="line"><span class="comment"># Хм, пока безуспешно. Логично, только</span></span><br><span class="line"><span class="comment"># UID 0 (root) разрешено создавать сетевые устройства, а</span></span><br><span class="line"><span class="comment"># в настоящее время мы nobody. Давайте это исправим.</span></span><br><span class="line">C$ <span class="built_in">echo</span> $$</span><br><span class="line">13294</span><br><span class="line"><span class="comment"># Back in P, we map UID 1000 in P to UID 0 in C</span></span><br><span class="line"><span class="comment"># Вернувшись в P, мы маппим UID 1000 в P с UID 0 в C</span></span><br><span class="line">P$ <span class="built_in">echo</span> <span class="string">&quot;0 1000 1&quot;</span> &gt; /proc/13294/uid_map</span><br><span class="line"><span class="comment"># Who are we now?</span></span><br><span class="line"><span class="comment"># Кто мы теперь?</span></span><br><span class="line">C$ id</span><br><span class="line">uid=0(root) gid=65534(nogroup)</span><br><span class="line">C$ ip link add <span class="built_in">type</span> veth</span><br><span class="line"><span class="comment"># Success!</span></span><br><span class="line"><span class="comment"># Успех!</span></span><br></pre></td></tr></table></figure><ul><li>К сожалению, мы повторно применим требование к суперпользователю в следующем посте, поскольку isolate требуются права root в корневом пространстве имен для правильной настройки пространств имен Mount и Network. Но мы обязательно удалим привилегии перед выполнением командного процесса, чтобы убедиться, что у команды нет ненужных разрешений.</li></ul><h3 id="Как-разрешаются-идентификаторы-How-IDs-are-resolved"><a href="#Как-разрешаются-идентификаторы-How-IDs-are-resolved" class="headerlink" title="Как разрешаются идентификаторы (How IDs are resolved)"></a>Как разрешаются идентификаторы (How IDs are resolved)</h3><p>Мы только что видели, как процесс, запущенный от имени обычного пользователя, 1000 внезапно переключился на root 😮. Не волнуйтесь, никакого повышения привилегий не было. Помните, что это всего лишь сопоставление идентификаторов - хотя наш процесс думает, что он есть root в системе, Linux знает, что root в его случае означает обычный UID 1000 (благодаря нашему сопоставлению), поэтому, хотя пространства имен, принадлежащие его новому пользовательскому пространству имен (например, сетевому пространству имен в C), признают его права в качестве root, другие (например, сетевое пространство имен в P) не делают этого, поэтому процесс не может сделать ничего, чего не смог бы пользователь 1000.</p><p>Всякий раз, когда процесс во вложенном пространстве имен пользователя выполняет операцию, требующую проверки разрешений, например, создает файл, его UID в этом пространстве имен сравнивается с эквивалентным идентификатором пользователя в root пространстве имен пользователя путем обхода сопоставлений в дереве пространств имен вплоть до корневого. Выполняется обратное направление, когда он, например, считывает идентификаторы пользователей, как мы делали бы с ls -l my_file - UID владельца my_file сопоставляется из root пользовательского пространства имен в текущее пространство имен, и окончательный сопоставленный идентификатор (или nobody если сопоставление отсутствовало где-то в дереве) предоставляется процессу чтения.</p><h3 id="Идентификаторы-групп-Group-IDs"><a href="#Идентификаторы-групп-Group-IDs" class="headerlink" title="Идентификаторы групп  (Group IDs)"></a>Идентификаторы групп  (Group IDs)</h3><p>Несмотря на то, что мы попали в  C как root, мы по-прежнему ассоциируемся с ужасной nogroup в качестве идентификатора(ID) нашей группы. Нам просто нужно сделать то же самое для соответствующего /proc/$pid/gid_map. Прежде чем мы сможем это сделать, нам нужно отключить setgroups системный вызов (в этом нет необходимости, если у вашего пользователя уже есть CAP_SETGID возможность в P, но мы не будем предполагать этого, поскольку это обычно сопровождается правами суперпользователя), написав “deny” в proc/$pid/setgroups файл:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Where 13294 is the pid for the unshared process</span></span><br><span class="line"><span class="comment"># Где 13294 -- pid для unshared процесса</span></span><br><span class="line">C$ id</span><br><span class="line">uid=0(root) gid=65534(nogroup)</span><br><span class="line">P$ <span class="built_in">echo</span> deny &gt; /proc/13294/setgroups</span><br><span class="line">P$ <span class="built_in">echo</span> <span class="string">&quot;0 1000 1&quot;</span> &gt; /proc/13294/gid_map</span><br><span class="line"><span class="comment"># Our group ID mapping is reflected</span></span><br><span class="line"><span class="comment"># Наш group ID маппинг отображается</span></span><br><span class="line">C$ id</span><br><span class="line">uid=0(root) gid=0(root)</span><br></pre></td></tr></table></figure><h3 id="Реализация-Implementation"><a href="#Реализация-Implementation" class="headerlink" title="Реализация (Implementation)"></a>Реализация (Implementation)</h3><p>Исходный код этого поста можно найти <a href="https://github.com/iffyio/isolate/tree/part-2">здесь</a>.</p><p>Как вы можете видеть, управление пользовательскими пространствами имен сопряжено с множеством сложностей, но реализация довольно проста. Все, что нам нужно сделать, это записать кучу строк в файл - основная задача заключалась в том, чтобы знать, что и куда записывать. Без лишних слов, вот наши цели, которых нам нужно достичь:</p><ol><li>Клонируйте командный процесс в его собственном пользовательском пространстве имен.</li><li>Запись в файлы UID и GID map командного процесса.</li><li>Отбросьте все права суперпользователя перед выполнением команды.</li></ol><p>1 достигается простым добавлением CLONE_NEWUSER флага к нашему clone системному вызову.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> clone_flags = SIGCHLD | CLONE_NEWUTS | CLONE_NEWUSER;</span><br></pre></td></tr></table></figure><p>Для 2 мы добавляем функцию prepare_user_ns, которая консервативно предоставляет доступ к одному обычному пользователю 1000 как root.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare_userns</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> uid = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">&quot;/proc/%d/uid_map&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">sprintf</span>(line, <span class="string">&quot;0 %d 1\n&quot;</span>, uid);</span><br><span class="line">    <span class="built_in">write_file</span>(path, line);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">&quot;/proc/%d/setgroups&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">sprintf</span>(line, <span class="string">&quot;deny&quot;</span>);</span><br><span class="line">    <span class="built_in">write_file</span>(path, line);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">&quot;/proc/%d/gid_map&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">sprintf</span>(line, <span class="string">&quot;0 %d 1\n&quot;</span>, uid);</span><br><span class="line">    <span class="built_in">write_file</span>(path, line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>И вызовите его из основного процесса в родительском пользовательском пространстве имен, прямо перед тем, как мы подадим сигнал командному процессу.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Get the writable end of the pipe.</span></span><br><span class="line"><span class="comment">// Получить доступный к записи конец пайпа.</span></span><br><span class="line"><span class="keyword">int</span> pipe = params.fd[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some namespace setup will take place here ...</span></span><br><span class="line"><span class="comment">// Тут будут размещаться некоторые настройки namespace ...</span></span><br><span class="line"><span class="built_in">prepare_userns</span>(cmd_pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signal to the command process we&#x27;re done with setup.</span></span><br><span class="line"><span class="comment">// Сигнал командному процессу, что мы закончили с настройкой.</span></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Для шага 3 мы обновляем cmd_exec функцию, чтобы убедиться, что команда выполняется от имени обычного непривилегированного пользователя, 1000 который мы указали в сопоставлении (помните, что пользователь root 0 в пространстве имен user командного процесса - user 1000):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Wait for &#x27;setup done&#x27; signal from the main process.</span></span><br><span class="line"><span class="comment">// Ожидание сигнала &#x27;настройка завершена&#x27; от основного процесса.</span></span><br><span class="line"><span class="built_in">await_setup</span>(params-&gt;fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">setgid</span>(<span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">  <span class="built_in">die</span>(<span class="string">&quot;Failed to setgid: %m\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">setuid</span>(<span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">  <span class="built_in">die</span>(<span class="string">&quot;Failed to setuid: %m\n&quot;</span>);</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>И все! isolate теперь запускает процесс в изолированном пользовательском пространстве имен.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./isolate sh</span><br><span class="line">===========sh============</span><br><span class="line">$ id</span><br><span class="line">uid=0(root) gid=0(root)</span><br></pre></td></tr></table></figure><p>В этом посте было довольно много подробностей о том, как User работают пространства имен, но, в конце концов, настройка экземпляра прошла относительно безболезненно. В следующем посте мы рассмотрим возможность isolate запуска команды в ее собственном Mount пространстве имен (раскрывая тайну, стоящую за Dockerfile FROM инструкцией). Здесь нам потребуется немного больше помощи Linux, чтобы правильно настроить экземпляр.</p><p><img src="/images/isolate.png" alt="Вот вам и namespaces"></p>]]></content>
    
    
    <summary type="html">Глубокое погружение в пространства имен Linux, часть 2</summary>
    
    
    
    <category term="ОС" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/"/>
    
    <category term="Namespaces" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/Namespaces/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>namespaces,часть 3</title>
    <link href="https://goxpert.ru/2024/06/01/os/namespaces3/"/>
    <id>https://goxpert.ru/2024/06/01/os/namespaces3/</id>
    <published>2024-06-01T09:16:00.000Z</published>
    <updated>2024-06-09T12:36:26.571Z</updated>
    
    <content type="html"><![CDATA[<p>Перевод сделан <a href="/2024/06/01/helloworld/index.html">автором сайта goxpert.ru</a></p><h3 id="Краткое-содежание-перевода"><a href="#Краткое-содежание-перевода" class="headerlink" title="Краткое содежание перевода"></a>Краткое содежание <a href="https://ifeanyi.co/posts/linux-namespaces-part-3/">перевода</a></h3><ul><li>Изоляция процессов в Linux может быть достигнута с помощью пространств имен. </li><li>Пространства имен позволяют изолировать процессы от других процессов и файловых систем. </li><li>Изоляция может быть достигнута путем создания нового пространства имен для монтирования и замены корневой файловой системы. </li><li>Проект Alpine Linux предоставляет корневые файловые системы, которые могут быть использованы для изоляции команд. </li><li>Поворотный корень позволяет монтировать системные файлы в новом пространстве имен для монтирования, не нарушая изоляцию. </li><li>Реализация изоляции процессов включает создание командного процесса в новом пространстве имен, настройку пространства имен для монтирования и поворот корня. </li><li>Пространства имен PID изолируют идентификаторы процессов в системе, обеспечивая большую изоляцию для запущенной команды. </li></ul><h2 id="Глубокое-погружение-в-пространства-имен-Linux-часть-3"><a href="#Глубокое-погружение-в-пространства-имен-Linux-часть-3" class="headerlink" title="Глубокое погружение в пространства имен Linux, часть 3"></a>Глубокое погружение в пространства имен Linux, часть 3</h2><p><a href="http://man7.org/linux/man-pages/man7/mount_namespaces.7.html">Пространства имен монтирования(Mount namespaces) </a>  изолируют  ресурсы файловой системы. Это в значительной степени охватывает все, что связано с файлами в системе. Среди инкапсулированных ресурсов есть файл, содержащий список <a href="http://www.linfo.org/mount_point.html">точек монтирования</a>, которые видны процессу, и, как мы намекали в <a href="/2024/06/01/os/namespaces/index.html">вступительном посте</a>, изоляция может обеспечить такое поведение, что изменение списка (или любого другого файла) в некотором экземпляре пространства имен монтирования M(mount namespace) не влияло на этот список в другом экземпляре (так что только процессы в M наблюдают изменения).</p><h2 id="Точки-монтирования-Mount-Points"><a href="#Точки-монтирования-Mount-Points" class="headerlink" title="Точки монтирования (Mount Points)"></a>Точки монтирования (Mount Points)</h2><p>Вам может быть интересно, почему мы просто увеличили кажущийся случайным файл, содержащий список - что в нем такого особенного? Список точек монтирования определяет полное представление процесса о доступных <a href="https://www.tldp.org/LDP/sag/html/filesystems.html">файловых системах</a> в системе, и поскольку мы находимся в стране Linux с мантрой “все - файл”, видимость практически каждого ресурса определяется этим представлением - от реальных файлов и устройств до информации о том, какие другие процессы также запущены в системе. Таким образом, для isolate это огромная победа в области безопасности - иметь возможность точно указывать, о каких частях системы будут в курсе команды, которые мы запускаем. Пространства имен монтирования в сочетании с точками монтирования являются очень мощным инструментом, который позволяет нам достичь этого.</p><p>Мы можем видеть точки монтирования, видимые процессу с идентификатором $pid через /proc/$pid/mounts файл - его содержимое одинаково для всех процессов, принадлежащих к тому же пространству имен монтирования , что и $pid:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/$$/mounts</span><br><span class="line">...</span><br><span class="line">/dev/sda1 / ext4 rw,relatime,errors=remount-ro,data=ordered 0 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Где-то в списке, возвращаемом в моей системе, указано /dev/sda1 устройство, установленное в / (у вас может отличаться). Это дисковое устройство, на котором размещена корневая файловая система, которая содержит все необходимое для запуска системы, поэтому было бы здорово, если бы isolate выполняли команды, не зная о подобных файловых системах.</p><p>Давайте начнем с запуска терминала в его собственном пространстве имен mount:</p><ul><li>Строго говоря, нам не нужен доступ суперпользователя для работы с новыми пространствами имен mount, если мы включаем процедуры настройки пользовательского пространства имен, описанные в предыдущем посте. В результате в этом посте мы будем только предполагать, что unshare команды в терминале выполняются от имени суперпользователя. isolate в этом предположении нет необходимости.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The -m flag creates a new mount namespace.</span></span><br><span class="line"><span class="comment"># Флаг -m создаёт новый mount namespace.</span></span><br><span class="line">$ unshare -m bash</span><br><span class="line">$ cat /proc/$$/mounts</span><br><span class="line">...</span><br><span class="line">/dev/sda1 / ext4 rw,relatime,errors=remount-ro,data=ordered 0 0</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Хммм, мы по-прежнему видим тот же список, что и в корневом(root) пространстве имен mount. Особенно после того, как в предыдущем посте было показано, что новое пространство имен пользователя начинается с чистого листа, может показаться, что -m флаг, который мы передали unshare, не возымел никакого эффекта.</p><p>Процесс оболочки фактически выполняется в другом пространстве имен mount (мы можем убедиться в этом, сравнив файл с символической ссылкой ls -l /proc/$$/ns/mnt с файлом другой оболочки, запущенным в корневом пространстве имен mount). Причина, по которой мы по-прежнему видим один и тот же список, заключается в том, что всякий раз, когда мы создаем новое пространство имен монтирования (дочернее), в качестве дочернего списка используется копия точек монтирования пространства имен монтирования, где происходило создание (родительское). Теперь любые изменения, которые мы вносим в этот файл (например, монтируя файловую систему), будут невидимы для всех других процессов.</p><p>Однако изменение практически любого другого файла на данном этапе повлияет на другие процессы, потому что мы по-прежнему ссылаемся на те же самые файлы (Linux создает копии только специальных файлов, таких как список точек монтирования). Это означает, что в настоящее время у нас минимальная изоляция. Если мы хотим ограничить то, что будет видеть наш командный процесс, мы должны обновить этот список самостоятельно.</p><p>Теперь, с одной стороны, поскольку мы пытаемся соблюдать безопасность, мы могли бы просто сказать “К черту” и isolate очистить весь список перед выполнением команды, но это сделает команду бесполезной, поскольку каждая программа, по крайней мере, зависит от ресурсов, таких как файлы операционной системы, которые, в свою очередь, поддерживаются некоторой файловой системой. С другой стороны, мы также могли бы просто выполнить команду как есть, совместно используя с ней те же файловые системы, которые содержат необходимые системные файлы, которые ей требуются, но это, очевидно, противоречит цели этой изоляции, которую мы выполняем.</p><p>Самое приятное - предоставить программе ее собственную копию зависимостей и системных файлов, которые ей требуются для запуска, все изолированные, чтобы она могла вносить в них любые изменения, не затрагивая другие программы в системе. В лучшем случае мы заключили бы эти файлы в файловую систему и смонтировали бы ее как корневую файловую систему (в корневом каталоге /) перед выполнением ничего не подозревающей программы. Идея в том, что все, к чему может достичь процесс, должно проходить через корневую файловую систему, и поскольку мы будем точно знать, какие файлы мы туда помещаем для командного процесса, мы будем спокойны, зная, что он должным образом изолирован от остальной системы.</p><p>Хорошо, теоретически это звучит неплохо, и для того, чтобы реализовать это, мы сделаем следующее:</p><ol><li>Создайте копию зависимостей и системных файлов, необходимых команде.</li><li>Создайте новое пространство имен mount.</li><li>Замените корневую файловую систему в новом пространстве имен mount на ту, которая состоит из нашей копии системных файлов.</li><li>Выполните программу внутри нового пространства имен mount.</li></ol><h3 id="Корневые-файловые-системы-Root-Filesystems"><a href="#Корневые-файловые-системы-Root-Filesystems" class="headerlink" title="Корневые файловые системы (Root Filesystems)"></a>Корневые файловые системы (Root Filesystems)</h3><p>Вопрос, который возникает уже на шаге, 1 заключается в том, какие системные файлы вообще необходимы команде, которую мы хотим запустить? Мы могли бы порыться в нашей собственной корневой файловой системе и задавать этот вопрос для каждого файла, с которым сталкиваемся, и включать только те, где ответ да, но это звучит болезненно и ненужно. Кроме того, мы даже не знаем, с какой команды isolate будет выполняться для начала.</p><p>Если бы только люди сталкивались с такой же проблемой и собирали набор системных файлов, достаточно общих, чтобы прямо из коробки служить базой для большинства существующих программ? К счастью, есть много проектов, которые делают это! Одним из которых является <a href="https://alpinelinux.org/">Alpine Linux project</a> (это его основная функция при запуске FROM alpine:xxx в вашем Dockerfile). Alpine предоставляет <a href="https://alpinelinux.org/downloads/">корневые файловые системы</a>, которые мы можем использовать для наших целей. Если вы следите за ходом событий, вы можете получить копию их минимальной корневой файловой системы (MINI ROOT FILESYSTEM) для x86_64 <a href="http://dl-cdn.alpinelinux.org/alpine/v3.10/releases/x86_64/alpine-minirootfs-3.10.1-x86_64.tar.gz">здесь</a>. Последняя версия на момент написания статьи , которую мы будем использовать в этом посте , - это v3.10.1.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://dl-cdn.alpinelinux.org/alpine/v3.10/releases/x86_64/alpine-minirootfs-3.10.1-x86_64.tar.gz</span><br><span class="line">$ mkdir rootfs</span><br><span class="line">$ tar -xzf alpine-minirootfs-3.10.1-x86_64.tar.gz -C rootfs</span><br><span class="line">$ ls rootfs</span><br><span class="line">bin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><p>В rootfs каталоге есть знакомые файлы, такие же, как в нашей корневой файловой системе по адресу /, но проверьте, насколько он минимален - довольно многие из этих каталогов пусты:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls rootfs/&#123;mnt,dev,proc,home,sys&#125;</span><br><span class="line"><span class="comment"># empty</span></span><br><span class="line"><span class="comment"># пусто</span></span><br></pre></td></tr></table></figure><p>Это здорово! мы можем дать команду запустить копию этого, и это возможно sudo rm -rf / нам все равно, больше никого это не побеспокоит.</p><h3 id="Pivot-root-поворачиваем-root"><a href="#Pivot-root-поворачиваем-root" class="headerlink" title="Pivot root (поворачиваем root)"></a>Pivot root (поворачиваем root)</h3><p>Учитывая наше новое пространство имен mount и копию системных файлов, мы хотели бы смонтировать эти файлы в корневом каталоге нового пространства имен mount, не выбивая почву у нас из-под ног. В Linux мы познакомились с pivot_root системным вызовом (есть соответствующая команда), который позволяет нам управлять тем, что процессы рассматривают как корневую файловую систему.</p><p>Команда pivot_root принимает два аргумента new_root put_old, где new_root это путь к файловой системе, содержащей будущую корневую файловую систему, и put_old это путь к каталогу. Это работает с помощью:</p><ol><li>Монтирование корневой файловой системы вызывающего процесса на put_old.</li><li>Монтируем файловую систему , на которую указывает new_root как на текущую корневую файловую систему в /.</li></ol><p>Давайте посмотрим на это в действии. В нашем новом пространстве имен mount мы начинаем с создания файловой системы на основе наших файлов alpine:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ unshare -m bash</span><br><span class="line">$ mount --<span class="built_in">bind</span> rootfs rootfs</span><br></pre></td></tr></table></figure><p>Далее мы поворачиваем root:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> rootfs</span><br><span class="line">$ mkdir put_old</span><br><span class="line">$ pivot_root . put_old</span><br><span class="line">$ <span class="built_in">cd</span> /</span><br><span class="line"><span class="comment"># We should now have our new root. e.g if we:</span></span><br><span class="line"><span class="comment"># Теперь у нас должен быть новый корневой каталог. Например, если мы сделаем:</span></span><br><span class="line">$ ls proc</span><br><span class="line"><span class="comment"># proc is empty</span></span><br><span class="line"><span class="comment"># And the old root is now in put_old</span></span><br><span class="line"><span class="comment"># proc пуст</span></span><br><span class="line"><span class="comment"># И старый корневой каталог теперь в put_old</span></span><br><span class="line">$ ls put_old</span><br><span class="line">bin   dev  home        lib    lost+found  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  etc  initrd.img  lib64  media       opt  root  sbin  sys  usr  vmlinuz</span><br></pre></td></tr></table></figure><p>Наконец, мы размонтируем старую файловую систему из put_old, чтобы вложенная оболочка не могла получить к ней доступ.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umount -l put_old</span><br></pre></td></tr></table></figure><p>Благодаря этому мы можем запустить любую команду в нашей оболочке, и они будут выполняться с использованием нашей пользовательской файловой системы alpine root, не подозревая об оркестровке, которая привела к их выполнению. И наши драгоценные файлы в старой файловой системе находятся в безопасности вне пределов их досягаемости.</p><h3 id="Реализация-Implementation"><a href="#Реализация-Implementation" class="headerlink" title="Реализация (Implementation)"></a>Реализация (Implementation)</h3><p>Исходный код этого поста можно найти <a href="https://github.com/iffyio/isolate/tree/part-3">здесь</a>.</p><p>Мы можем повторить то, что только что сделали, в коде, заменив pivot_root команду на соответствующий системный вызов. Сначала мы создаем наш командный процесс в новом пространстве имен mount , добавляя CLONE_NEWNS флаг в clone.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> clone_flags = SIGCHLD | CLONE_NEWUTS | CLONE_NEWUSER | CLONE_NEWNS;</span><br></pre></td></tr></table></figure><p>Далее мы создаем функцию, prepare_mntns которая, учитывая путь к каталогу, содержащему системные файлы (rootfs), устанавливает текущее пространство имен mount , поворачивая корень текущего процесса в rootfs, как мы делали ранее.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare_mntns</span><span class="params">(<span class="keyword">char</span> *rootfs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mnt = rootfs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mount</span>(rootfs, mnt, <span class="string">&quot;ext4&quot;</span>, MS_BIND, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to mount %s at %s: %m\n&quot;</span>, rootfs, mnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chdir</span>(mnt))</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to chdir to rootfs mounted at %s: %m\n&quot;</span>, mnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *put_old = <span class="string">&quot;.put_old&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mkdir</span>(put_old, <span class="number">0777</span>) &amp;&amp; errno != EEXIST)</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to mkdir put_old %s: %m\n&quot;</span>, put_old);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">syscall</span>(SYS_pivot_root, <span class="string">&quot;.&quot;</span>, put_old))</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to pivot_root from %s to %s: %m\n&quot;</span>, rootfs, put_old);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to chdir to new root: %m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">umount2</span>(put_old, MNT_DETACH))</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to umount put_old %s: %m\n&quot;</span>, put_old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Нам нужно вызвать эту функцию из нашего кода, и это должно быть сделано нашим командным процессом в cmd_exec (поскольку он выполняется в новом пространстве имен mount), прежде чем начнется выполнение фактической команды.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Wait for &#x27;setup done&#x27; signal from the main process.</span></span><br><span class="line"><span class="comment">// Ожидание сигнала &#x27;настройка завершена&#x27; от основного процесса.</span></span><br><span class="line"><span class="built_in">await_setup</span>(params-&gt;fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">prepare_mntns</span>(<span class="string">&quot;rootfs&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Давайте попробуем:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ./isolate sh</span><br><span class="line">===========sh============</span><br><span class="line">$ ls put_old</span><br><span class="line"><span class="comment"># put_old is empty. Hurray!</span></span><br><span class="line"><span class="comment"># What does our new mount list look like?</span></span><br><span class="line"><span class="comment"># put_old пуст. Ура!</span></span><br><span class="line"><span class="comment"># Как выглядит наш новый список монтирования?</span></span><br><span class="line">$ cat /proc/$$/mounts</span><br><span class="line">cat: cant open <span class="string">&#x27;/proc/1431/mounts&#x27;</span>: No such file or directory</span><br><span class="line"><span class="comment"># Hmmm, what other processes are running?</span></span><br><span class="line"><span class="comment"># Хммм, а какие ещё процессы запущены?</span></span><br><span class="line">$ ps aux</span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line"><span class="comment"># Empty! eh?</span></span><br><span class="line"><span class="comment"># Пусто! А?</span></span><br></pre></td></tr></table></figure><p>Этот вывод показывает нечто странное - мы не можем проверить список подключений(монтирования), за который мы так упорно боролись, и ps сообщает нам, что в системе не запущено никаких процессов (даже текущего процесса или ps самого себя?). Более вероятно, что мы что-то сломали при настройке пространства имен mount.</p><h3 id="Пространства-имен-PID-PID-Namespaces"><a href="#Пространства-имен-PID-PID-Namespaces" class="headerlink" title="Пространства имен PID (PID Namespaces)"></a>Пространства имен PID (PID Namespaces)</h3><p>Мы уже упоминали /proc каталог несколько раз в этой серии, и если вы были знакомы с ним, то, вероятно, не удивлены, что ps он оказался пустым, поскольку ранее мы видели, что каталог был пуст в этом пространстве имен mount (когда мы получили его из корневой файловой системы alpine).</p><p>/proc Каталог в Linux обычно используется для предоставления доступа к <a href="https://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html">специальной файловой системе</a> (называемой файловой системой proc), которая управляется самим Linux. Linux использует его для предоставления информации обо всех процессах, запущенных в системе, а также другой системной информации, касающейся устройств, прерываний и т.д. Всякий раз, когда мы запускаем команду типа ps, которая обращается к информации о процессах в системе, она обращается к этой файловой системе для получения информации.</p><p>Другими словами, нам нужно раскрутить proc файловую систему. К счастью, это в основном включает в себя сообщение Linux о том, что нам нужна файловая система, желательно смонтированная в /proc. Но мы пока не можем этого сделать, поскольку наш командный процесс по-прежнему зависит от той же proc файловой системы, что и isolate и любой другой обычный процесс в системе - чтобы устранить эту зависимость, нам нужно запустить его внутри его собственного PID пространства имен.</p><p><a href="http://man7.org/linux/man-pages/man7/pid_namespaces.7.html">Пространство имен PID</a> изолирует идентификаторы процессов в системе. Одним из результатов является то, что процессы, запущенные в разных пространствах имен PID, могут иметь один и тот же идентификатор процесса, не конфликтуя друг с другом. Конечно, мы изолируем это пространство имен, потому что хотим максимально изолировать нашу запущенную команду, но более интересная причина, по которой мы показываем это здесь, заключается в том, что для монтирования proc файловой системы требуются привилегии root, а текущее пространство имен PID принадлежит пространству имен пользователя root, где у нас нет достаточных разрешений (если вы помните из предыдущего поста, root для командного процесса на самом деле нет root). Итак, мы должны работать в пространстве имен PID, принадлежащем пользовательскому пространству имен, которое распознает наш командный процесс как root.</p><p>Мы можем создать новое пространство имен PID , передав CLONE_NEWPID в clone:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> clone_flags = SIGCHLD | CLONE_NEWUTS | CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWPID;</span><br></pre></td></tr></table></figure><p>Далее мы добавим функцию prepare_procfs, которая настраивает файловую систему proc путем монтирования ее в текущем пространстве имен mount и pid.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void prepare_procfs()</span><br><span class="line">&#123;</span><br><span class="line">    if (mkdir(&quot;/proc&quot;, 0555) &amp;&amp; errno != EEXIST)</span><br><span class="line">        die(&quot;Failed to mkdir /proc: %m\n&quot;);</span><br><span class="line"></span><br><span class="line">    if (mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;&quot;))</span><br><span class="line">        die(&quot;Failed to mount proc: %m\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Наконец, мы вызываем функцию непосредственно перед размонтированием put_old в нашей prepare_mntns функции, после того как мы настроили пространство имен mount и изменили его на корневой каталог.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare_mntns</span><span class="params">(<span class="keyword">char</span> *rootfs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">prepare_procfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">umount2</span>(put_old, MNT_DETACH))</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;Failed to umount put_old %s: %m\n&quot;</span>, put_old);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Мы можем попробовать isolate еще раз:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./isolate sh</span><br><span class="line">===========sh============</span><br><span class="line">$ ps</span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 sh</span><br><span class="line">    2 root      0:00 ps</span><br></pre></td></tr></table></figure><p>Это выглядит намного лучше! Оболочка рассматривает себя как единственный процесс, запущенный в системе и работающий с PID 1 (поскольку это был первый процесс, запущенный в этом новом пространстве имен PID).</p><p>В этом посте были рассмотрены два пространства имен и, как результат, isolate появились две новые функции. В следующем посте мы рассмотрим изоляцию с помощью Network пространств имен. Там нам придется иметь дело с некоторой сложной низкоуровневой сетевой конфигурацией в попытке обеспечить сетевое взаимодействие между процессами в разных сетевых пространствах имен.</p><p><img src="/images/isolate.png" alt="Вот вам и namespaces"></p>]]></content>
    
    
    <summary type="html">Глубокое погружение в пространства имен Linux, часть 3</summary>
    
    
    
    <category term="ОС" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/"/>
    
    <category term="Namespaces" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/Namespaces/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>namespaces,часть 4</title>
    <link href="https://goxpert.ru/2024/06/01/os/namespaces4/"/>
    <id>https://goxpert.ru/2024/06/01/os/namespaces4/</id>
    <published>2024-06-01T09:16:00.000Z</published>
    <updated>2024-06-09T13:33:38.051Z</updated>
    
    <content type="html"><![CDATA[<p>Перевод сделан <a href="/2024/06/01/helloworld/index.html">автором сайта goxpert.ru</a></p><h3 id="Краткое-содежание-перевода"><a href="#Краткое-содежание-перевода" class="headerlink" title="Краткое содежание перевода"></a>Краткое содежание <a href="https://ifeanyi.co/posts/linux-namespaces-part-4/">перевода</a></h3><ul><li>В Linux существуют пространства имен для изоляции сетевых ресурсов. </li><li>Сетевое пространство имен изолирует сетевые ресурсы, создавая свои собственные сетевые устройства, таблицы маршрутизации и правила брандмауэра. </li><li>Команда ip в Linux является швейцарским армейским ножом для работы в сети. </li><li>Именованные сетевые пространства имен проще в использовании и могут существовать без участия процессов в качестве членов. </li><li>Устройства Veth используются для создания виртуальных сетевых устройств Ethernet, которые обеспечивают связь между пространствами имен. </li><li>Для взаимодействия с Linux используется интерфейс Netlink, который предоставляет API поверх сокетов для сетевой маршрутизации и управления устройствами</li></ul><h2 id="Глубокое-погружение-в-пространства-имен-Linux-часть-4"><a href="#Глубокое-погружение-в-пространства-имен-Linux-часть-4" class="headerlink" title="Глубокое погружение в пространства имен Linux, часть 4"></a>Глубокое погружение в пространства имен Linux, часть 4</h2><p><a href="http://man7.org/linux/man-pages/man7/mount_namespaces.7.html">Пространства имен монтирования(Mount namespaces) </a>  изолируют  ресурсы файловой системы. Это в значительной степени охватывает все, что связано с файлами в системе. Среди инкапсулированных ресурсов есть файл, содержащий список <a href="http://www.linfo.org/mount_point.html">точек монтирования</a>, которые видны процессу, и, как мы намекали в <a href="/2024/06/01/os/namespaces/index.html">вступительном посте</a>, изоляция может обеспечить такое поведение, что изменение списка (или любого другого файла) в некотором экземпляре пространства имен монтирования M(mount namespace) не влияло на этот список в другом экземпляре (так что только процессы в M наблюдают изменения).</p><p>В этом заключительном посте серии мы рассмотрим <a href="http://man7.org/linux/man-pages/man8/ip-netns.8.html">сетевые пространства имен</a>. Как мы намекали во вступительном посте, сетевое пространство имен изолирует связанные с сетью ресурсы - процесс, запущенный в отдельном сетевом пространстве имен, имеет свои собственные сетевые устройства, таблицы маршрутизации, правила брандмауэра и т.д. Мы можем сразу увидеть это в действии, изучив нашу текущую сетевую среду.</p><h3 id="Команда-ip"><a href="#Команда-ip" class="headerlink" title="Команда ip"></a>Команда ip</h3><p>Поскольку в этом посте мы будем взаимодействовать с сетевыми устройствами, мы восстановим требования к суперпользователю, которые мы смягчили в предыдущих постах. С этого момента мы будем предполагать, что оба ip и isolate выполняются с sudo.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip link list</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:96:2e:3b brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>Звездой шоу здесь является ip command - <a href="https://access.redhat.com/sites/default/files/attachments/rh_ip_command_cheatsheet_1214_jcs_print.pdf">швейцарский армейский нож для создания сетей</a> в Linux - и мы будем широко использовать его в этом посте. Прямо сейчас мы только что запустили link list подкоманду, которая покажет нам, какие сетевые устройства в настоящее время доступны в системе (здесь у нас есть lo интерфейс обратной связи и ens33 интерфейс локальной сети ethernet).</p><p>Как и во всех других пространствах имен, система начинается с начального сетевого пространства имен, к которому принадлежат все процессы, если не указано иное. Запуск этой ip link list команды как есть дает нам сетевые устройства, принадлежащие исходному пространству имен (поскольку наша оболочка и ip команда принадлежат этому пространству имен).</p><h3 id="Именованные-сетевые-пространства-имен"><a href="#Именованные-сетевые-пространства-имен" class="headerlink" title="Именованные сетевые пространства имен"></a>Именованные сетевые пространства имен</h3><p>Давайте создадим новое сетевое пространство имен:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns add coke</span><br><span class="line">$ ip netns list</span><br><span class="line">coke</span><br></pre></td></tr></table></figure><p>И снова мы использовали команду ip. Его netns подкоманда позволяет нам играть с сетевыми пространствами имен - например, мы можем создавать новые сетевые пространства имен с помощью add подкоманды netns и использовать list, чтобы, ну, составить их список.</p><p>Вы могли заметить, что list вернуло только наше недавно созданное пространство имен - разве оно не должно возвращать как минимум два, второе из которых является исходным пространством имен, о котором мы упоминали ранее? Причина этого в том, что ip создается так называемое именованное сетевое пространство имен, которое просто является сетевым пространством имен, идентифицируемым по уникальному имени (в нашем случае coke). Через list показаны только именованные сетевые пространства имен, а начальное сетевое пространство имен не названо.</p><p>Именованные сетевые пространства имен получить проще. Например, для каждого именованного сетевого пространства имен в /var/run/netns папке создается файл, который может использоваться процессом, который хочет переключиться на свое пространство имен. Еще одним свойством именованных сетевых пространств имен является то, что они могут существовать без участия какого-либо процесса в качестве члена - в отличие от безымянных, которые будут удалены после завершения работы всех входящих в них процессов.</p><p>Теперь, когда у нас есть дочернее сетевое пространство имен, мы можем посмотреть на сеть с его точки зрения.</p><ul><li>Мы будем использовать командную строку C$ чтобы подчеркнуть оболочку, работающую внутри дочернего сетевого пространства имен.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> coke bash</span><br><span class="line">C$ ip link list</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure><p>exec $namespace $command Подкоманда выполняется $command в именованном сетевом пространстве имен $namespace. Здесь мы запустили оболочку внутри coke пространства имен и перечислили доступные сетевые устройства. Мы видим, что, по крайней мере, наше ens33 устройство исчезло. Единственное устройство, которое отображается, - это loopback, и даже этот интерфейс не работает.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C$ ping 127.0.0.1</span><br><span class="line">connect: Network is unreachable</span><br></pre></td></tr></table></figure><p>Мы уже должны привыкнуть к этому, настройки по умолчанию для пространств имен обычно очень строгие. Как мы видим, в сетевых пространствах имен не будет никаких устройств, кроме loopback. Однако мы можем настроить loopback интерфейс без какой-либо бумажной волокиты:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C$ ip link <span class="built_in">set</span> dev lo up</span><br><span class="line">C$ ping 127.0.0.1</span><br><span class="line">PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.034 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Сетевая-изоляция"><a href="#Сетевая-изоляция" class="headerlink" title="Сетевая изоляция"></a>Сетевая изоляция</h3><p>Мы уже начинаем понимать, что, запуская процесс во вложенном сетевом пространстве имен, таком как coke, мы можем быть уверены, что он изолирован от остальной системы в том, что касается сетевого взаимодействия. Наш процесс оболочки, запущенный в coke может взаимодействовать только через loopback - это означает, что он может взаимодействовать только с процессами, которые также являются членами coke пространства имен, но в настоящее время других процессов-членов нет (и во имя изоляции мы хотели бы, чтобы так и оставалось), так что здесь немного одиноко. Давайте попробуем немного ослабить эту изоляцию, мы создадим туннель, через который процессы в coke могут взаимодействовать с процессами в нашем исходном пространстве имен.</p><p>Теперь любое сетевое взаимодействие должно осуществляться через некоторое сетевое устройство, а устройство может существовать только в одном сетевом пространстве имен в любой момент времени, поэтому взаимодействие между любыми двумя процессами в разных пространствах имен должно осуществляться по крайней мере через два сетевых устройства - по одному в каждом сетевом пространстве имен.</p><h3 id="Устройства-Veth"><a href="#Устройства-Veth" class="headerlink" title="Устройства Veth"></a>Устройства Veth</h3><p>Для удовлетворения наших потребностей мы будем использовать виртуальноевиртуальное(<strong>v</strong>irtual) <strong>eth</strong>ernet сетевое устройство (или, для краткости veth). Устройства Veth всегда создаются как пара устройств по типу туннеля, так что сообщения, записанные на устройство на одном конце, выходят из устройства на другом конце. Вы могли бы догадаться, что мы могли бы легко иметь один конец в исходном сетевом пространстве имен, а другой - в нашем дочернем сетевом пространстве имен, и вся связь между сетевыми пространствами имен осуществлялась бы через соответствующее конечное устройство veth (и вы были бы правы).</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a veth pair (veth0 &lt;=&gt; veth1)</span></span><br><span class="line"><span class="comment"># Создание пары veth (veth0 &lt;=&gt; veth1)</span></span><br><span class="line">$ ip link add veth0 <span class="built_in">type</span> veth peer name veth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Move the veth1 end to the new namespace</span></span><br><span class="line"><span class="comment"># Перемещение veth1 в новое пространство имён</span></span><br><span class="line">$ ip link <span class="built_in">set</span> veth1 netns coke</span><br><span class="line"></span><br><span class="line"><span class="comment"># List the network devices from inside the new namespace</span></span><br><span class="line"><span class="comment"># Просмотр сетевых устройств в новом пространстве имён</span></span><br><span class="line">C$ ip link list</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">7: veth1@if8: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether ee:16:0c:23:f3:af brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure><p>Наше veth1 устройство теперь отображается в coke пространстве имен. Но чтобы пара veth заработала, нам нужно предоставить им обоим IP-адреса и настроить интерфейсы. Мы сделаем это в соответствующем сетевом пространстве имен.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In the initial namespace</span></span><br><span class="line"><span class="comment"># В исходном пространстве имён</span></span><br><span class="line">$ ip addr add 10.1.1.1/24 dev veth0</span><br><span class="line">$ ip link <span class="built_in">set</span> dev veth0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># In the coke namespace</span></span><br><span class="line"><span class="comment"># В пространстве имён coke</span></span><br><span class="line">C$ ip addr add 10.1.1.2/24 dev veth1</span><br><span class="line">C$ ip link <span class="built_in">set</span> dev veth1 up</span><br><span class="line"></span><br><span class="line">C$ ip addr show veth1</span><br><span class="line">7: veth1@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether ee:16:0c:23:f3:af brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.1.1.2/24 scope global veth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::ec16:cff:fe23:f3af/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>Мы должны увидеть, что veth1 установлено и имеет назначенный нам адрес 10.1.1.2 - то же самое должно произойти для veth0 в исходном пространстве имен. Теперь мы должны быть в состоянии выполнять пинг между пространствами имен между двумя процессами, запущенными в обоих пространствах имен.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ping -I veth0 10.1.1.2</span><br><span class="line">PING 10.1.1.2 (10.1.1.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.1.1.2: icmp_seq=1 ttl=64 time=0.041 ms</span><br><span class="line">...</span><br><span class="line">C$ ping 10.1.1.1</span><br><span class="line">PING 10.1.1.1 (10.1.1.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.067 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Реализация"><a href="#Реализация" class="headerlink" title="Реализация"></a>Реализация</h3><p>Исходный код этого поста можно найти <a href="https://github.com/iffyio/isolate/tree/part-4">здесь</a>.</p><p>Как обычно, сейчас мы попытаемся воспроизвести то, что видели до сих пор, в коде. В частности, нам нужно будет сделать следующее:</p><ol><li>Выполните команду в новом сетевом пространстве имен.</li><li>Создайте пару veth (veth0 &lt;=&gt; veth1).</li><li>Переместите устройство veth1 в новое пространство имен.</li><li>Назначьте IP-адреса обоим устройствам и выведите их на экран.</li></ol><p>Шаг 1 прост: мы создаем наш командный процесс в новом пространстве имен network, добавляя CLONE_NEWNET флаг в clone:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> clone_flags = SIGCHLD | CLONE_NEWUTS | CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWNET;</span><br></pre></td></tr></table></figure><h3 id="Netlink"><a href="#Netlink" class="headerlink" title="Netlink"></a>Netlink</h3><p>На оставшихся этапах мы в первую очередь будем использовать <a href="http://man7.org/linux/man-pages/man7/netlink.7.html">интерфейс</a> <a href="http://www.infradead.org/~tgr/libnl/doc/core.html#_introduction">Netlink</a> для взаимодействия с Linux. Netlink в основном используется для связи между обычными приложениями (например, isolate) и ядром Linux. Поверх сокетов предоставляется API, основанный на <a href="http://www.infradead.org/~tgr/libnl/doc/core.html#core_netlink_fundamentals">протоколе</a>, который определяет структуру и содержимое сообщений. Используя этот протокол, мы можем отправлять сообщения, которые Linux получает и преобразует в запросы - например, создать пару veth с именами veth0 и veth1.</p><p>Давайте начнем с создания нашего сокета netlink. В нем мы указываем, что хотим использовать NETLINK_ROUTE протокол - этот протокол охватывает реализации сетевой маршрутизации и управления устройствами.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd = <span class="built_in">socket</span>(domain, type, protocol);</span><br><span class="line">    <span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;cannot open socket: %m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sock_fd = <span class="built_in">create_socket</span>(</span><br><span class="line">  PF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE);</span><br></pre></td></tr></table></figure><h3 id="Формат-сообщения-Netlink"><a href="#Формат-сообщения-Netlink" class="headerlink" title="Формат сообщения Netlink"></a>Формат сообщения Netlink</h3><p><a href="http://www.infradead.org/~tgr/libnl/doc/core.html#core_msg_format">Сообщение</a> Netlink представляет собой выровненный по 4 байта блок данных, содержащий заголовок (struct nlmsghdr) и полезную нагрузку. Формат заголовка описан <a href="https://tools.ietf.org/html/rfc3549#section-2.3.2">здесь</a>. <a href="https://tools.ietf.org/html/rfc3549#section-2.3.1">Модуль службы сетевого интерфейса</a> (NIS) определяет формат (struct ifinfomsg), с которого должна начинаться полезная нагрузка, связанная с администрированием сетевого интерфейса.</p><p>Наш запрос будет представлен следующей C структурой:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PAYLOAD 1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nl_req</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> <span class="title">n</span>;</span>     <span class="comment">// Netlink message header</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifinfomsg</span> <span class="title">i</span>;</span>    <span class="comment">// Payload starting with NIS module info</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAX_PAYLOAD]; <span class="comment">// Remaining payload</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Атрибуты-Netlink"><a href="#Атрибуты-Netlink" class="headerlink" title="Атрибуты Netlink"></a>Атрибуты Netlink</h3><p>Модуль NIS требует, чтобы полезная нагрузка кодировалась как <a href="http://www.infradead.org/~tgr/libnl/doc/core.html#core_attr">атрибуты Netlink</a>. Атрибуты предоставляют способ сегментировать полезную нагрузку на подразделы. Атрибут имеет тип и длину в дополнение к полезной нагрузке, содержащей его фактические данные.</p><p>Полезная нагрузка сообщения Netlink будет закодирована в виде списка атрибутов (где любой такой атрибут, в свою очередь, может иметь вложенные атрибуты), и у нас будут некоторые вспомогательные функции для заполнения его атрибутами. В коде атрибут представлен rtattr структурой в linux/rtnetlink.h заголовочном файле в виде:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span>  rta_len;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span>  rta_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>rta_len это длина полезной нагрузки атрибута, которая непосредственно следует за rt_attr структурой в памяти (т. е. за следующими rta_len байтами). То, как интерпретируется содержимое этой полезной нагрузки, определяется rta_type , а возможные значения полностью зависят от реализации получателя и отправляемого запроса.</p><p>В попытке собрать все это воедино, давайте посмотрим, как isolate выполняет запрос netlink для создания пары veth со следующей функцией, create_veth которая выполняет шаг2:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ip link add ifname type veth ifname name peername</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_veth</span><span class="params">(<span class="keyword">int</span> sock_fd, <span class="keyword">char</span> *ifname, <span class="keyword">char</span> *peername)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __u16 flags =</span><br><span class="line">            NLM_F_REQUEST  <span class="comment">// This is a request message - Это сообщение запроса</span></span><br><span class="line">            | NLM_F_CREATE <span class="comment">// Create the device if it doesn&#x27;t exist  - cоздание устройства, если оно не существует</span></span><br><span class="line">            | NLM_F_EXCL   <span class="comment">// If it already exists, do nothing  - Если оно уже существует, ничего не делать</span></span><br><span class="line">            | NLM_F_ACK;   <span class="comment">// Reply with an acknowledgement or error - Ответ с подтверждением или ошибкой</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialise request message.</span></span><br><span class="line">    <span class="comment">// Инициализация сообщения запроса.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nl_req</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">            .n.nlmsg_len = <span class="built_in">NLMSG_LENGTH</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct ifinfomsg)),</span><br><span class="line">            .n.nlmsg_flags = flags,</span><br><span class="line">            .n.nlmsg_type = RTM_NEWLINK, <span class="comment">// This is a netlink message - Это сообщение netlink</span></span><br><span class="line">            .i.ifi_family = PF_NETLINK,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">n</span> =</span> &amp;req.n;</span><br><span class="line">    <span class="keyword">int</span> maxlen = <span class="built_in"><span class="keyword">sizeof</span></span>(req);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create an attribute r0 with the veth info. e.g if ifname is veth0</span></span><br><span class="line"><span class="comment">     * then the following will be appended to the message</span></span><br><span class="line"><span class="comment">     * Создание атрибута r0 с информацией о veth. Например, если ifname - veth0,</span></span><br><span class="line"><span class="comment">     * тогда нижеследующее будет добавлено к сообщению</span></span><br><span class="line"><span class="comment">     * &#123;</span></span><br><span class="line"><span class="comment">     *   rta_type: IFLA_IFNAME</span></span><br><span class="line"><span class="comment">     *   rta_len: 5 (len(veth0) + 1)</span></span><br><span class="line"><span class="comment">     *   data: veth0\0</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">addattr_l</span>(n, maxlen, IFLA_IFNAME, ifname, <span class="built_in">strlen</span>(ifname) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a nested attribute r1 within r0 containing iface info</span></span><br><span class="line">    <span class="comment">// Добавление вложенного атрибута r1 в r0, содержащего информацию iface</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">linfo</span> =</span></span><br><span class="line">            <span class="built_in">addattr_nest</span>(n, maxlen, IFLA_LINKINFO);</span><br><span class="line">    <span class="comment">// Specify the device type is veth</span></span><br><span class="line">    <span class="comment">// Указание типа устройства veth</span></span><br><span class="line">    <span class="built_in">addattr_l</span>(&amp;req.n, <span class="built_in"><span class="keyword">sizeof</span></span>(req), IFLA_INFO_KIND, <span class="string">&quot;veth&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add another nested attribute r2</span></span><br><span class="line">    <span class="comment">// Добавление еще одного вложенного атрибута r2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">linfodata</span> =</span></span><br><span class="line">            <span class="built_in">addattr_nest</span>(n, maxlen, IFLA_INFO_DATA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This next nested attribute r3 one contains the peer name e.g veth1</span></span><br><span class="line">    <span class="comment">// Следующий вложенный атрибут r3 содержит имя соседнего устройства, например veth1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">peerinfo</span> =</span></span><br><span class="line">            <span class="built_in">addattr_nest</span>(n, maxlen, VETH_INFO_PEER);</span><br><span class="line">    n-&gt;nlmsg_len += <span class="built_in"><span class="keyword">sizeof</span></span>(struct ifinfomsg);</span><br><span class="line">    <span class="built_in">addattr_l</span>(n, maxlen, IFLA_IFNAME, peername, <span class="built_in">strlen</span>(peername) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addattr_nest_end</span>(n, peerinfo); <span class="comment">// end r3 nest  - конец вложенного атрибута r3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">addattr_nest_end</span>(n, linfodata); <span class="comment">// end r2 nest - конец вложенного атрибута r2</span></span><br><span class="line">    <span class="built_in">addattr_nest_end</span>(n, linfo); <span class="comment">// end r1 nest - конец вложенного атрибута r1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the message</span></span><br><span class="line">    <span class="comment">// Отправка сообщения</span></span><br><span class="line">    <span class="built_in">send_nlmsg</span>(sock_fd, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Как мы можем видеть, нам нужно быть точными в отношении того, что мы здесь отправляем - нам нужно было закодировать сообщение именно так, как оно будет интерпретировано реализацией ядра, и здесь нам потребовалось для этого 3 вложенных атрибута. Я уверен, что это где-то задокументировано, хотя я не смог найти это после некоторого поиска в Google - в основном я разобрался с этим через strace и исходный код ip команды.</p><p>Следующим шагом 3 является метод, который, учитывая имя интерфейса ifname и дескриптор файла сетевого пространства имен netns, перемещает устройство, связанное с этим интерфейсом, в указанное сетевое пространство имен.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// $ ip link set veth1 netns coke</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_if_to_pid_netns</span><span class="params">(<span class="keyword">int</span> sock_fd, <span class="keyword">char</span> *ifname, <span class="keyword">int</span> netns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nl_req</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">            .n.nlmsg_len = <span class="built_in">NLMSG_LENGTH</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct ifinfomsg)),</span><br><span class="line">            .n.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,</span><br><span class="line">            .n.nlmsg_type = RTM_NEWLINK,</span><br><span class="line">            .i.ifi_family = PF_NETLINK,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addattr_l</span>(&amp;req.n, <span class="built_in"><span class="keyword">sizeof</span></span>(req), IFLA_NET_NS_FD, &amp;netns, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">addattr_l</span>(&amp;req.n, <span class="built_in"><span class="keyword">sizeof</span></span>(req), IFLA_IFNAME,</span><br><span class="line">              ifname, <span class="built_in">strlen</span>(ifname) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">send_nlmsg</span>(sock_fd, &amp;req.n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>После создания пары veth и перемещения одного конца в наше целевое сетевое пространство имен, на шаге 4 мы назначаем IP-адреса обоих конечных устройств и запускаем их интерфейсы. Для этого у нас есть вспомогательная функция, if_up которая, получив имя интерфейса ifname и IP-адрес ip, присваивает ip устройству ifname и запускает его. Для краткости мы не показываем их здесь, но вместо этого их можно <a href="https://github.com/iffyio/isolate/blob/part-4/netns.c#L155">найти здесь</a>.</p><p>Наконец, мы объединяем эти методы, чтобы подготовить наше сетевое пространство имен для нашего командного процесса.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare_netns</span><span class="params">(<span class="keyword">int</span> child_pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *veth = <span class="string">&quot;veth0&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *vpeer = <span class="string">&quot;veth1&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *veth_addr = <span class="string">&quot;10.1.1.1&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *vpeer_addr = <span class="string">&quot;10.1.1.2&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *netmask = <span class="string">&quot;255.255.255.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create our netlink socket</span></span><br><span class="line">    <span class="comment">// Создание нашего сокета netlink</span></span><br><span class="line">    <span class="keyword">int</span> sock_fd = <span class="built_in">create_socket</span>(</span><br><span class="line">            PF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... and our veth pair veth0 &lt;=&gt; veth1.</span></span><br><span class="line">    <span class="comment">// ... и нашей пары veth veth0 &lt;=&gt; veth1.</span></span><br><span class="line">    <span class="built_in">create_veth</span>(sock_fd, veth, vpeer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// veth0 is in our current (initial) namespace</span></span><br><span class="line">    <span class="comment">// so we can bring it up immediately.</span></span><br><span class="line">    <span class="comment">// veth0 находится в нашем текущем (исходном) namespace</span></span><br><span class="line">    <span class="comment">// так что мы можем сразу поднять его.</span></span><br><span class="line">    if_up(veth, veth_addr, netmask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... veth1 will be moved to the command namespace.</span></span><br><span class="line">    <span class="comment">// To do that though we need to grab a file descriptor</span></span><br><span class="line">    <span class="comment">// to and enter the commands namespace but first we must</span></span><br><span class="line">    <span class="comment">// remember our current namespace so we can get back to it</span></span><br><span class="line">    <span class="comment">// when we&#x27;re done.</span></span><br><span class="line">    <span class="comment">// ... veth1 будет перемещен в namespace команды.</span></span><br><span class="line">    <span class="comment">// Для этого нам нужно получить файловый дескриптор</span></span><br><span class="line">    <span class="comment">// и перейти в namespace команды, но сначала мы должны</span></span><br><span class="line">    <span class="comment">// запомнить наш текущий namespace, чтобы мы могли вернуться в него</span></span><br><span class="line">    <span class="comment">// когда закончим.</span></span><br><span class="line">    <span class="keyword">int</span> mynetns = <span class="built_in">get_netns_fd</span>(<span class="built_in">getpid</span>());</span><br><span class="line">    <span class="keyword">int</span> child_netns = <span class="built_in">get_netns_fd</span>(child_pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move veth1 to the command network namespace.</span></span><br><span class="line">    <span class="comment">// Перемещение veth1 в network namespace команды.</span></span><br><span class="line">    <span class="built_in">move_if_to_pid_netns</span>(sock_fd, vpeer, child_netns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... then enter it</span></span><br><span class="line">    <span class="comment">// ... и переход туда</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setns</span>(child_netns, CLONE_NEWNET)) &#123;</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;cannot setns for child at pid %d: %m\n&quot;</span>, child_pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... and bring veth1 up</span></span><br><span class="line">    <span class="comment">// ... и поднятие veth1-интерфейса</span></span><br><span class="line">    if_up(vpeer, vpeer_addr, netmask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... before moving back to our initial network namespace.</span></span><br><span class="line">    <span class="comment">// ... перед возвращением в наш исходный network namespace.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setns</span>(mynetns, CLONE_NEWNET)) &#123;</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;cannot restore previous netns: %m\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Затем мы можем вызвать prepare_netns сразу после того, как закончим настройку пользовательского пространства имен.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Get the writable end of the pipe.</span></span><br><span class="line"><span class="comment">// Получение записываемого конца пайпа.</span></span><br><span class="line"><span class="keyword">int</span> pipe = params.fd[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">prepare_userns</span>(cmd_pid);</span><br><span class="line"><span class="built_in">prepare_netns</span>(cmd_pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signal to the command process we&#x27;re done with setup.</span></span><br><span class="line"><span class="comment">// Сигнал командному процессу, что мы закончили настройку.</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Давайте попробуем!</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./isolate sh</span><br><span class="line">===========sh============</span><br><span class="line">$ ip link list</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">31: veth1@if32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP qlen 1000</span><br><span class="line">    link/ether 2a:e8:d9:df:b4:3d brd ff:ff:ff:ff:ff:ff</span><br><span class="line"><span class="comment"># Verify inter-namespace connectivity</span></span><br><span class="line">$ ping 10.1.1.1</span><br><span class="line">PING 10.1.1.1 (10.1.1.1): 56 data bytes</span><br><span class="line">64 bytes from 10.1.1.1: seq=0 ttl=64 time=0.145 ms</span><br></pre></td></tr></table></figure><p><img src="/images/isolate.png" alt="Вот вам и namespaces"></p>]]></content>
    
    
    <summary type="html">Глубокое погружение в пространства имен Linux, часть 4</summary>
    
    
    
    <category term="ОС" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/"/>
    
    <category term="Namespaces" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/Namespaces/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Cgroups</title>
    <link href="https://goxpert.ru/2024/06/01/os/cgroups/"/>
    <id>https://goxpert.ru/2024/06/01/os/cgroups/</id>
    <published>2024-06-01T09:16:00.000Z</published>
    <updated>2024-06-09T14:32:45.335Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Краткое-содежание"><a href="#Краткое-содежание" class="headerlink" title="Краткое содежание"></a>Краткое содежание</h3><ul><li>Cgroups - механизм управления ресурсами в Linux, позволяющий изолировать процессы и устройства. </li><li>Cgroups состоят из групп, которые могут быть встроены в подсистемы. </li><li>Механизм cgroups предоставляет обширные возможности управления памятью и устройствами. </li><li>Cgroups используются в современных инструментах контейнеризации, таких как LXC. </li><li>Недостатки cgroups включают непоследовательность и неправильную организацию. </li><li>Cgroup v2 был включен в ядро Linux начиная с версии 4.5, предлагая более последовательный подход. </li></ul><p>Продолжаем цикл статей о механизмах контейнеризации. В <a href="/2024/06/01/os/namespaces/index.html">предыдущем посте</a> мы говорили об изоляции процессов с помощью механизма «пространств имён» (namespaces). Но для контейнеризации одной лишь изоляции ресурсов недостаточно. Если мы запускаем какое-либо приложение в изолированном окружении, мы должны быть уверены в том, что этому приложению выделено достаточно ресурсов и что оно не будет потреблять лишние ресурсы, нарушая тем самым работу остальной системы. Для решения этой задачи в ядре Linux имеется специальный механизм — cgroups (сокращение от control groups, контрольные группы). О нём мы расскажем в сегодняшней статье.</p><p>Тема cgroups сегодня особенно актуальна: в ядро версии 4.5, вышедшей в свет в январе текущего года, была официально добавлена новая версия этого механизма — group v2.<br>В ходе работы над ней cgroups был по сути переписан заново.</p><p>Почему потребовались столь радикальные изменения? Чтобы ответить на этот вопрос, рассмотрим в деталях, как была реализована первая версия cgroups.</p><h3 id="Cgroups-краткая-история"><a href="#Cgroups-краткая-история" class="headerlink" title="Cgroups: краткая история"></a>Cgroups: краткая история</h3><p>Разработка cgroups была начата в 2006 году сотрудниками Google Полом Менеджем и Рохитом Сетом. Термин «контрольная группа» тогда ещё не использовался, а вместо него употреблялся термин «<a href="http://lwn.net/Articles/236038/">контейнеры процессов</a>» (process containers). Собственно, сначала они и не ставили перед собой цели создать cgroups в современном понимании. Изначальный замысел был гораздо скромнее: усовершенствовать механизм <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/sec-cpuset.html">cpuset</a>, предназначенный для распределения процессорного времени и памяти между задачами. Но со временем всё переросло в более масштабный проект.</p><p>В конце 2007 года название process containers было заменено на control groups. Это было сделано, чтобы избежать разночтений в толковании термина «контейнер» (в то время уже активно развивался проект OpenVZ, и слово «контейнер» стало употребляться в новом, современном значении).</p><p>В 2008 году механизм cgroups был официально добавлен в ядро Linux (версия 2.6.24). Что нового появилось в этой версии ядра по сравнению с предыдущими?</p><p>Ни одного системного вызова, предназначенного специально для работы с cgroups, добавлено не было. В числе главных изменений следует назвать файловую систему cgroups, известную также под названием cgroupfs.</p><p>В init/main.c были были добавлены отсылки к функциям для активации cgoups во время загрузки: cgroup_init и cgroup_init_early. Были незначительно изменены функции, используемые для порождения и завершения процесса — fork() и exit().</p><p>В виртуальной файловой системе /proc появились новые директории: /proc/{pid}/сgroup (для каждого процесса) и /proc/cgroups (для системы в целом).</p><h3 id="Архитектура"><a href="#Архитектура" class="headerlink" title="Архитектура"></a>Архитектура</h3><p>Механизм cgroups состоит из двух составных частей: ядра (<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/cgroup.c">cgroup core</a>) и так называемых подсистем. В ядре версии 4.4.0.21 таких подсистем 12:</p><p><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/block/blk-cgroup.c">blkio</a> — устанавливает лимиты на чтение и запись с блочных устройств;<br><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/sched/cpuacct.c">cpuacct</a> — генерирует отчёты об использовании ресурсов процессора;<br><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/sched/core.c">cpu</a> — обеспечивает доступ процессов в рамках контрольной группы к CPU;<br><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/cpuset.c">cpuset</a> — распределяет задачи в рамках контрольной группы между процессорными ядрами;<br><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/security/device_cgroup.c">devices</a> — разрешает или блокирует доступ к устройствам;<br><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/cgroup_freezer.c">freezer</a> — приостанавливает и возобновляет выполнение задач в рамках контрольной группы<br><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/mm/hugetlb_cgroup.c">hugetlb</a> — активирует поддержку больших страниц памяти для контрольных групп;<br><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/mm/memcontrol.c">memory</a> — управляет выделением памяти для групп процессов;<br><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/core/netclassid_cgroup.c">net_cls</a> — помечает сетевые пакеты специальным тэгом, что позволяет идентифицировать пакеты, порождаемые определённой задачей в рамках контрольной группы;<br><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/core/netprio_cgroup.c">netprio</a> — используется для динамической установки приоритетов по трафику;<br><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/cgroup_pids.c">pids</a> — используется для ограничения количества процессов в рамках контрольной группы.</p><p>Вывести список подсистем на консоль можно с помощью команды:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls /sys/fs/cgroup/</span><br><span class="line"></span><br><span class="line">blkio    cpu,cpuacct  freezer  net_cls           perf_event</span><br><span class="line">cpu      cpuset       hugetlb  net_cls,net_prio  pids</span><br><span class="line">cpuacct  devices      memory   net_prio          systemd</span><br></pre></td></tr></table></figure><p>Каждая подсистема представляет собой директорию с управляющими файлами, в которых прописываются все настройки. В каждой из этих директорий имеются следующие управляющие файлы:</p><ul><li>cgroup.clone_children — позволяет передавать дочерним контрольным группам свойства родительских;</li><li>tasks — содержит список PID всех процессов, включённых в контрольные группы;</li><li>cgroup.procs — содержит список TGID групп процессов, включённых в контрольные группы;</li><li>cgroup.event_control — позволяет отправлять уведомления в случае изменения статуса контрольной группы;</li><li>release_agent — содержится команда, которая будет выполнена, если включена опция notify_on_release. Может использоваться, например, для автоматического удаления пустых контрольных групп;</li><li>notify_on_release — содержит булеву переменную (0 или 1), включающую (или наоборот отключающую), выполнение команду, указанной в release_agent.</li></ul><p>У каждой подсистемы имеются также собственные управляющие файлы. О некоторых из них мы расскажем ниже.</p><p>Чтобы создать контрольную группу, достаточно создать вложенную директорию в любой из подсистем. В эту вложенную директорию будут автоматически добавлены управляющие файлы (ниже мы расскажем об этом более подробно). Добавить процессы в группу очень просто: нужно просто записать их PID в управляющий файл tasks.</p><p>Совокупность контрольных групп, встроенных в подсистему, называется иерархией.Попробуем разобрать принципы функционирования cgroups на простых практических примерах.</p><h2 id="Иерархия-cgroups-практическое-знакомство"><a href="#Иерархия-cgroups-практическое-знакомство" class="headerlink" title="Иерархия cgroups: практическое знакомство"></a>Иерархия cgroups: практическое знакомство</h2><h3 id="Пример-1-управление-процессорными-ресурсами"><a href="#Пример-1-управление-процессорными-ресурсами" class="headerlink" title="Пример 1: управление процессорными ресурсами"></a>Пример 1: управление процессорными ресурсами</h3><p>Выполним команду:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /sys/fs/cgroup/cpuset/group0</span><br></pre></td></tr></table></figure><p>С помощью этой команды мы создали контрольную группу, в которой содержатся следующие управляющие файлы:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ls /sys/fs/cgroup/cpuset/group0</span><br><span class="line"></span><br><span class="line">group.clone_children   cpuset.memory_pressure</span><br><span class="line">cgroup.procs           cpuset.memory_spread_page</span><br><span class="line">cpuset.cpu_exclusive   cpuset.memory_spread_slab</span><br><span class="line">cpuset.cpus            cpuset.mems</span><br><span class="line">cpuset.effective_cpus  cpuset.sched_load_balance</span><br><span class="line">cpuset.effective_mems  cpuset.sched_relax_domain_level</span><br><span class="line">cpuset.mem_exclusive   notify_on_release</span><br><span class="line">cpuset.mem_hardwall    tasks</span><br><span class="line">cpuset.memory_migrate</span><br></pre></td></tr></table></figure><p>Пока что в нашей группе никаких процессов нет. Чтобы добавить процесс, нужно записать его PID в файл tasks, например:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $$ &gt; /sys/fs/cgroup/cpuset/group0/tasks</span><br></pre></td></tr></table></figure><p>Cимволами $$ обозначается PID процесса, выполняемого текущей командной оболочкой.</p><p>Этот процесс не закреплён ни за одним ядром CPU, что подтверждает следующая команда:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/$$/status |grep <span class="string">&#x27;_allowed&#x27;</span></span><br><span class="line">Cpus_allowed: 2</span><br><span class="line">Cpus_allowed_list:  0-1</span><br><span class="line">Mems_allowed: 00000000,00000001</span><br><span class="line">Mems_allowed_list:  0</span><br></pre></td></tr></table></figure><p>Вывод этой команды показывает, что для интересующего нас процесса доступны 2 ядра CPU с номерами 0 и 1.</p><p>Попробуем «привязать» этот процесс к ядру с номером 0:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 0 &gt;/sys/fs/cgroup/cpuset/group0/cpuset.cpus</span><br></pre></td></tr></table></figure><p>Проверим, что получилось:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/$$/status |grep <span class="string">&#x27;_allowed&#x27;</span></span><br><span class="line">Cpus_allowed: 1</span><br><span class="line">Cpus_allowed_list:  0</span><br><span class="line">Mems_allowed: 00000000,00000001</span><br><span class="line">Mems_allowed_list:  0</span><br></pre></td></tr></table></figure><h3 id="Пример-2-управление-памятью"><a href="#Пример-2-управление-памятью" class="headerlink" title="Пример 2: управление памятью"></a>Пример 2: управление памятью</h3><p>Встроим созданную в предыдущем примере группу ещё в одну подсистему:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /sys/fs/cgroup/memory/group0</span><br></pre></td></tr></table></figure><p>Далее выполним:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $$ &gt; /sys/fs/cgroup/memory/group0/tasks</span><br></pre></td></tr></table></figure><p>Попробуем ограничить для контрольной группы group0 потребление памяти. Для этого нам понадобится прописать соответствующий лимит в файле memory.limit_in_bytes:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 40M &gt; /sys/fs/cgroup/memory/group0/memory.limit_in_bytes</span><br></pre></td></tr></table></figure><p>Механизм cgroups предоставляет очень обширные возможности управления памятью. Например, с его помощью мы можем оградить критически важные процессы от попадания под горячую руку OOM-killer’a:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /sys/fs/cgroup/memory/group0/memory.oom_control</span><br><span class="line">$ cat /sys/fs/cgroup/memory/group0/memory.oom_control</span><br><span class="line">oom_kill_disable 1</span><br><span class="line">under_oom 0</span><br></pre></td></tr></table></figure><p>Если мы поместим в отдельную контрольную группу, например, ssh-демон и отключим для этой группы OOM-killer, то мы можем быть уверены в том, что он не будет «убит» при преувеличении потребления памяти.</p><h3 id="Пример-3-управление-устройствами"><a href="#Пример-3-управление-устройствами" class="headerlink" title="Пример 3: управление устройствами"></a>Пример 3: управление устройствами</h3><p>Добавим нашу контрольную группу ещё в одну иерархию:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /sys/fs/cgroup/devices/group0</span><br></pre></td></tr></table></figure><p>По умолчанию у группы нет никаких ограничений доступа к устройствам:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/fs/cgroup/devices/group0/devices.list </span><br><span class="line">a *:* rwm</span><br></pre></td></tr></table></figure><p>Попробуем выставить ограничения:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;c 1:3 rmw&#x27;</span> &gt; /sys/fs/cgroup/devices/group0/devices.deny</span><br></pre></td></tr></table></figure><p>Эта команда включит устройство /dev/null в список запрещённых для нашей контрольной группы. Мы записали в управляющий файл строку вида ‘c 1:3 rmw’. Сначала мы указываем тип устройства — в нашем случае это символьное устройство, обозначаемое буквой с (сокращение от character device). Два других типа устройств — это блочные (b) и все возможные устройства (а). Далее следуют мажорный и минорный номера устройства. Узнать номера можно с помощью команды вида:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l  /dev/null</span><br></pre></td></tr></table></figure><p>Вместо /dev/null, естественно, можно указать любой другой путь. Вывод этой команды выглядит так:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crw-rw-rw- 1 root root 1, 3 May 30 10:49 /dev/null</span><br></pre></td></tr></table></figure><p>Первая цифра в выводе — это мажорный, а вторая — минорный номер.</p><p>Три последние буквы означают права доступа: r — разрешение читать файлы с указанного устройства, w — разрешение записывать на указанное устройство, m — разрешение создавать новые файлы устройств.</p><p>Далее выполним:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $$ &gt; /sys/fs/cgroup/devices/group0/tasks </span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;test&quot;</span> &gt; /dev/null</span><br></pre></td></tr></table></figure><p>При выполнении последней команды система выдаст сообщение об ошибке:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: /dev/null: Operation not permitted</span><br></pre></td></tr></table></figure><p>С устройством /dev/null мы никак взаимодействовать не можем, потому что доступ закрыт.</p><p>Восстановим доступ:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> a &gt; /sys/fs/cgroup/devices/group0/devices.allow</span><br></pre></td></tr></table></figure><p>В результате выполнения этой команды в файл /sys/fs/cgroup/devices/group0/devices.allow будет добавлена запись a <em>:</em> rwm, и все ограничения будут сняты.</p><h2 id="Cgroups-и-контейнеры"><a href="#Cgroups-и-контейнеры" class="headerlink" title="Cgroups и контейнеры"></a>Cgroups и контейнеры</h2><p>Из приведённых примеров понятно, в чём заключается принцип работы cgroups: мы помещаем определённые процессы в группу, которую затем «встраиваем» в подсистемы. Разберём теперь более сложные примеры и рассмотрим, как cgroups используются в современных инструментах контейнеризации на примере LXC.</p><p>Установим LXC и создадим контейнер:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install lxc debootstrap bridge-utils</span><br><span class="line">$ sudo lxc-create -n ubuntu -t ubuntu -f /usr/share/doc/lxc/examples/lxc-veth.conf</span><br><span class="line">$ lxc-start -d -n ubuntu </span><br></pre></td></tr></table></figure><p>Посмотрим, что изменилось в директории cgroups после создания и запуска контейнера:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ls /sys/fs/cgroup/memory</span><br><span class="line"></span><br><span class="line">cgroup.clone_children  memory.limit_in_bytes            memory.swappiness</span><br><span class="line">cgroup.event_control   memory.max_usage_in_bytes        memory.usage_in_bytes</span><br><span class="line">cgroup.procs           memory.move_charge_at_immigrate  memory.use_hierarchy</span><br><span class="line">cgroup.sane_behavior   memory.numa_stat                 notify_on_release</span><br><span class="line">lxc                    memory.oom_control               release_agent</span><br><span class="line">memory.failcnt         memory.pressure_level            tasks</span><br><span class="line">memory.force_empty     memory.soft_limit_in_bytes</span><br></pre></td></tr></table></figure><p>Как видим, в каждой иерархии появилась директория lxc, которая в свою очередь содержит поддиректорию Ubuntu. Для каждого нового контейнера в директории lxc будет создаваться отдельная поддиректория. PID всех запускаемых в этом контейнере процессов будут записываться в файл /sys/fs/cgroup/cpu/lxc/[имя контейнера]/tasks</p><p>Выделять ресурсы для контейнеров можно как с помощью управляющих файлов cgroups, так и с помощью специальных команд lxc, например:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lxc-cgroup -n [имя контейнера] memory.limit_in_bytes 400</span><br></pre></td></tr></table></figure><p>Аналогичным образом дело обстоит с контейнерами Docker, systemd-nspawn и другими.</p><h2 id="Недостатки-cgroups"><a href="#Недостатки-cgroups" class="headerlink" title="Недостатки cgroups"></a>Недостатки cgroups</h2><p>На протяжении почти 10 лет существования механизм cgroups неоднократно подвергался критике. Как отметил автор одной <a href="https://lwn.net/Articles/484251/">статьи на LWN.net</a>, разработчики ядра cgroups активно не любят. Причины такой нелюбви можно понять даже из приведённых в этой статье примеров, хоть мы и старались подавать их максимально нейтрально, без эмоций: встраивать контрольную группу в каждую подсистему по отдельности очень неудобно. Присмотревшись повнимательней, мы увидим, что такой подход отличается крайней непоследовательностью.</p><p>Если мы, например, создаём вложенную контрольную группу, то в некоторых подсистемах настройки родительской группы наследуются, а в некоторых — нет.</p><p>В подсистеме cpuset любое изменение в родительской контрольной группе автоматически передаётся вложенным группам, а в других подсистемах такого нет и нужно активировать параметр clone.children.</p><p>Об устранении этих и других недостатков cgroups разговоры в сообществе разработчиков ядра шли очень давно: <a href="https://lwn.net/Articles/484254/">один из первых текстов на эту тему датируется началом 2012 года</a>.</p><p>Автор этого текста, инженер Facebook Течжен Хе, прямо указал, что главная проблема cgroups заключается в неправильной организации, при которой подсистемы подключаются к многочисленным иерархиям контрольных групп. Он предложил использовать одну и только одну иерархию, а подсистемы добавлять для каждой группы отдельно. Такой подход повлёк за собой серьёзные изменения вплоть до смены названия: механизм изоляции ресурсов теперь называется <a href="https://www.kernel.org/doc/Documentation/cgroup-v2.txt">cgroup</a> (в единственном числе), а не cgroups.</p><p>Разберёмся более подробно в сути реализованных нововведений.</p><h2 id="Cgroup-v2-что-нового"><a href="#Cgroup-v2-что-нового" class="headerlink" title="Cgroup v2: что нового"></a>Cgroup v2: что нового</h2><p>Как уже было отмечено выше, сgroup v2 был включён в ядро Linux начиная с версии ядра 4.5. При этом старая версия поддерживается тоже. Для версии 4.6 уже существует патч, с помощью которого можно отключить поддержку первой версии при загрузке ядра.</p><p>На текущий момент в cgroup v2 можно работать только с тремя подсистемами: blkio, memory и PID. Уже появились (пока что в тестовом варианте) патчи, позволяющие управлять ресурсами CPU.</p><p>Cgroup v2 монтируется при помощи следующей команды:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -t cgroup2 none [точка монтирования]</span><br></pre></td></tr></table></figure><p>Предположим, мы смонтировали cgroup 2 в директорию /cgroup2. В этой директории будут автоматически созданы следующие управляющие файлы:</p><ul><li>cgroup.controllers — содержит список поддерживаемых подсистем;</li><li>cgroup.procs — по завершении монтирования содержит список всех выполняемых процессов в системе, включая процессы-зомби. Если мы создадим группу, то для неё тоже будет создан такой файл; он будет пустым, пока в группу не добавлены процессы;</li><li>cgroup.subtree_control — содержит список подсистем, активированных для данной контрольной группы; по умолчанию пуст.</li></ul><p>Эти же самые файлы создаются в каждой новой контрольной группе. Также в группу добавляется файл cgroup.events, который в корневой директории отсутствует.</p><p>Новая группа создаётся так:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /cgroup2/group1</span><br></pre></td></tr></table></figure><p>Чтобы добавить для группы подсистему, нужно записать имя этой подсистемы в файл cgroup.subtree_control:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;+pid&quot;</span> &gt; /cgroup2/group1/cgroup.subtree_control</span><br></pre></td></tr></table></figure><p>Для удаления подсистемы используется аналогичная команда, только на место плюса ставится минус:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;-pid&quot;</span> &gt; /cgroup2/group1/cgroup.subtree_control</span><br></pre></td></tr></table></figure><p>Когда для группы активируется подсистема, в ней создаются дополнительные управляющие файлы. Например, после активации подсистемы PID в директории появятся файлы pids.max и pids.current. Первый из этих файлов используется для ограничения числа процессов в группе, а второй — содержит информацию о числе процессов, включённых в группу на текущий момент.</p><p>Внутри уже имеющихся групп можно создавать подгруппы:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /cgroup2/group1/subgroup1</span><br><span class="line">$ mkdir /cgroup2/group1/subgroup2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;+memory&quot;</span> &gt; /cgroup2/group1/cgroup.subtree_control, </span><br></pre></td></tr></table></figure><p>Все подгруппы наследуют характеристики родительской группы. В только что приведённом примере подсистема PID будет активирована как для группы group1, так и для обеих вложенных в неё подгрупп; в них также будут добавлены файлы pids.max и pids.current. Сказанное можно проиллюстрировать с помощью схемы:</p><p><img src="/images/cgroup1.png" alt="пример активации cgroup"></p><p>Чтобы избежать недоразумений с вложенными группами (см. выше), в cgroup v2 действует следующее правило: нельзя добавить процесс во вложенную группу, если в ней уже активирована какая-либо подсистема:</p><p><img src="/images/cgroup1.png" alt="пример активации cgroup"></p><p>В первой версии cgroups процесс мог входить в несколько подгрупп одновременно, если эти подгруппы входили в разные иерархии, встроенные в разные подсистемы. Во второй версии один процесс может принадлежать только к одной подгруппе, что позволяет избежать путаницы.</p><h2 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h2><p>В этой статье мы рассказали, как устроен механизм cgroups и какие изменения были внесены в его новую версию. Если у вас есть вопросы и дополнения — добро пожаловать в комментарии.</p><p>Для всех, кто хочет глубже погрузиться в тему, приводим список ссылок на интересные материалы:</p><p><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt</a> — документация первой версии cgroups;<br><a href="https://www.kernel.org/doc/Documentation/cgroup-v2.txt">https://www.kernel.org/doc/Documentation/cgroup-v2.txt</a> — документация cgroup v2;<br><a href="https://www.youtube.com/watch?v=PzpG40WiEfM">https://www.youtube.com/watch?v=PzpG40WiEfM</a> — лекция Течжена Хе о нововведениях cgroup v2;<br><a href="https://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf">https://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf</a> — презентация доклада о cgroup v2 с подробными разъяснениями всех нововведений и изменений.</p><p><img src="/images/isolate.png" alt="Вот вам и cgroup"></p>]]></content>
    
    
    <summary type="html">Cgroups - механизм управления ресурсами в Linux, позволяющий изолировать процессы и устройства</summary>
    
    
    
    <category term="ОС" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/"/>
    
    <category term="Namespaces" scheme="https://goxpert.ru/categories/%D0%9E%D0%A1/Namespaces/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>SSA правила в GO</title>
    <link href="https://goxpert.ru/2024/06/01/common/ssa/"/>
    <id>https://goxpert.ru/2024/06/01/common/ssa/</id>
    <published>2024-06-01T07:23:00.000Z</published>
    <updated>2024-06-04T16:12:04.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Статическая-форма-с-одним-заданием-Static-single-assignment-form"><a href="#Статическая-форма-с-одним-заданием-Static-single-assignment-form" class="headerlink" title="Статическая форма с одним заданием (Static single-assignment form)"></a>Статическая форма с одним заданием (Static single-assignment form)</h1><ul><li>SSA (Static Single Assignment) - форма представления кода, используемая в компиляторах для оптимизации. </li><li>SSA представляет код в виде набора функций, каждая из которых описывает часть исходного кода. </li><li>Форма SSA упрощает анализ и оптимизацию кода, особенно для блочно-локальных переменных. </li><li>Блочные аргументы являются альтернативой Φ-функциям и могут быть более удобными при оптимизации. </li><li>Форма SSA обычно не используется для прямого исполнения, но часто используется поверх другой IR. </li><li>Расширения к форме SSA включают изменения в критерии переименования и функционально-ориентированные расширения. </li><li>Компиляторы, использующие форму SSA, включают Mono, WebKit, Swift, Erlang, LLVM, GCC, и другие</li></ul><p>Подробней можно почитать  <a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">здесь</a>, если необходимо разъяснить, то пишите внизу в комментариях<br>В конструкции компилятора статическая форма одиночного присваивания (часто называемая формой SSA или просто SSA ) — это тип промежуточного представления (IR), где каждой переменной присваивается ровно один раз. SSA используется в большинстве высококачественных оптимизирующих компиляторов для императивных языков, включая LLVM , GNU Compiler Collection и многие коммерческие компиляторы.</p><p><img src="/images/golang_ssa.png" alt="Вот вам и SSA"></p><h1 id="SSA-правила-в-GO"><a href="#SSA-правила-в-GO" class="headerlink" title="SSA правила в GO"></a>SSA правила в GO</h1><p>В компиляторе gc для описания Static Single Assignment (SSA) правил оптимизаций используется специальный Лисп-подобный предметно-ориентированный язык (DSL).</p><p>Предлагаю разобрать основные элементы этого языка, его особенности и ограничения.<br>В качестве упражнения, добавим в Go компилятор генерацию инструкции, которую он раньше не генерировал, оптимизируя выражение a*b+c.</p><p>Это первая статья из серии про внутренности Go SSA compiler backend, поэтому помимо обзора самого DSL описания правил мы рассмотрим связанные компоненты, чтобы создать необходимую базу для нашей следующей сессии.</p><h1 id="Введение"><a href="#Введение" class="headerlink" title="Введение"></a>Введение</h1><p>Frontend Go компилятора заканчивается на моменте генерации SSA представления из аннотированного AST. Функции, ответственные за конвертацию можно найти в <a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/ssa.go">cmd/compile/internal/gc/ssa.go</a>. Точкой входа в SSA backend является функция ssa.Compile, определённая в файле <a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/compile.go">cmd/compile/internal/ssa/compile.go</a>.</p><table><thead><tr><th>EN</th><th>RU</th><th>Значение</th></tr></thead><tbody><tr><td>Compiler frontend</td><td>Фронтенд компилятора</td><td>Парсинг и лексический анализ, иногда разрешение типов, промежуточное представление близко к исходному коду, обычно какое-нибудь аннотированное AST.</td></tr><tr><td>Compiler backend</td><td>Бэкенд компилятора</td><td>Более низкоуровневые оптимизации и промежуточное представление, кодогенерация.</td></tr><tr><td>Form</td><td>Форма</td><td>Практически синоним слову “выражение” (expression). Обычно в Лиспах form — довольно распространённый способ именовать элемент программы, будь то список или атом.</td></tr><tr><td>Optimization pass</td><td>Фаза оптимизации</td><td>Выполнение определённого алгоритма над программой. Слово “проход” несколько неоднозначно, потому что одна фаза может выполнять несколько проходов, и/или использовать общий с другими фазами код.</td></tr></tbody></table><p>Если по мере прочтения статьи вы нашли совершенно непонятный для вас термин, стоит сообщить об этом, возможно он будет добавлен в эту таблицу.</p><p>SSA оптимизатор Go состоит из нескольких фаз, каждая из которых выполняет проходы по компилируемой функции. Некоторые фазы используют так называемые “rewrite rules”, правила преобразования одних SSA последовательностей в другие, потенциально более оптимальные.</p><p>Правила преобразования описываются с помощью <a href="https://en.wikipedia.org/wiki/S-expression">S-выражений</a>. Элементы этих выражений — <a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/value.go#L19">ssa.Value</a>. В простейшем случае эти правила позволяют заменить один ssa.Value на другой.</p><p>Например, код ниже сворачивает умножение 8-битных констант:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Mul8 (Const8 [c]) (Const8 [d])) -&gt; (Const8 [int64(int8(c*d))])</span><br></pre></td></tr></table></figure><p>Есть две основные категории SSA значений: высокоуровневые, почти не зависящие от целевой машины и те, что архитектурно-специфичны (обычно отображаются на машинные инструкции 1-в-1).</p><p>Оптимизации описываются в терминах этих двух категорий. Сначала высокоуровневые и общие для всех архитектур, затем платформенно-ориентированные.</p><p>Весь код, связанный с правилами, лежит в <a href="https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa/gen">cmd/compile/internal/ssa/gen</a>. Мы будем рассматривать два набора:</p><ol><li><a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/gen/genericOps.go">genericOps.go</a> — машино-независимые операции.</li><li><a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/gen/AMD64Ops.go">AMD64Ops.go</a> — операции, специфичные для GOARCH=AMD64 (64-bit x86).</li></ol><p>После нескольких первых фаз, которые работают над абстрактной машиной, выполняется так называемый lowering, в результате которого происходит переход из genericOps в набор конкретной архитектуры. В нашем примере это будет AMD64Ops. После этого момента, все последующие фазы оперируют над представлением из второй категории.</p><p>После оптимизатора в игру вступает кодогенератор. Для AMD64 реализацию кодогенерации можно найти в пакете <a href="https://github.com/golang/go/tree/master/src/cmd/compile/internal/amd64">cmd/compile/internal/amd64</a>. Задача кодогенератора — заменить ssa.Block и ssa.Value в последовательность <a href="https://github.com/golang/go/blob/0dc814cd7f6a5c01213169be17e823b69e949ada/src/cmd/internal/obj/link.go#L271">obj.Prog</a>, передаваемые <a href="https://github.com/golang/go/tree/master/src/cmd/internal/obj/x86">ассемблеру</a>. Ассемблер соберёт машинный код, который будет готов к исполнению после <a href="https://github.com/golang/go/tree/master/src/cmd/link">линковки</a>.</p><h2 id="Правила-оптимизаций"><a href="#Правила-оптимизаций" class="headerlink" title="Правила оптимизаций"></a>Правила оптимизаций</h2><p>Если файлы с определениями операций имеют название вида “${ARCH}Ops.go”, то правила оптимизаций размещаются в “${ARCH}.Rules”.</p><p>Высокоуровневые правила выполняют простейшие преобразования, большую часть <a href="https://en.wikipedia.org/wiki/Constant_folding">сворачивания константных выражений</a>, а также некоторые преобразования, которые упрощают последующую обработку.</p><p>Каждый файл с низкоуровневыми правилами состоит из двух частей:</p><ol><li>Lowering — замена абстрактных операций на машинные эквиваленты.</li><li>Непосредственно сами оптимизации.</li></ol><p>Пример сведения операции к машинной:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(Const32 [val]) -&gt; (MOVLconst [val]) // L - long, 32-бита</span><br><span class="line">(Const64 [val]) -&gt; (MOVQconst [val]) // Q - quad, 64-бита</span><br><span class="line"> |                  |</span><br><span class="line"> generic op         |</span><br><span class="line">                   AMD64 op</span><br></pre></td></tr></table></figure><p>Именно в низкоуровневых оптимизациях выполняется основное количество важных оптимизаций, таких как <a href="https://en.wikipedia.org/wiki/Strength_reduction">снижение стоимости операций</a>, частичное встраивание и утилизация возможностей доступных в процессоре <a href="https://en.wikipedia.org/wiki/Addressing_mode">режимов адресации памяти</a>.</p><p>Операции имеют мнемоническое имя, которое обычно называется опкодом (opcode). Опкоды архитектурно-зависимых операций, как правило, отражают названия реальных инструкций.</p><h2 id="Синтаксис-языка-описания-правил"><a href="#Синтаксис-языка-описания-правил" class="headerlink" title="Синтаксис языка описания правил"></a>Синтаксис языка описания правил</h2><p>Базовая грамматика описана в <a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/gen/rulegen.go">rulegen.go</a>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rule syntax:</span></span><br><span class="line"><span class="comment">//    sexpr [&amp;&amp; extra conditions] -&gt; [@block] sexpr</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sexpr are s-expressions (lisp-like parenthesized groupings)</span></span><br><span class="line"><span class="comment">// sexpr ::= [variable:](opcode sexpr*)</span></span><br><span class="line"><span class="comment">//         | variable</span></span><br><span class="line"><span class="comment">//         | &lt;type&gt;</span></span><br><span class="line"><span class="comment">//         | [auxint]</span></span><br><span class="line"><span class="comment">//         | &#123;aux&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// aux      ::= variable | &#123;code&#125;</span></span><br><span class="line"><span class="comment">// type     ::= variable | &#123;code&#125;</span></span><br><span class="line"><span class="comment">// variable ::= some token</span></span><br><span class="line"><span class="comment">// opcode   ::= one of the opcodes from the *Ops.go files</span></span><br></pre></td></tr></table></figure><p>Перевод сниппера выше</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// синтаксис правил:</span></span><br><span class="line"><span class="comment">//    sexpr [&amp;&amp; дополнительные условия] -&gt; [@block] sexpr</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sexpr - это S-выражений (группирование в стиле Лиспа)</span></span><br><span class="line"><span class="comment">// sexpr ::= [variable:](opcode sexpr*)</span></span><br><span class="line"><span class="comment">//         | variable</span></span><br><span class="line"><span class="comment">//         | &lt;type&gt;</span></span><br><span class="line"><span class="comment">//         | [auxint]</span></span><br><span class="line"><span class="comment">//         | &#123;aux&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// aux      ::= variable | &#123;code&#125;</span></span><br><span class="line"><span class="comment">// type     ::= variable | &#123;code&#125;</span></span><br><span class="line"><span class="comment">// variable ::= Go переменная (любой токен)</span></span><br><span class="line"><span class="comment">// opcode   ::= опкод из *Ops.go файла</span></span><br></pre></td></tr></table></figure><p>Стоит также упомянуть, что внутри .Rules файлов разрешены “//“ комментарии.</p><p>Разберём простой пример, который содержит все эти элементы:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   Opcode=ADDLconst - сложение аргумента с 32-битной константой</span><br><span class="line">     :    AuxInt=c - константа, которая прибавляется к `x`</span><br><span class="line">     :      :</span><br><span class="line">(ADDLconst [c] x) &amp;&amp; int32(c)==0 -&gt; x</span><br><span class="line">|              /  |           /     |</span><br><span class="line">|             /   |          /      |</span><br><span class="line">|            /    |         /       Форма для замены</span><br><span class="line">|           /     Условие замены (через `&amp;&amp;` можно добавить ещё условий)</span><br><span class="line">Форма, которую мы пытаемся заменить</span><br></pre></td></tr></table></figure><ul><li>Все эти пояснительные подписи не являются частью валидной записи правил.</li></ul><p>Данное правило преобразует x+0 в x. Всё внутри секции условий — это обычный Go код,<br>разве что ограниченный до выражений, результатом которых должен быть bool.<br>Можно вызывать предикаты, определённые в <a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/rewrite.go">rewrite.go</a>.</p><p>Кроме обычных опкодов, могут использоваться комбинации, которые порождают несколько правил:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(ADD(Q|L)const [off] x:(SP)) -&gt; (LEA(Q|L) [off] x)</span><br><span class="line">// Уберём Q|L alternation:</span><br><span class="line">(ADDQconst [off] x:(SP)) -&gt; (LEAQ [off] x)</span><br><span class="line">(ADDLconst [off] x:(SP)) -&gt; (LEAL [off] x)</span><br><span class="line">// Уберём привязку к `x`:</span><br><span class="line">(ADDQconst [off] (SP)) -&gt; (LEAQ [off] (SP))</span><br><span class="line">(ADDLconst [off] (SP)) -&gt; (LEAL [off] (SP))</span><br></pre></td></tr></table></figure><ul><li>(SP) — это одна из операций в genericOps.go и выражает загрузку указателя на аппаратный стек. Для архитектур, где аппаратного SP нет, он эмулируется.</li></ul><p>Особенности переменных в шаблонах (S-выражения слева от -&gt;):</p><ul><li>Переменные, типа x, без выражения через :, захватывают что угодно</li><li>аналогично обычной переменной, _ захватывает любое значение, но результат можно игнорировать</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Оба правила делают одно и то же: реализуют функцию идентичности ADDQconst,</span><br><span class="line">// то есть они возвращают совпавшую с шаблоном форму без изменений:</span><br><span class="line">(ADDQconst _) -&gt; v</span><br><span class="line">(ADDQconst x) -&gt; (ADDQconst x)</span><br></pre></td></tr></table></figure><p>Если AuxInt не указан (выражение в квадратных скобках), то правило будет срабатывать на любом значении AuxInt. Аналогично с {}-параметрами (о них ниже).</p><p>Имя v означает самую внешнюю захваченную форму.<br>Например, для выражения (ADDQconst (SUBQconst x)) внешней формой является ADDQconst.</p><p>Переменные можно использовать несколько раз, это позволяет требовать соответствия нескольких частей S-выражения между собой:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(ADDQconst [v] (ADDQconst [v] x))</span><br><span class="line">// Сработает, например, для &quot;x+2+2&quot; (x+v+v).</span><br></pre></td></tr></table></figure><h2 id="Типы-в-правилах"><a href="#Типы-в-правилах" class="headerlink" title="Типы в правилах"></a>Типы в правилах</h2><p>В некоторых случаях требуется явно указывать тип генерируемой и/или сопостовляемой формы.<br>Указывается тип в “треугольных скобках”, как аргумент-тип в шаблонах C++:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// typ.UInt32 - тип операции BTSLconst.</span><br><span class="line">// BSFL имеет фиксированный тип typ.UInt32, поэтому указывать для</span><br><span class="line">// него тип не требуется.</span><br><span class="line">(Ctz16 x) -&gt; (BSFL (BTSLconst &lt;typ.UInt32&gt; [16] x))</span><br></pre></td></tr></table></figure><p>Кроме типов, существуют “символы” (или, более универсально — Aux свойства).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(StaticCall [argsWidth] &#123;target&#125; mem) -&gt; (CALLstatic [argsWidth] &#123;target&#125; mem)</span><br></pre></td></tr></table></figure><ul><li>[argsWidth] — Value.AuxInt. Для StaticCall — суммарный размер передаваемых аргументов</li><li>{target} — Value.Aux. Для StaticCall — вызываемая функция</li><li>&lt;typ.UInt32&gt; — Value.Type. Тип значения</li></ul><p>Семантика Aux и AuxInt сильно варьируется от операции к операции. Лучшим источником документации в данном случае являются *Ops.go файлы. У каждого определения опкода opData есть поле aux, которое описывает как именно интерпретировать эти поля.</p><p>Для описания типов используется пакет <a href="https://github.com/golang/go/tree/master/src/cmd/compile/internal/types">cmd/compile/internal/types</a>. Некоторые типы специфичны для SSA бэкенда, например types.TypeFlags, остальные общие между cmd/compile/internal/gc и cmd/compile/internal/ssa.</p><h2 id="Особые-типы"><a href="#Особые-типы" class="headerlink" title="Особые типы"></a>Особые типы</h2><p>Существует особый тип types.TypeMem, который выполняет сразу несколько функций:</p><ol><li>Позволяет сортировать и группировать ssa.Value по паттернам доступа к памяти. В частности, это гарантирует правильный порядок выполнения в рамках базовых блоков (о них ниже).</li><li>Определяет состояние потока памяти в программе. Если инструкция модифицирует память, новое SSA значение с типом types.TypeMem будет сгенерировано в результате этой операции.</li></ol><p>Подобно особому значению OpPhi, память интерпретируется исключительным образом во многих фазах оптимизатора.</p><ul><li>Phi имеет роль, которая немного меняется от фазы к фазе.<br>В самом начале работы SSA части компилятора, Phi служит своей классической цели и выражает выбор значения в зависимости от пути исполнения, который привёл нас к этому значению.<br>Например, если в блок есть два прыжка, и оба модифицируют память, то блок-назначение получит память равную (Phi mem1 mem2). Циклы также протаскивают Phi значение.</li></ul><p>Другим особым типом является упомянутый выше types.TypeFlags. Этот тип описывает генерацию инструкцией <a href="https://en.wikipedia.org/wiki/FLAGS_register">CPU флагов</a>.</p><p>При этом инструкции, вроде ADDQ, хоть и генерируют флаги, не имеют тип types.Flags, но отмечены атрибутом clobberFlags.</p><p>types.Flags используется для выделения результата инструкций вроде CMPQ, которые не пишут результат ни в один из своих явных операндов, а только обновляют внутреннее состояние процессора, которое может использоваться следующей инструкцией.</p><p>Инструкции, вроде SETL позволяют “прочитать” флаги и вернуть их в виде ssa.Value, который может быть размещён в регистре.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> L-less than               G-greater than</span><br><span class="line"> |                         |</span><br><span class="line">(SETL (InvertFlags x)) -&gt; (SETG x)</span><br><span class="line">                   |</span><br><span class="line">                   Форма, генерирующая флаги</span><br></pre></td></tr></table></figure><h2 id="Инспекция-SSA-программы"><a href="#Инспекция-SSA-программы" class="headerlink" title="Инспекция SSA программы"></a>Инспекция SSA программы</h2><p>Допустим, у нас есть такая программа (example.go):</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fusedMulAdd</span><span class="params">(a, b, c <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a*c + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Мы можем просмотреть SSA код, который сгенерирован для функции fusedMulAdd:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ GOSSAFUNC=fusedMulAdd go tool compile example.go &gt; ssa.txt</span><br></pre></td></tr></table></figure><p>Теперь проверьте рабочую (текущую) директорию:</p><ul><li>ssa.txt содержит тектовой дамп.</li><li>ssa.html, который генерируется автоматически, содержит ту же информацию, но в более интерактивном и удобночитабельном формате. Попробуйте открыть в браузере.</li></ul><p>Символ ~r3 переименован в ret для выразительности.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v7  (4) MOVSD a(SP), X0</span><br><span class="line">v11 (4) MOVSD c+16(SP), X1</span><br><span class="line">v12 (4) MULSD X1, X0</span><br><span class="line">v6  (4) MOVSD b+8(SP), X1</span><br><span class="line">v13 (4) ADDSD X1, X0</span><br><span class="line">v15 (4) MOVSD X0, ret+24(SP)</span><br><span class="line">b1  (4) RET</span><br></pre></td></tr></table></figure><p><img src="/images/golang_ssa2.png" alt="Вот вам и ssa.html"></p><p>Если вам почему-то захотелось это скопировать:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lower [77667 ns]</span><br><span class="line">b1:</span><br><span class="line">    v1 (?) = InitMem &lt;mem&gt;</span><br><span class="line">    v2 (?) = SP &lt;uintptr&gt;</span><br><span class="line">    v7 (?) = LEAQ &lt;*float64&gt; &#123;~r3&#125; v2</span><br><span class="line">    v8 (3) = Arg &lt;float64&gt; &#123;a&#125;</span><br><span class="line">    v9 (3) = Arg &lt;float64&gt; &#123;b&#125;</span><br><span class="line">    v10 (3) = Arg &lt;float64&gt; &#123;c&#125;</span><br><span class="line">    v12 (+4) = MULSD &lt;float64&gt; v8 v10</span><br><span class="line">    v13 (4) = ADDSD &lt;float64&gt; v12 v9</span><br><span class="line">    v14 (4) = VarDef &lt;mem&gt; &#123;~r3&#125; v1</span><br><span class="line">    v15 (4) = MOVSDstore &lt;mem&gt; &#123;~r3&#125; v2 v13 v14</span><br><span class="line">Ret v15 (line +4)</span><br></pre></td></tr></table></figure><p>Переводя это в S-выражения:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(MOVQstore &#123;~r3&#125; </span><br><span class="line">           (SP)</span><br><span class="line">           (ADDSD (MULSD (Arg &#123;a&#125;)</span><br><span class="line">                         (Arg &#123;c&#125;))</span><br><span class="line">                  (Arg &#123;b&#125;)))</span><br></pre></td></tr></table></figure><p>Так выглядит вывод ssa.html для фазы regalloc.</p><p><img src="/images/golang_ssa2.png" alt="Вот вам и ssa.html"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">regalloc [87237 ns]</span><br><span class="line">b1:</span><br><span class="line">    v1 (?) = InitMem &lt;mem&gt;</span><br><span class="line">    v14 (4) = VarDef &lt;mem&gt; &#123;~r3&#125; v1</span><br><span class="line">    v2 (?) = SP &lt;uintptr&gt; : SP</span><br><span class="line">    v8 (3) = Arg &lt;float64&gt; &#123;a&#125; : a[float64]</span><br><span class="line">    v9 (3) = Arg &lt;float64&gt; &#123;b&#125; : b[float64]</span><br><span class="line">    v10 (3) = Arg &lt;float64&gt; &#123;c&#125; : c[float64]</span><br><span class="line">    v7 (4) = LoadReg &lt;float64&gt; v8 : X0</span><br><span class="line">    v11 (4) = LoadReg &lt;float64&gt; v10 : X1</span><br><span class="line">    v12 (+4) = MULSD &lt;float64&gt; v7 v11 : X0</span><br><span class="line">    v6 (4) = LoadReg &lt;float64&gt; v9 : X1</span><br><span class="line">    v13 (4) = ADDSD &lt;float64&gt; v12 v6 : X0</span><br><span class="line">    v15 (4) = MOVSDstore &lt;mem&gt; &#123;~r3&#125; v2 v13 v14</span><br><span class="line">Ret v15 (line +4)</span><br></pre></td></tr></table></figure><h2 id="Добавление-новых-правил-оптимизаций"><a href="#Добавление-новых-правил-оптимизаций" class="headerlink" title="Добавление новых правил оптимизаций"></a>Добавление новых правил оптимизаций</h2><p>На процессорах с FMA мы можем вычислять a*c + b за одну инструкцию вместо двух.</p><p>Возьмём за основу <a href="https://go-review.googlesource.com/c/go/+/117295">CL117295</a> за авторством <a href="https://github.com/TocarIP">Ильи Токаря</a>.</p><p>Для вашего удобства, я подготовил <a href="https://gist.github.com/Quasilyte/0d4dbb0f8311f38d00a7b2d25dcec704">минимальный diff патч</a>.</p><h2 id="1-Добавление-новой-операции-—-FMASD"><a href="#1-Добавление-новой-операции-—-FMASD" class="headerlink" title="1. Добавление новой операции — FMASD"></a>1. Добавление новой операции — FMASD</h2><p>В файле compile/internal/ssa/gen/AMD64Ops.go найдите переменную-слайс AMD64ops и добавьте туда новый элемент (в любое место):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; // fp64 fma</span><br><span class="line">  name: &quot;FMASD&quot;,      // Опкод для SSA</span><br><span class="line">  argLength: 3,</span><br><span class="line">  reg: fp31,          // Информация для regalloc, спецификатор регистров</span><br><span class="line">  resultInArg0: true, // Первый аргумент является и source, и destination</span><br><span class="line">  asm: &quot;VFMADD231SD&quot;, // Ассемблерный опкод</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>Поскольку ранее (fp,fp,fp -&gt; fp) операций не было, нужно определить новый спецификатор:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  fp01     = regInfo&#123;inputs: nil, outputs: fponly&#125;</span><br><span class="line">  fp21     = regInfo&#123;inputs: []regMask&#123;fp, fp&#125;, outputs: fponly&#125;</span><br><span class="line">+ fp31     = regInfo&#123;inputs: []regMask&#123;fp, fp, fp&#125;, outputs: fponly&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Добавление-правила-оптимизации"><a href="#2-Добавление-правила-оптимизации" class="headerlink" title="2. Добавление правила оптимизации"></a>2. Добавление правила оптимизации</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ADDSD (MULSD x y) z) -&gt; (FMASD z x y)</span><br></pre></td></tr></table></figure><p>Более правильная реализация не была бы безусловной и проверяла бы доступность FMA. Мы будем считать, что на нашей целевой машине FMA точно есть.</p><p>В компиляторе для подобных проверок используется config:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Если config.useFMA=false, оптимизация выполняться не будет.</span><br><span class="line">(ADDSD (MULSD x y) z) &amp;&amp; config.useFMA-&gt; (FMASD z x y)</span><br></pre></td></tr></table></figure><p>Как проверить поддержку FMA?<br>Если в системе доступен lscpu, то, например так:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lscpu | grep fma</span><br></pre></td></tr></table></figure><h2 id="3-Реализация-кодогенерации"><a href="#3-Реализация-кодогенерации" class="headerlink" title="3. Реализация кодогенерации"></a>3. Реализация кодогенерации</h2><p>Теперь в функцию ssaGenValue, определённую в файле compile/internal/amd64/ssa.go, нужно добавить кодогенерацию для FMASD:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ssaGenValue</span><span class="params">(s *gc.SSAGenState, v *ssa.Value)</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> v.Op &#123;</span><br><span class="line">  <span class="keyword">case</span> ssa.OpAMD64FMASD:</span><br><span class="line">    p := s.Prog(v.Op.Asm()) <span class="comment">// Создание нового obj.Prog в текущем блоке</span></span><br><span class="line">    <span class="comment">// From: первый source операнд.</span></span><br><span class="line">    p.From = obj.Addr&#123;Type: obj.TYPE_REG, Reg: v.Args[<span class="number">2</span>].Reg()&#125;</span><br><span class="line">    <span class="comment">// To: destination операнд.</span></span><br><span class="line">    <span class="comment">// v.Reg() возвращает регистр, который был выделен для результата FMASD.</span></span><br><span class="line">    p.To = obj.Addr&#123;Type: obj.TYPE_REG, Reg: v.Reg()&#125;</span><br><span class="line">    <span class="comment">// From3: второй source операнд.</span></span><br><span class="line">    <span class="comment">// Название From3 историческое. На самом деле заполняется</span></span><br><span class="line">    <span class="comment">// поле RestArgs, который содержит все source операнды, кроме первого.</span></span><br><span class="line">    p.SetFrom3(obj.Addr&#123;</span><br><span class="line">      Type: obj.TYPE_REG,</span><br><span class="line">      Reg: v.Args[<span class="number">1</span>].Reg(),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> v.Reg() != v.Args[<span class="number">0</span>].Reg() &#123; <span class="comment">// Валидация условия resultInArg0</span></span><br><span class="line">      s := v.LongString()</span><br><span class="line">      v.Fatalf(<span class="string">&quot;input[0] and output not in same register %s&quot;</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// Остальной код остаётся неизменным, мы только добавляем новый case.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Теперь всё готово, чтобы проверять работу нашей новой оптимизации. Добавлять новые инструкции приходится очень редко, обычно новые оптимизации делают на основе уже определённых SSA операций.</p><h2 id="Проверка-результатов"><a href="#Проверка-результатов" class="headerlink" title="Проверка результатов"></a>Проверка результатов</h2><p>Первым шагом является генерация Go кода из обновлённых gen/AMD64Ops.go и gen/AMD64.Rules.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Если GOROOT не задан, перейдите в директорию, которую выводит `go env GOROOT`.</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOROOT</span>/src/cmd/compile/internal/ssa/gen &amp;&amp; go run *.go</span><br></pre></td></tr></table></figure><p>Далее нужно собрать наш новый компилятор:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install cmd/compile</span><br></pre></td></tr></table></figure><p>Теперь при компиляции того же примера, мы получим иной машинный код:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- v7  (4) MOVSD a(SP), X0</span><br><span class="line">- v11 (4) MOVSD c+16(SP), X1</span><br><span class="line">- v12 (4) MULSD X1, X0</span><br><span class="line">- v6  (4) MOVSD b+8(SP), X1</span><br><span class="line">- v13 (4) ADDSD X1, X0</span><br><span class="line">- v15 (4) MOVSD X0, ret+24(SP)</span><br><span class="line">- b1  (4) RET</span><br><span class="line">+ v12 (4) MOVSD b+8(SP), X0</span><br><span class="line">+ v7  (4) MOVSD a(SP), X1</span><br><span class="line">+ v11 (4) MOVSD c+16(SP), X2</span><br><span class="line">+ v13 (4) VFMADD231SD X2, X1, X0</span><br><span class="line">+ v15 (4) MOVSD  X0, ret+24(SP)</span><br><span class="line">+ b1  (4) RET</span><br></pre></td></tr></table></figure><h2 id="Базовые-блоки-basic-blocks"><a href="#Базовые-блоки-basic-blocks" class="headerlink" title="Базовые блоки (basic blocks)"></a>Базовые блоки (basic blocks)</h2><p>Теперь, когда самая сложная работа сделана, поговорим о <a href="https://en.wikipedia.org/wiki/Basic_block">базовых блоках</a>.</p><p>Значения, которые мы оптимизировали выше, находятся в блоках, а блоки находятся в функции.</p><p>Блоки, как и ssa.Value, бывают абстрактными и машино-зависимыми. Все блоки имеют ровно одну точку входа и от 0 до 2 блоков-назначений (зависит от типа блока).</p><p>Самыми простыми блоками являются If, Exit и Plain:</p><ul><li>Exit блок имеет 0 блоков-назначений. Это листовые блоки, которые совершают нелокальный прыжок, например, с помощью panic.</li><li>Plain блок имеет 1 блоков-назначение. Можно рассматривать как безусловный переход после выполнения всех инструкций блока в другой блок.</li><li>If блок имеет 2 блока-назначения. Переход осуществляется в зависимости от условия (Block.Control).</li></ul><p>Вот простые примеры переписывания абстрактных блоков в блоки AMD64:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                Тело &quot;then&quot; (является блоком)</span><br><span class="line">                |   Тело &quot;else&quot; (является блоком)</span><br><span class="line">                |   |</span><br><span class="line">(If (SETL  cmp) yes no) -&gt; (LT cmp yes no)</span><br><span class="line">(If (SETLE cmp) yes no) -&gt; (LE cmp yes no)</span><br></pre></td></tr></table></figure><p>Тему блоков более подробно будем рассматривать в контексте других оптимизирующих фаз в SSA части компилятора.</p><h2 id="Ограничения-правил-оптимизаций"><a href="#Ограничения-правил-оптимизаций" class="headerlink" title="Ограничения правил оптимизаций"></a>Ограничения правил оптимизаций</h2><p>У SSA бэкенда есть свои преимущества. Некоторые оптимизации выполнимы за O(1). Однако есть и недостатки, из-за которых одного лишь SSA оптимизатора будет маловато, по крайней мере пока не изменятся некоторые аспекты его реализации.</p><p>Предположим, вы хотите выполнять слияние вызовов append:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xs = <span class="built_in">append</span>(xs, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">xs = <span class="built_in">append</span>(xs, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line">xs = <span class="built_in">append</span>(xs, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><p>На момент, когда SSA сгенерирован, высокоуровневая структура кода утрачена и append, будучи не обычной функцией, уже встроен в тело содержащего блока. Вам придётся писать громоздкое правило, которое захватывает всю сгенерированную для append последовательность операций.</p><p>Если говорить конкретно о .Rules, то в этом DSL довольно слабая работа с блоками (ssa.Block). Любая нетривиальная оптимизация, связанная с блоками, невозможна для выражения на этом языке. Частичное обновление блока невозможно. Выбрасывать блоки тоже невозможно (но есть хак в виде First блока, который используется для удаления мёртвого кода).</p><ul><li>Даже если часть недостатков исправима, большинство компиляторов сходятся во мнении, что нет единой и лучшей промежуточной формы для представления кода.</li></ul><h2 id="Go-that-goes-faster"><a href="#Go-that-goes-faster" class="headerlink" title="Go that goes faster"></a>Go that goes faster</h2><p>Если придумаете какие-то крутые правила оптимизации, смело высылайте на go-review.googlesource.com. Буду рад произвести ревью (добавляйте в CC <a href="mailto:&#105;&#115;&#107;&#97;&#110;&#100;&#x65;&#114;&#46;&#115;&#x68;&#x61;&#x72;&#x69;&#112;&#111;&#118;&#64;&#x69;&#110;&#x74;&#101;&#108;&#x2e;&#x63;&#111;&#109;">&#105;&#115;&#107;&#97;&#110;&#100;&#x65;&#114;&#46;&#115;&#x68;&#x61;&#x72;&#x69;&#112;&#111;&#118;&#64;&#x69;&#110;&#x74;&#101;&#108;&#x2e;&#x63;&#111;&#109;</a>).</p><p>Счастливого хакинга компилятора!</p><p><img src="/images/golang_ssa4.gif" alt="Вот вам и ssa.html"></p><h2 id="Бонусный-материал"><a href="#Бонусный-материал" class="headerlink" title="Бонусный материал"></a>Бонусный материал</h2><p>Примеры хороших патчей в Go, которые добавляли или изменяли SSA rules:</p><p><a href="https://go-review.googlesource.com/c/go/+/99656">CL99656: cmd/compile/internal/ssa: emit IMUL3{L/Q} for MUL{L/Q}const on x86</a><br>CL102277: cmd/compile/internal/ssa: optimize away double NEG on amd64<br>CL54410: cmd/compile/internal/ssa: use sse to zero on amd64<br>CL58090: cmd/compile/internal/ssa: remove redundant zeroextensions on amd64<br>CL95475: cmd/compile/internal/ssa: combine byte stores on amd64<br>CL97175: cmd/compile/internal/ssa: combine consecutive LittleEndian stores on arm64<br>CL115617: cmd/compile/internal/ssa: remove useless zero extension<br>CL101275: cmd/compile: add amd64 LEAL{1,2,4,8} ops</p><p>Не так давно появился <a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/README.md">README</a> документ для описания SSA части компилятора.<br>Рекомендуется к прочтению.</p>]]></content>
    
    
    <summary type="html">Статическая форма с одним заданием в GO</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="SSA" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/SSA/"/>
    
    <category term="SSA" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/SSA/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>SOLID в GO</title>
    <link href="https://goxpert.ru/2024/06/01/common/solid_go/"/>
    <id>https://goxpert.ru/2024/06/01/common/solid_go/</id>
    <published>2024-06-01T07:22:00.000Z</published>
    <updated>2024-06-04T08:39:42.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SOLID-дизайн-Go"><a href="#SOLID-дизайн-Go" class="headerlink" title="SOLID дизайн Go"></a>SOLID дизайн Go</h1><p>Этот пост на основе текста из основного доклада GolangUK прошедшего 18-ого Августа 2016.<br>Запись выступления <a href="https://www.youtube.com/watch?v=zzAdEt3xZ1M">доступна в YouTube</a>.</p><h2 id="Как-много-программистов-на-Go-в-мире"><a href="#Как-много-программистов-на-Go-в-мире" class="headerlink" title="Как много программистов на Go в мире?"></a>Как много программистов на Go в мире?</h2><p>Как много программистов на Go в мире? Подумайте о числе и держите его в своей голове,<br>мы вернемся к этому вопросу в конце разговора.</p><h2 id="Рецензирование-кода"><a href="#Рецензирование-кода" class="headerlink" title="Рецензирование кода"></a>Рецензирование кода</h2><p>Кто здесь проводит рецензирование кода, как часть своей работы? (большая часть аудитории поднимает свои руки, что обнадеживает). Хорошо, почему вы делаете рецензирование кода? (кто то выкрикивает “чтобы сделать код лучше”)</p><p>Если рецензирование кода нужно для того, чтобы отловить плохой код, тогда как вы узнаете, что код, который вы рецензируете, хороший или плохой?</p><p>Сейчас это нормально сказать “этот код ужасен” или “ого, этот код прекрасен”, точно так же, как если бы вы сказали “эта живопись прекрасна” или “эта комната прекрасна”, но это субъективные понятия, а я ищу объективные пути, чтобы говорить о свойствах хорошего или плохого кода.</p><h2 id="Плохой-код"><a href="#Плохой-код" class="headerlink" title="Плохой код"></a>Плохой код</h2><p>Какими могут быть свойства плохого кода, которые вы можете использовать при рецензировании?</p><ul><li>Негибкий. Является ли код негибким? Содержит ли он жесткий набор типов и параметров, что затрудняет модификацию.</li><li>Хрупкий. Является ли код хрупким? Вызывает ли хаос малейшее изменение кодовой базы?</li><li>Неподвижный. Сложно ли код поддается рефакторингу? Находится ли он в одном нажатии клавиши от цикличного импорта?</li><li>Cложный. Существует ли этот код только ради кода и не является ли он переусложненным?</li><li>Многословный. Использование кода изнурительно? Можете ли вы глядя на код сказать, что он пытается сделать?</li></ul><p>Относятся ли эти слова к позитивным? Доставило бы вам удовольствие слышать эти слова при рецензировании вашего кода?</p><p>Возможно, что нет.</p><h2 id="Хороший-дизайн"><a href="#Хороший-дизайн" class="headerlink" title="Хороший дизайн"></a>Хороший дизайн</h2><p>Но это улучшение, теперь мы можем сказать что то вроде “мне не нравится это потому, что слишком сложно модифицировать”, или “мне не нравится это потому, что я не могу сказать, что этот код пытается сделать”, но что насчет того, чтобы вести обсуждение позитивно?</p><p>Разве это не было бы здорово, если бы существовал способ описать свойства хорошего дизайна, а не только плохого и иметь возможность рассуждать объективными терминами?</p><h1 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h1><p>В 2002 году Роберт Мартин опубликовал свою книгу <a href="https://www.amazon.co.uk/dp/0135974445/ref=pd_lpo_sbs_dp_ss_2/253-1946330-6751666?pf_rd_m=A3P5ROKL5A1OLE&pf_rd_s=lpo-top-stripe&pf_rd_r=23C4AHYV7EXGYHKD6G8Q&pf_rd_t=201&pf_rd_p=569136327&pf_rd_i=0132760584">Agile Software Development, Principles, Patterns, and Practices</a>. В ней он описал пять принципов переиспользуемого дизайна програмного обеспечения, которые он назвал SOLID принципами, аббревиатурой их названий.</p><ul><li>Принцип единственной ответственности (SRP) Single Responsibility Principle</li><li>Принцип открытости/закрытости (OCP) Open / Closed Principle</li><li>Принцип подстановки Барбары Лисков  (LSP) Liskov Substitution Principle</li><li>Принцип разделения интерфейса (ISP) Interface Segregation Principle</li><li>Принцип инверсии зависимостей (DIP) Dependency Inversion Principle</li></ul><p>Эта книга слегка устарела, языки о которых ведется разговор использовались порядка 10 лет назад. Но, возможно, существуют некоторые аспекты SOLID принципа, которые могут предоставить нам ключ к разгадке того, как говорить о хорошо разработанных программах на Go.</p><p>Это именно то, что я хотел бы обсудить с вами этим утром.</p><h2 id="1-Принцип-единственной-ответственности"><a href="#1-Принцип-единственной-ответственности" class="headerlink" title="1. Принцип единственной ответственности"></a>1. Принцип единственной ответственности</h2><h3 id="Первый-принцип-SOLID-это-S-—-принцип-единой-ответственности"><a href="#Первый-принцип-SOLID-это-S-—-принцип-единой-ответственности" class="headerlink" title="Первый принцип SOLID, это S — принцип единой ответственности."></a>Первый принцип SOLID, это S — принцип единой ответственности.</h3><ul><li>Класс должен иметь одну и только одну причину для изменений. -Роберт С. Мартин</li></ul><p>Go совершенно не содержит классов, вместо них мы имеем гораздо более мощную концепцию композиции, но если вы посмотрите на историю использования понятия класс, я думаю здесь есть определенный смысл.</p><p>Почему это так важно, чтобы один участок кода имел только одну причину для изменений? Чтож, идея того, что ваш код может изменяться мучительна, но она гораздо менее тягостная, чем то, что код от которого зависит ваш код, тоже может изменяться. И когда ваш код должен изменяться, он должен делать это в соответствии с конкретным требованием, а не быть жертвой сопутствуюещго ущерба.</p><p>Итак код, который отвечает за единственную задачу, будет иметь меньше причин для внесения изменений.</p><h3 id="Связанность-amp-Единство"><a href="#Связанность-amp-Единство" class="headerlink" title="Связанность &amp; Единство"></a>Связанность &amp; Единство</h3><p>Два слова, которые описывают на сколько просто вносить изменения в вашу программу, это связанность и единство.<br>Связанность - это просто понятие которое описывает одновременное изменение в двух участках кода, когда изменения в одном месте означает обязательное изменение в другом.</p><p>Смежное, но отдельное понятие, это единство — сила взаимного притяжения.</p><p>В контексте программного обеспечения единство - это свойство описывающее то, что участки кода естественно связанны между собой.</p><p>Чтобы описать реализацию принципов связанности и единство в программе на Go, мы могли бы поговорить о функциях и методах, как это часто бывает при обсуждении SRP(принципа единой ответственности), но я верю, что все начинается с системы пакетов в Go.</p><h3 id="Имена-пакетов"><a href="#Имена-пакетов" class="headerlink" title="Имена пакетов"></a>Имена пакетов</h3><p>В Go весь код существует внутри пакетов, и хороший дизайн пакета начинается с его имени. Имя пакета-это и описание его назначения и префикс пространства имен. В качестве примера хороших имен пакетов из стандартной библиотеки Go, можно привести:</p><ul><li>net/http, который предоставляет http клиент и сервер.</li><li>os/exec, который запускает внешние команды.</li><li>encoding/json, который реализует кодирование и декодирование документов JSON.</li></ul><p>Когда вы используете символы другого пакета внутри своего собственного, это выполняется с помощью ключевого слова import, которое устанавливает связанность на уровне исходного кода между двумя пакетами. Теперь они знают о существовании друг друга.</p><h3 id="Плохие-имена-пакетов"><a href="#Плохие-имена-пакетов" class="headerlink" title="Плохие имена пакетов"></a>Плохие имена пакетов</h3><p>Подобное фокусирование на именовании не просто педантичность. Плохо именованные пакеты упускают возможность описать свою задачу, даже если бы она у них была.</p><p>Какую возможность предоставляет package server?.. возможно это сервер, но с какой протокол он реализует?</p><p>Какую возможность предоставляет package private? Штуки, которые я не должен увидеть? Должен ли он вообще иметь какие -то публичные символы?</p><p>И package common, ровно как и его соучастник package utils часто находятся рядом с другими злостными нарушителями.</p><p>Привлечение подобных пакетов, превращает код в свалку потому, что они имеют много обязанностей и часто изменяются без причины.</p><h3 id="Филисофия-UNIX-в-Go"><a href="#Филисофия-UNIX-в-Go" class="headerlink" title="Филисофия UNIX в Go"></a>Филисофия UNIX в Go</h3><p>В моем представлении, никакое обсуждение раздельного дизайна не будет полным без упоминания труда Дугласа Маклроя “Филисофия UNIX”; мелкие, острые инструменты, которые сочетаются для решения более крупных задач, часто таких, которые не были предусмотренны оригинальными авторами. Я думаю что пакеты Go воплощают дух философии UNIX. В действительности каждый пакет Go сам по себе -это маленькая Go программа, единственная точка изменений с единственной ответственностью.</p><h2 id="2-Принцип-открытости-закрытости"><a href="#2-Принцип-открытости-закрытости" class="headerlink" title="2. Принцип открытости/закрытости"></a>2. Принцип открытости/закрытости</h2><p>Второй принцип O — принцип открытости / закрытости Бертрана Мейера, который в 1988 году писал:</p><ul><li>Програмные объекты должны быть открыты для расширения и закрыты для модификации.</li><li>Бертран Мейер, Построение Объектно-Ориентированного Программного Обеспечения<br>Как этот совет применялся для языков созданных 21 год назад?</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">  year <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span> <span class="title">Greet</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;Hello GolangUK&quot;</span>, a.year) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">   A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b B)</span> <span class="title">Greet</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;Welcome to GolangUK&quot;</span>, b.year) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a A</span><br><span class="line">  a.year = <span class="number">2016</span></span><br><span class="line">  <span class="keyword">var</span> b B</span><br><span class="line">  b.year = <span class="number">2016</span></span><br><span class="line">  a.Greet() <span class="comment">// Hello GolangUK 2016</span></span><br><span class="line">  b.Greet() <span class="comment">// Welcome to GolangUK 2016</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>У нас есть тип A, с полем year и методом Greet. Мы имеем второй тип B в который встроен A, вызовы методов B перекрывают вызовы методов A поскольку A встроен, как поле в B и B предлогает свой собственный метод Greet скрывая аналогичный в A.</p><p>Но встраивание существует не только для методов, оно также предоставляет доступ к встроенным полям типа. Как вы можете увидеть, поскольку оба A и B определены в одном пакете, B может получить доступ к приватному полю year в A, как будто оно было определенно внутри B.</p><p>Итак встраивание-это мощный инструмент, который позволяет типам в Go быть открытыми для расширения.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Legs</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">PrintLegs</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;I have %d legs\n&quot;</span>, c.Legs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OctoCat <span class="keyword">struct</span> &#123;</span><br><span class="line">  Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o OctoCat)</span> <span class="title">Legs</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">5</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> octo OctoCat</span><br><span class="line">  fmt.Println(octo.Legs()) <span class="comment">// 5</span></span><br><span class="line">  octo.PrintLegs()         <span class="comment">// I have 4 legs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере у нас есть тип Cat, который может посчитать колличество ног с помощью своего метода Legs. Мы встраиваем этот тип Cat в новый тип OctoCat и декларируем то, что OctocatS имеет пять ног. При этом OctoCat определяет свой собственный метод Legs, который возвращается 5, когда вызывается метод PrintLegs, он возвращает 4.</p><p>Это происходит потому, что PrintLegs определен внутри типа Cat. Он принимает Cat в качестве ресивера и отсылает к методу Legs типа Cat. Cat должен знать о типе в который он был встроен, поэтому его метод не может быть изменен встраиванием.</p><p>Отсюда мы можем сказать, что типы в Go открыты для расширения и закрыты для модификации.</p><p>На самом деле методы в Go это несколько больше, чем просто синтаксический сахар вокруг функции с преобъявленными формальными параметрами, они являются ресиверами.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">PrintLegs</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;I have %d legs\n&quot;</span>, c.Legs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintLegs</span><span class="params">(c Cat)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;I have %d legs\n&quot;</span>, c.Legs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ресивер - это в точности то, что вы передаете в него, первый параметр функции и посколько Go не поддерживает перегрузку функций, OctoCat не является взаимозаменяемым с обычным типом Cats. Что подводит меня к следующему принципу.</p><h2 id="3-Принцип-подстановки-Барбары-Лисков"><a href="#3-Принцип-подстановки-Барбары-Лисков" class="headerlink" title="3. Принцип подстановки Барбары Лисков"></a>3. Принцип подстановки Барбары Лисков</h2><p>Придуманный Барбарой Лисков, принцип подстановки Лисков утверждает, что два типа являются взаимозаменяемыми, если они проявляют такое поведение, при котором вызывающий не может определить разницу.</p><p>В языке основанном на классах, принцип подстановки Лисков часто интерпретируется, как спецификация для абстрактного класса с различными конкретными подтипами. Но в Go нет классов или наследования, потому подстановка не может быть реализованна в терминах иерархии абстратного класса.</p><h3 id="Интерфейсы"><a href="#Интерфейсы" class="headerlink" title="Интерфейсы"></a>Интерфейсы</h3><p>Вместо этого подстановка, это компетенция интерфейсов в Go. В Go от типов не требуют имплементации конкретного интерфейса, вместо этого любой тип имплементирующий интерфейс просто содержит метод чья сигнатура соответствует декларации интерфейса.</p><p>Мы говорим, что в Go интерфейсы удовлетворяются неявно вместо явного соответствия и это оказывает глубокое влияние на то, как они используются в языке.</p><p>Хорошо продуманный интерфейс, это скорее всего маленький интерфейс; преобладающая идиома это то, что интерфейс содержит только единственный метод. Вполне логично, что маленький интерфейс содержит простую имплементацию, поскольку сложно сделать иначе. Из чего следует, что пакеты -это компромисное решение простых имплементаций связанных обычным поведением.</p><h3 id="io-Reader"><a href="#io-Reader" class="headerlink" title="io.Reader"></a>io.Reader</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// Read reads up to len(buf) bytes into buf.</span></span><br><span class="line">  Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Что приводит меня к io.Reader моему любимому интерфейсу в Go.</p><p>Интерфейс io.Reader очень прост; Read читает данные в указанный буфер и возвращает вызывающему коду число байт, которые были прочитаны, и любую ошибку, которая может возникнуть в процесе чтения. Это выглядит просто, но это очень мощно.</p><p>Поскольку io.Reader имеет дело с чем угодно, что может быть выраженно как поток байт, мы может конструировать объекты читатели буквально из чего угодно; константной строки, массива байт, стандартного потока входа, сетевого потока, архива gzip tar, стандартного выходного потока или команды выполненной удаленно через ssh.</p><p>И все эти реализации взаимозаменяемы, поскольку они удовлетворяют одному простому контракту.</p><p>Итак, принцип подстановки Лисков применим в Go и сказанное можно суммировать прекрасным афоризмом покойного Джима Вейриха:</p><ul><li>Требуй не больше, обещай не меньше.-Джим Вейрих</li></ul><p>И это отличный переход к четвертому принципу SOLID.</p><h2 id="4-Принцип-разделения-интерфейса"><a href="#4-Принцип-разделения-интерфейса" class="headerlink" title="4. Принцип разделения интерфейса"></a>4. Принцип разделения интерфейса</h2><p>Четвертый принцип, это принцип разделения интерфейса, который читается, как:</p><ul><li>Клиенты не должны быть вынужденны зависеть от методов, которые они не используют. -Роберт С. Мартин</li></ul><p>В Go применение принципа разделения интерфейса может пониматься, как процесс изоляции поведения необходимого функции для выполнения ее работы. В качестве конкретного примера скажем, у меня есть задача написать функцию, которая сохраняет структуру Document на диск.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the file f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(f *os.File, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>Я могу определить такую функцию. давайте назовем ее Save, она принимает *os.File как источник для записи предоставленного Document. Но здесь возникает несколько проблем.</p><p>Сигнатура Save препятствует возможности записи данных по какому ту адресу в сети. Предположим, что сетевое хранилище скорее всего станет требованием в дальнейшем и сигнатура этой функции может измениться, что повлияет на всех, кто ее вызывает.</p><p>Поскольку Save оперирует непосредственно файлами на диске, тестировать ее довольно неприятно. Чтобы верифицировать операции тесты должны считать содержимое файла после записи. Кроме того тесты должны убедиться, что f был записан во временное хранилище и всегда удаляется впоследствии.</p><p>*os.File также определяет много методов, которые не релевантны Save, как чтение дирректорий и проверка того, является ли путь символической ссылкой. Было бы полезно, если бы сигнатура нашей функции Save была описанна только теми частями *os.File, которые релевантны ее задаче.</p><p>Что мы можем сделать с этими проблемами?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied ReadWriterCloser.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(rwc io.ReadWriteCloser, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>Используя io.ReadWriteCloser мы можем применить принцип разделения интерфейса для переопределения Save таким образом, чтобы она принимала интерфейс, который описывает более общие задачи операций с файлами.</p><p>С этими изменениями любой тип, который реализует интерфейс io.ReadWriteCloser может быть замещен предыдущим *os.File. Это делает применение Save более широким и поясняет стороне вызывающей Save, какой метод из типа *os.File релевантный требуемой операции.</p><p>Как автор Save я более не должен иметь возможность вызова всех нерелевантных методов из *os.File, поскольку они спрятанны за io.ReadWriteCloser интерфейсом. Но мы можем пойти немного дальше с методом разделения интерфейса.</p><p>Во-первых, вряд ли Save следует принципу единственной ответственности, он будет читать файл, в который только что произошла запись, чтобы проверить содержимое, что должно быть ответственностью другой части кода. Потому мы можем сузить спецификацию интерфейса, который мы передаем в Save исключительно до открытия и закрытия файла.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied WriteCloser.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(wc io.WriteCloser, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>Во-вторых, предоставляя Save с механизмом закрытия потока, который мы унаследовали с желанием сделать это похожим на обычный механизм работы с файлом, возникает вопрос, при каких обстоятельствах wc будет закрыт. Возможно Save будет вызывать Close без каки либо условий, или Close будет вызван в случае успеха.</p><p>Все это представляет пороблему для вызывающего Save, поскольку он может пожелать добавить дополнительную информацию в поток, после того, как документ уже записан.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NopCloser <span class="keyword">struct</span> &#123;</span><br><span class="line">        io.Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close has no effect on the underlying writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *NopCloser)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br></pre></td></tr></table></figure><p>Грубым решением будет определение нового типа, который встраивает io.Writer и переопределяет метод Close, предотвращая вызов Save из закрытого основного потока.</p><p>Но это будет скорее всего нарушением принципа подстановки Барбары Лисков, поскольку NopCloser на самом деле ничего не закрывает.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied Writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(w io.Writer, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>Куда лучше будет решение переопределить Save, принимая только io.Writer, полностью лишив его возможности делать что -то помимо записи данных в поток.</p><p>Но применяя принцип разделения интерфейса к нашей функции Save, результат одновременно становится функцией, которая наиболее специфична в условиях ее требований, единственное, что ей нужно — это что-то куда можно писать и наиболее важное в этой функции то, что мы можем использовать Save для сохранения наших данных в любое место, где реализован интерфейс io.Writer.</p><ul><li>Важное эмпирическое правило для Go, принимать интерфейсы, а возвращать структуры. -Джек Линдамуд<br>Приведенная выше цитата интересный мем, который просочился в дух Go в течении нескольких последних лет.</li></ul><p>В этой версии в рамках стандартного твита не хватает одного нюанса и это не вина Джека, но я думаю, что она представляет одну из главных причин появления приданий о дизайне языка Go.</p><h2 id="5-Принцип-инверсии-зависимостей"><a href="#5-Принцип-инверсии-зависимостей" class="headerlink" title="5. Принцип инверсии зависимостей"></a>5. Принцип инверсии зависимостей</h2><p>Последний принцип SOLID, это принцип инверсии зависимостей, который утверждает:</p><ul><li>Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба уровня должны зависеть от абстракций. Абстракции не должны зависеть от их деталей. Детали должны зависеть от абстракций. -Роберт С. Мартин<br>Но что означает инверсия зависмостей на практике для программиста на Go?</li></ul><p>Если вы применяете все принципы о которых мы говорили до этого момента, тогда ваш код уже должен быть расположен в дискретных пакетах, каждый с единственной и хорошо определенной зависимостью или целью. Ваш код должен описывать свои зависимости в терминах интерфейсов и эти интерфейсы должны быть направленны на описание исключительно того поведения, которое требуется этим функциям. Другими словами, не должно остаться много работы.</p><p>Итак, как я представляю себе то, о чем Мартин тут говорит, в основном в контексте Go-это структура вашего графа импортов.</p><p>В Go ваш граф импортов должен быть ацикличным. Попытка игнорирования ацикличности приведет к ошибке компиляции, но гораздо более серьезная ошибка может быть в архитектуре. При прочих равных условиях граф импорта хорошо разработанной Go программы должен быть широким и относительно плоским вместо того, чтобы быть высоким и узким. Если у вас есть пакет, функции которого не могут исполняться без привлечения помощи другого пакета, возможно это сигнал о том, что не достаточно хорошо определены границы пакета.</p><p>Принцип инверсии зависимостей поощряет вас переносить спецефическую ответственность на столько высоко, на сколько возможно в графе импортов, в ваш пакет main или на верхний уровень обработчика, оставляя нижний уровень кода работать с абстракциями и интерфейсами.</p><h2 id="SOLID-дизайн-Go-1"><a href="#SOLID-дизайн-Go-1" class="headerlink" title="SOLID дизайн Go"></a>SOLID дизайн Go</h2><p>В качестве резюме, когда каждый из принципов SOLID применяется в отношении Go они являются мощным инструментом дизайна, но используемые вместе, они являются главной темой.</p><p>Принцип единой ответственности поощряет вас стуктурировать функции, типы и методы в пакеты, которые естественно связанны между собой; типы и функции вместе служат единственной цели.</p><p>Принцип открытости / закрытости поощряет вас к компромису простых типов и более сложных путем использования встривания.</p><p>Принцип подстановки Барбары Лисков поощряет вас выражать зависимости между вашими пакетами в терминах интерфейсов, а не конкретных типов. Определяя небольшые интерфейсы мы можем быть более уверенны, что реализации будут удовлетворять своим контрактам.</p><p>Принцип разделения интерфейса продолжает эту идею и поощряет вас определять функции и методы которые зависят только на том поведении, которое им нужно. Если ваши функции нуждаются только в параметре типа интерфейса с единственным методом, тогда скорее всего эти функции имеют единственную ответственность.</p><p>Принцип инверсии заисимостей поощряет вас перемещать знания о зависимостях вашего пакета от этапа компиляции, в Go мы наблюдаем это с сокращением числа импортов используемых конкретным пакетом, на этап выполнения кода.</p><p>Если вы хотите подвести итог этого разговора, то скорее всего это будет: интерфейсы позволяют вам применять принципы SOLID в Go программах.</p><p>Поскольку интерфейсы позволяют программистам Go описывать возможности своих пакетов, а не конкретную реализацию. Все это просто еще один способ сказать “разъединение”, что и есть цель, поскольку слабосвязанный код легче поддается изменениям.</p><h3 id="Как-заметил-Санди-Метз"><a href="#Как-заметил-Санди-Метз" class="headerlink" title="Как заметил Санди Метз:"></a>Как заметил Санди Метз:</h3><ul><li>Дизайн - это искусство организации кода, который должен работать сегодня и легко поддаваться изменениям всегда. -Санди Метз</li></ul><p>Потому, что если Go планирует быть языком в который компании инвестируют в долгосрочной перспективе, то ключевым фактором в их решении будет то, на сколько легко поддерживать код на Go и как просто он поддается изменениям.</p><h2 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h2><p>В завершении давайте вернемся к вопросу, которым я открыл этот разговор. Как много программистов на Go во всем мире? Вот мое предположение:</p><ul><li>В 2020 году будет 500,000 разработчиков на Go.-Дейв Чейни<br>Что половина миллиона программистов на Go будут делать со своим временем? Чтож, очевидно, они будут писать много кода на Go и если мы будем честны, не весь код будет хорошим, часть кода будет плохим.</li></ul><p>Пожалуйста поймите, что я не пытаюсь быть жестоким, но каждый из вас в этой комнате с опытом разработки на других языках, языках из которых вы пришли в Go знает из собственного опыта, что в этом предсказании есть доля правды.</p><ul><li>В С++ есть гораздо более чистый и эволюционный язык, который пытается выйти. -Бьёрн Страуструп, Дизайн и Эволюция С++<br>Возможность помочь нашему языку добиться успеха для каждого программиста заключается в том, чтобы не создавать такой беспорядок, о котором люди начинают говорить, когда они шутят о C++ сегодня.</li></ul><p>Рассказы высмеивающие другие языки за то, что они раздуты, многословны и перегруженны однажды, могут быть применены в отношении Go и я не хочу, чтобы это случилось и потому у меня есть просьба.</p><p>Go программистам нужно перестать говорить о фреймворках и начать больше говорить о дизайне. Мы должны перестать фокусировать на производительности любой ценой и вместо этого сфокусироваться не переиспользовании любой ценой.</p><p>Я хотел бы увидеть сегодня, как люди говорят о том, как использовать язык, который у нас есть, независимо от их выбора и ограничений, чтобы создавать решения и решать реальные проблемы.</p><p>Я бы хотел услышать сегодня о том, как люди говорят о дизайне программ на Go таким способом, чтобы они были хорошо спроектированны, разъединенные, переиспользуемые и отзывчивые к изменениям.</p><h2 id="…-и-еще-одна-деталь"><a href="#…-и-еще-одна-деталь" class="headerlink" title="… и еще одна деталь"></a>… и еще одна деталь</h2><p>Сейчас это отлично, что так много людей сегодня пришли, чтобы послушать такой отличный состав спикеров, но реальность такова, что не важно на сколько эта конференция вырастет, в сравнении с общим числом людей, которые используют Go в течение всей его жизни, мы лишь малая часть.</p><p>Потому наша задача рассказать оставшейся части мира, как хорошее програмное обеспечение должно быть написанно. Хорошее програмное обеспечение, совместимое, поддающееся изменениям и показать им, как сделать это используя Go. И это начинается с тебя.</p><p>Я хочу, чтобы вы начали говорить о дизайне, возможно используйте часть идей, которые я представил тут, надеюсь вы проведете свое собственное исследование и примените эти идеи для своего проекта. Тогда я хочу чтобы вы:</p><ul><li>Написали пост в блоге об этом.</li><li>Расскажите на семинаре о том, что вы сделали.</li><li>Напишите книгу о том, чему вы научились.<br>И приходите снова на эту конференцию в следующем году и расскажите о том, чего вы добились.</li></ul><p>Делая все это мы сможем сформировать экосистему разработчиков на Go, которые заботятся о своих программах, разработанных для того, чтобы продолжать работать.</p><p>Спасибо.</p><p><img src="/images/golang_solid_the_best.jpg" alt="Вот вам и SOLID"></p>]]></content>
    
    
    <summary type="html">Принципы SOLID на примерах в GO</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="SOLID" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/SOLID/"/>
    
    <category term="SOLID" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/SOLID/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>SOLID</title>
    <link href="https://goxpert.ru/2024/06/01/common/solid/"/>
    <id>https://goxpert.ru/2024/06/01/common/solid/</id>
    <published>2024-06-01T07:21:00.000Z</published>
    <updated>2024-06-04T07:11:53.955Z</updated>
    
    <content type="html"><![CDATA[<p>Автор оригинала: Ugonna Thelma<br>Специально для сына Георгия. Он только начинает свой путь в программировании и мне хочется на простых примерах донести ему суть происходящего.</p><p><img src="/images/golang_solid1.png" alt="Поехали"></p><p>Если вы знакомы с объектно-ориентированным программированием, то наверняка слышали и о принципах SOLID. Эти пять правил разработки ПО задают траекторию, по которой нужно следовать, когда пишешь программы, чтобы их проще было масштабировать и поддерживать. Они получили известность благодаря программисту Роберту Мартину.</p><p>В Сети множество отличных статей, где рассказывается о принципах SOLID, но иллюстрированных среди них мне практически не попадалось. Из-за этого таким людям со склонностью к визуальному восприятию информации – таким, как я – бывает сложно схватывать суть и не отвлекаться.</p><p>Основная цель этой статьи – лучше усвоить принципы SOLID через отрисовку иллюстраций, а также определить назначение каждого принципа. Дело в том, что некоторые из принципов кажутся похожими, но функции выполняют разные. Может получиться так, что одному принципу следуешь, а другой при этом нарушаешь, хотя с виду особой разницы между ними нет.</p><p>Чтобы проще читалось, я упоминаю здесь только классы, однако всё сказанное в статье применимо также к функциям, методам и модулям, так что имейте это в виду.</p><h1 id="Принципы-SOLID"><a href="#Принципы-SOLID" class="headerlink" title="Принципы SOLID"></a>Принципы SOLID</h1><h2 id="S-–-Single-Responsibility-Принцип-единственной-ответственности"><a href="#S-–-Single-Responsibility-Принцип-единственной-ответственности" class="headerlink" title="S – Single Responsibility (Принцип единственной ответственности)"></a>S – Single Responsibility (Принцип единственной ответственности)</h2><ol><li>Каждый класс должен отвечать только за одну операцию.<br><img src="/images/golang_solid2.png" alt="Принцип единственной ответственности"></li></ol><p>Если класс отвечает за несколько операций сразу, вероятность возникновения багов возрастает – внося изменения, касающиеся одной из операций вы, сами того не подозревая, можете затронуть и другие.</p><h3 id="Назначение"><a href="#Назначение" class="headerlink" title="Назначение"></a>Назначение</h3><p>Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы.</p><h2 id="O-—-Open-Closed-Принцип-открытости-закрытости"><a href="#O-—-Open-Closed-Принцип-открытости-закрытости" class="headerlink" title="O — Open-Closed (Принцип открытости-закрытости)"></a>O — Open-Closed (Принцип открытости-закрытости)</h2><ol start="2"><li>Классы должны  быть  открыты для расширения, но закрыты для модификации.<br><img src="/images/golang_solid3.png" alt="Принцип открытости-закрытости"></li></ol><p>Когда вы меняете текущее поведение класса, эти изменения сказываются на всех системах, работающих с данным классом. Если хотите, чтобы класс выполнял больше операций, то идеальный вариант – не заменять старые на новые, а добавлять новые к уже существующим.</p><h3 id="Назначение-1"><a href="#Назначение-1" class="headerlink" title="Назначение"></a>Назначение</h3><p>Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.</p><h2 id="L-—-Liskov-Substitution-Принцип-подстановки-Барбары-Лисков"><a href="#L-—-Liskov-Substitution-Принцип-подстановки-Барбары-Лисков" class="headerlink" title="L — Liskov Substitution (Принцип подстановки Барбары Лисков)"></a>L — Liskov Substitution (Принцип подстановки Барбары Лисков)</h2><ol start="3"><li>Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.<br><img src="/images/golang_solid4.png" alt="Принцип подстановки Барбары Лисков"><br>В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, возникает риск появления ошибок.</li></ol><p>Если у вас имеется класс и вы создаете на его базе другой класс, исходный класс становится родителем, а новый – его потомком. Класс-потомок должен производить такие же операции, как и класс-родитель. Это называется наследственностью.</p><p>Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. Или же результат может отличаться, но при этом относиться к тому же типу. На картинке это показано так: класс-родитель подаёт кофе (в любых видах), значит, для класса-потомка приемлемо подавать капучино (разновидность кофе), но неприемлемо подавать воду.</p><p>Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от родителя и нарушает принцип.</p><h3 id="Назначение-2"><a href="#Назначение-2" class="headerlink" title="Назначение"></a>Назначение</h3><p>Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.</p><h2 id="I-—-Interface-Segregation-Принцип-разделения-интерфейсов"><a href="#I-—-Interface-Segregation-Принцип-разделения-интерфейсов" class="headerlink" title="I — Interface Segregation (Принцип разделения интерфейсов)"></a>I — Interface Segregation (Принцип разделения интерфейсов)</h2><ol start="4"><li>Не следует ставить клиент в зависимость от методов, которые он не использует<br><img src="/images/golang_solid5.png" alt="Принцип разделения интерфейсов"></li></ol><p>Когда классу приходится производить действия, не несущие никакой реальной пользы, это выливается в пустую трату ресурса, а в случае, если класс выполнять эти действия не способен, ведёт к возникновению багов.</p><p>Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.</p><h3 id="Назначение-3"><a href="#Назначение-3" class="headerlink" title="Назначение"></a>Назначение</h3><p>Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.</p><h2 id="D-—-Dependency-Inversion-Принцип-инверсии-зависимостей"><a href="#D-—-Dependency-Inversion-Принцип-инверсии-зависимостей" class="headerlink" title="D — Dependency Inversion (Принцип инверсии зависимостей)"></a>D — Dependency Inversion (Принцип инверсии зависимостей)</h2><ol start="5"><li>Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</li></ol><p>Для начала объясню термины, которые здесь применяются, простыми словами.</p><p>Модули (или классы) верхнего уровня = классы, которые выполняют операцию при помощи инструмента<br>Модули (или классы) нижнего уровня = инструменты, которые нужны для выполнения операций<br>Абстракции – представляют интерфейс, соединяющий два класса<br>Детали = специфические характеристики работы инструмента</p><p>Согласно данному принципу, класс не должен соединяться с инструментом, который применяет для выполнения операции. Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом.</p><p>Кроме того, принцип гласит, что ни интерфейс, ни класс, не обязаны вникать в специфику работы инструмента. Напротив, это инструмент должен подходить под требования интерфейса.</p><p>Назначение</p><p>Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.</p><p>Обобщая сказанное</p><p>Мы разобрали все пять принципов и сформулировали для каждого назначение. Всё это призвано помочь вам писать код, который можно модифицировать, расширять и тестировать с минимумом проблем. Спасибо, что прочитали; надеюсь, вы получили не меньше удовольствия, чем я в процессе работы над статьёй.</p><p><img src="/images/golang_solid1.png" alt="Вот вам и SOLID"></p>]]></content>
    
    
    <summary type="html">Принципы SOLID</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="SOLID" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/SOLID/"/>
    
    <category term="SOLID" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/SOLID/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Планировщик</title>
    <link href="https://goxpert.ru/2024/06/01/concurrency/scheduler/"/>
    <id>https://goxpert.ru/2024/06/01/concurrency/scheduler/</id>
    <published>2024-06-01T07:19:00.000Z</published>
    <updated>2024-06-02T18:11:35.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Как-работает-планировщик-в-Golang"><a href="#Как-работает-планировщик-в-Golang" class="headerlink" title="Как работает планировщик в Golang?"></a>Как работает планировщик в Golang?</h2><p>Планировщик в Golang - это механизм, который отвечает за распределение и выполнение горутин (G) на логических процессорах (P), которые в свою очередь работают на физических потоках (M) операционной системы. Планировщик в Golang использует модель M:N, то есть может запускать произвольное количество горутин на произвольном количестве потоков.</p><p>Горутина (G) - это легковесный поток выполнения, который может быть создан, переключен и уничтожен планировщиком Go без взаимодействия с операционной системой. Горутины занимают мало памяти и могут быть заспавнены в большом количестве. Горутины не привязаны к конкретному потоку или процессору, а могут динамически менять свой контекст выполнения.</p><p>Логический процессор (P) - это абстракция, которая представляет собой ресурс, необходимый для выполнения горутин. Каждый P имеет свою локальную очередь (LRQ), в которой хранятся горутины, ожидающие запуска. Количество P обычно равно количеству ядер в системе, чтобы максимально использовать параллелизм. P не может выполнять горутину самостоятельно, а нуждается в M для этого.</p><p>Физический поток (M) - это поток операционной системы, который может быть связан с P и выполнять горутину из LRQ. M может переключаться между разными P в зависимости от ситуации. Например, если M блокируется на системном вызове или операции ввода-вывода, он может быть отсоединен от P и заменен другим M. Также M может участвовать в процессе work stealing, когда он пытается украсть горутину из LRQ или глобальной очереди (GRQ) другого P.</p><p>Планировщик Go использует алгоритм work stealing для балансировки нагрузки между P. Если LRQ одного P пуста, он может попытаться украсть горутину из LRQ или GRQ другого P. Это позволяет эффективно использовать ресурсы и избегать простоя.</p><p>Источники:</p><ul><li><a href="https://habr.com/ru/articles/478168/">Habr</a></li><li><a href="https://habr.com/ru/articles/489862/">Habr</a></li><li><a href="https://backendinterview.ru/goLang/scheduler.html">Backend Interview</a></li></ul><h2 id="В-чем-разница-между-вытесняющим-и-кооперативным-планировщиком"><a href="#В-чем-разница-между-вытесняющим-и-кооперативным-планировщиком" class="headerlink" title="В чем разница между вытесняющим и кооперативным планировщиком?"></a>В чем разница между вытесняющим и кооперативным планировщиком?</h2><p>Вытесняющий планировщик - это такой планировщик, который может прервать выполнение текущей задачи в любой момент и передать управление другой задаче, если он посчитает это необходимым. Вытесняющий планировщик обычно использует таймер или другие прерывания, чтобы определить, когда нужно сменить задачу. Вытесняющий планировщик позволяет более эффективно распределять ресурсы между задачами и обеспечивать более высокую отзывчивость системы.</p><p>Кооперативный планировщик - это такой планировщик, который не может прервать выполнение текущей задачи, пока она сама не отдаст управление. Кооперативный планировщик полагается на то, что задачи будут добровольно освобождать процессор, когда они закончат свою работу или будут ждать ввода-вывода. Кооперативный планировщик проще в реализации и потребляет меньше ресурсов, но он может привести к проблемам с производительностью и справедливостью, если одна из задач будет занимать процессор слишком долго.</p><p>Если вы хотите узнать больше о том, в чем разница между вытесняющим и кооперативным планировщиком, вы можете посмотреть следующие источники:</p><ul><li><a href="https://habr.com/ru/articles/489862/">Планирование в Go: Часть II — Планировщик Go</a></li><li><a href="https://t-fakt.ru/raznica/raznicza-mezhdu-vytesnyayushhim-i-nevytesnyayushhim-planirovaniem-v-operaczionnyh-sistemah/">Разница между вытесняющим и невытесняющим планированием в операционных системах</a></li><li><a href="https://www.guru99.com/ru/preemptive-vs-non-preemptive-scheduling.html">Упреждающее и невытесняющее планирование</a></li></ul><h2 id="Какой-тип-планировщика-в-Golang"><a href="#Какой-тип-планировщика-в-Golang" class="headerlink" title="Какой тип планировщика в Golang?"></a>Какой тип планировщика в Golang?</h2><p>Планировщик в Golang - это вытесняющий планировщик с кооперативными элементами. </p><p>Это означает, что он может прервать выполнение текущей горутины в любой момент и передать управление другой горутине, если он посчитает это необходимым, но он также полагается на то, что горутины будут добровольно освобождать процессор, когда они будут ждать ввода-вывода или блокироваться на каналах.</p><p>Планировщик в Golang использует таймер или другие прерывания, чтобы определить, когда нужно сменить горутину, а также учитывает приоритеты и аффинность горутин к процессорам.</p><p>Источники:</p><ul><li><a href="https://habr.com/ru/articles/489862/">Планирование в Go: Часть II — Планировщик Go</a></li><li><a href="https://habr.com/ru/articles/478168/">Планирование в Go: Часть I — Планировщик ОС</a></li></ul><h2 id="В-планировщике-до-версии-1-15-какие-операции-приводят-к-переключению-контекста-горутин"><a href="#В-планировщике-до-версии-1-15-какие-операции-приводят-к-переключению-контекста-горутин" class="headerlink" title="В планировщике до версии 1.15 какие операции приводят к переключению контекста горутин?"></a>В планировщике до версии 1.15 какие операции приводят к переключению контекста горутин?</h2><p>В планировщике Golang до версии 1.15 переключение контекста горутин происходило только при выполнении следующих операций:</p><ul><li>Ожидание ввода-вывода (I/O), такого как чтение или запись в файл, сеть, канал или таймер.</li><li>Блокировка на мьютексе (mutex) или другом примитиве синхронизации.</li><li>Вызов функции runtime.Gosched, которая явно передает управление другой горутине.</li><li>Вызов функции runtime.GC, которая запускает сборку мусора и приостанавливает все горутины.</li><li>Вызов функции runtime.LockOSThread, которая привязывает горутину к одному системному потоку и не позволяет ей переключаться на другой.</li></ul><p>В версии 1.15 планировщик Golang стал вытесняющим, то есть он может прервать выполнение любой горутины, которая работает слишком долго, и передать управление другой горутине, если он посчитает это необходимым. Это улучшило отзывчивость и справедливость системы, а также уменьшило вероятность возникновения состояний гонки и взаимных блокировок.</p><h2 id="Можно-ли-руками-переключить-контекст-горутины"><a href="#Можно-ли-руками-переключить-контекст-горутины" class="headerlink" title="Можно ли руками переключить контекст горутины?"></a>Можно ли руками переключить контекст горутины?</h2><p>В общем случае, нет, нельзя руками переключить контекст горутины, так как это делает планировщик Golang автоматически, когда он посчитает это необходимым.</p><p>Однако, в некоторых редких случаях, можно руками переключить контекст горутины, используя низкоуровневые функции из пакета runtime, такие как runtime.Gopark и runtime.Goready, которые позволяют приостановить и возобновить горутину по собственному условию. Эти функции не рекомендуются для обычного использования, так как они могут привести к ошибкам и несовместимостям с планировщиком Golang.</p><p>Источники:</p><ul><li><a href="https://habr.com/ru/articles/489862/">Планирование в Go: Часть II — Планировщик Go</a></li><li><a href="https://habr.com/ru/articles/478168/">Планирование в Go: Часть I — Планировщик ОС</a></li></ul><h2 id="Сколько-потоков-операционной-системы-мы-можем-создать"><a href="#Сколько-потоков-операционной-системы-мы-можем-создать" class="headerlink" title="Сколько потоков операционной системы мы можем создать?"></a>Сколько потоков операционной системы мы можем создать?</h2><p>Количество потоков операционной системы, которые мы можем создать в Golang, зависит от нескольких факторов, таких как:</p><ul><li>Количество горутин (goroutines), которые мы запускаем в нашей программе.</li><li>Количество процессоров или ядер на компьютере. По умолчанию Golang создает столько системных потоков, сколько доступно логических процессоров на компьютере, но это можно изменить с помощью переменной окружения GOMAXPROCS.</li><li>Размер стека для каждого системного потока. Стек - это область памяти, которая используется для хранения локальных переменных, параметров и адресов возврата функций. Размер стека ограничивает количество системных потоков, которые могут быть созданы, так как память не бесконечна.</li></ul><h2 id="Расскажи-про-глобальную-и-локальную-очереди"><a href="#Расскажи-про-глобальную-и-локальную-очереди" class="headerlink" title="Расскажи про глобальную и локальную очереди"></a>Расскажи про глобальную и локальную очереди</h2><p>Глобальная и локальная очереди в Golang - это структуры данных, которые используются планировщиком Go для распределения горутин между логическими процессорами (P). Горутина - это легковесный поток выполнения, который может быть переключен планировщиком без блокировки операционной системы.</p><p>Глобальная очередь выполнения (GRQ) содержит горутины, которые еще не были назначены ни одному логическому процессору. Когда логический процессор создается или освобождается, он может взять горутину из GRQ и поместить ее в свою локальную очередь выполнения (LRQ). LRQ содержит горутины, которые принадлежат конкретному логическому процессору и ожидают своего запуска.</p><p>Планировщик Go использует алгоритм work stealing для балансировки нагрузки между логическими процессорами. Если LRQ одного логического процессора пуста, он может попытаться украсть горутину из LRQ другого логического процессора или из GRQ. Это позволяет эффективно использовать ресурсы и избегать простоя.</p><p>Источники: </p><ul><li><a href="https://habr.com/ru/articles/743266/">Habr</a></li><li><a href="https://habr.com/ru/articles/489862/">Habr</a></li></ul><h2 id="Может-ли-горутина-начать-работу-на-одном-P-приостановиться-и-продолжить-работу-на-другом-P"><a href="#Может-ли-горутина-начать-работу-на-одном-P-приостановиться-и-продолжить-работу-на-другом-P" class="headerlink" title="Может ли горутина начать работу на одном P, приостановиться и продолжить работу на другом P?"></a>Может ли горутина начать работу на одном P, приостановиться и продолжить работу на другом P?</h2><p>Да, горутина может переключаться между разными логическими процессорами (P) во время своей работы. Это может произойти по нескольким причинам, например:</p><ul><li>Горутина блокируется на операции ввода-вывода или системном вызове, и планировщик Go переназначает ее P другой горутине.</li><li>Горутина добровольно отступает от своего P, вызывая функцию yield или resume, которые позволяют использовать корутины в Go.</li><li>Горутина истекает свой квант времени, и планировщик Go прерывает ее выполнение и переводит ее в конец своей локальной очереди (LRQ).</li><li>Горутина становится жертвой work stealing, когда другой P, у которого пустая LRQ, пытается украсть горутину из LRQ или глобальной очереди (GRQ) другого P.</li></ul><p>Таким образом, горутины в Go не привязаны к конкретному P на всю свою жизнь, а могут динамически менять свой контекст выполнения в зависимости от ситуации. Это повышает эффективность и отзывчивость приложений, написанных на Go.</p><p>Источники: </p><ul><li><a href="https://habr.com/ru/articles/775532/">Habr</a></li><li><a href="https://habr.com/ru/articles/743266/">Habr</a></li><li><a href="https://habr.com/ru/articles/489862/">Habr</a></li></ul><h2 id="Может-ли-одна-очередь-украсть-горутины-у-другой"><a href="#Может-ли-одна-очередь-украсть-горутины-у-другой" class="headerlink" title="Может ли одна очередь украсть горутины у другой?"></a>Может ли одна очередь украсть горутины у другой?</h2><p>Да, одна очередь может украсть горутины у другой в процессе work stealing. Это алгоритм, который позволяет планировщику Go балансировать нагрузку между логическими процессорами (P). Когда один P имеет пустую локальную очередь (LRQ), он может попытаться украсть горутину из LRQ или глобальной очереди (GRQ) другого P. Это увеличивает вероятность того, что каждый P будет иметь работу, и избегает простоя.</p><h2 id="В-чем-профит-горутин-если-мы-можем-заспавнить-миллион-потоков-в-процессе-и-почему-упадет-процесс-с-таким-количеством-потоков-или-нет"><a href="#В-чем-профит-горутин-если-мы-можем-заспавнить-миллион-потоков-в-процессе-и-почему-упадет-процесс-с-таким-количеством-потоков-или-нет" class="headerlink" title="В чем профит горутин, если мы можем заспавнить миллион потоков в процессе, и почему упадет процесс с таким количеством потоков, или нет?"></a>В чем профит горутин, если мы можем заспавнить миллион потоков в процессе, и почему упадет процесс с таким количеством потоков, или нет?</h2><p>Профит горутин в том, что они легковеснее и эффективнее обычных потоков. Горутины занимают меньше памяти (порядка килобайтов), чем потоки (порядка мегабайтов), и могут динамически расти и уменьшаться в зависимости от потребностей. Горутины также имеют меньший оверхед на создание, переключение и уничтожение, чем потоки, которые требуют взаимодействия с операционной системой.</p><p>Если мы попытаемся заспавнить миллион потоков в процессе, то скорее всего процесс упадет из-за нехватки памяти или ресурсов. Каждый поток требует выделения стека, регистров, дескрипторов и других ресурсов, которые ограничены операционной системой. Кроме того, большое количество потоков приводит к частому переключению контекста, которое снижает производительность и увеличивает задержки.</p><p>В отличие от потоков, горутины могут быть заспавнены в большом количестве без существенных потерь производительности и памяти. Планировщик Go оптимально распределяет горутины между логическими процессорами (P), используя глобальную и локальные очереди, а также алгоритм work stealing. Таким образом, горутины позволяют писать высокопроизводительные и масштабируемые приложения на Go.</p><p><img src="/images/golang_scheduler.jpg" alt="Вот вам и scheduler"></p>]]></content>
    
    
    <summary type="html">Вопросы по планировщику Golang и OS.</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Планировщик" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"/>
    
    <category term="Планировщик" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Контекст</title>
    <link href="https://goxpert.ru/2024/06/01/concurrency/context/"/>
    <id>https://goxpert.ru/2024/06/01/concurrency/context/</id>
    <published>2024-06-01T07:18:00.000Z</published>
    <updated>2024-06-02T18:08:23.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-контекст"><a href="#Что-такое-контекст" class="headerlink" title="Что такое контекст?"></a>Что такое контекст?</h2><p>В Go, контекст (context) используется для передачи сигналов относительно отмены операций, таймаутов и передачи метаданных между API. Это особенно полезно в ситуациях, когда у вас есть множество горутин и вы хотите контролировать их выполнение.</p><p>В Go есть пакет context, который предоставляет функции и типы для работы с контекстами. Вы можете создать контекст с помощью функций <code>context.Background()</code> или <code>context.TODO()</code>. Затем вы можете создать дочерний контекст с помощью функций <code>context.WithCancel()</code>, <code>context.WithDeadline()</code>, <code>context.WithTimeout()</code>, или <code>context.WithValue()</code>.</p><p>Когда контекст отменяется, все горутины, которые получают этот контекст, получают сигнал об отмене, и они должны прекратить свою работу.</p><h2 id="Для-чего-используется-контекст"><a href="#Для-чего-используется-контекст" class="headerlink" title="Для чего используется контекст?"></a>Для чего используется контекст?</h2><p>Контекст в Go используется для нескольких целей:</p><ul><li>Отмена операций: Контекст может быть использован для отмены операций. Это особенно полезно, когда у вас есть долгосрочная операция, которая может быть отменена в любой момент. Когда контекст отменяется, все горутины, которые получают этот контекст, получают сигнал об отмене.</li><li>Таймауты: Контекст также может быть использован для установки таймаутов на операции. Это может быть полезно, когда вы хотите ограничить время выполнения операции.</li><li>Передача метаданных: Контекст может быть использован для передачи метаданных между API. Это может быть полезно, когда у вас есть информация, которую нужно передать между различными частями вашего приложения, например, информация о трассировке.</li><li>Контроль над горутинами: Контекст позволяет контролировать выполнение горутин, особенно когда у вас есть множество горутин и вы хотите контролировать их выполнение.</li></ul><h2 id="Какие-есть-виды-контекстов"><a href="#Какие-есть-виды-контекстов" class="headerlink" title="Какие есть виды контекстов?"></a>Какие есть виды контекстов?</h2><ul><li>Background: Это базовый контекст, который обычно используется, когда другой контекст не доступен. Это обычно используется в main функции, в тестах и в пакетах, которые не знают, в каком контексте они будут использоваться. Создается с помощью функции context.Background().</li><li>TODO: Этот контекст также используется, когда контекст не доступен. Он обычно используется, когда не ясно, какой контекст использовать, или когда контекст будет доступен в будущем. Создается с помощью функции context.TODO().</li><li>WithCancel: Этот контекст предоставляет возможность отмены. Когда функция cancel вызывается, все горутины, которые слушают этот контекст, получают сигнал об отмене. Создается с помощью функции context.WithCancel(parentContext).</li><li>WithDeadline и WithTimeout: Эти контексты предоставляют возможность установить время, после которого контекст будет автоматически отменен. WithDeadline принимает конкретное время, после которого контекст будет отменен, а WithTimeout принимает продолжительность времени, после которой контекст будет отменен. Создаются с помощью функций context.WithDeadline(parentContext, deadline) и context.WithTimeout(parentContext, timeout) соответственно.</li><li>WithValue: Этот контекст предоставляет возможность связать значения с контекстом, которые затем могут быть извлечены в другом месте в коде. Создается с помощью функции context.WithValue(parentContext, key, value).</li></ul><h2 id="Как-устроен-контекст"><a href="#Как-устроен-контекст" class="headerlink" title="Как устроен контекст?"></a>Как устроен контекст?</h2><p>Контекст в Go устроен как древовидная структура, где каждый контекст может иметь одного родителя и множество дочерних элементов. Когда создается новый контекст с помощью функций WithCancel, WithDeadline, WithTimeout или WithValue, он наследует все свойства своего родительского контекста.</p><p>Внутри, контекст представляет собой интерфейс с несколькими методами:</p><ul><li><code>Deadline() (deadline time.Time, ok bool)</code>: Возвращает время, когда работа должна быть завершена. Второе возвращаемое значение ok показывает, был ли установлен крайний срок.</li><li><code>Done() &lt;-chan struct&#123;&#125;</code>: Возвращает канал, который будет закрыт, когда работа должна быть отменена. Если канал закрыт, то Err() вернет не nil.</li><li><code>Err()</code> error: Возвращает ошибку, которая описывает причину завершения контекста. Это может быть context.Canceled или context.DeadlineExceeded.</li><li><code>Value(key interface&#123;&#125;) interface&#123;&#125;</code>: Возвращает значение, связанное с ключом. Если ключа нет, возвращается nil.</li></ul><p>Когда контекст отменяется, все его дочерние контексты также отменяются. Это позволяет управлять группами горутин, которые выполняют связанные задачи. Если одна задача отменяется, все связанные задачи также отменяются</p><h2 id="Как-работает-WithCancel"><a href="#Как-работает-WithCancel" class="headerlink" title="Как работает WithCancel?"></a>Как работает WithCancel?</h2><p>Функция <code>WithCancel</code> из пакета <code>context</code> в Go создает новый контекст из существующего (родительского) контекста, который может быть отменен. Эта функция возвращает новый контекст и функцию <code>cancel</code>, которую можно вызвать, чтобы отменить контекст.</p><p>Вот как это работает:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(parentCtx)</span><br></pre></td></tr></table></figure><p>Здесь <code>ctx</code> - это новый контекст, который наследует все свойства от <code>parentCtx</code>, и <code>cancel</code> - это функция, которую можно вызвать, чтобы отменить <code>ctx</code> и все контексты, производные от <code>ctx</code>.</p><p>Когда функция <code>cancel</code> вызывается, канал <code>Done</code> контекста <code>ctx</code> закрывается. Все горутины, которые слушают канал <code>Done</code>, могут проверить его закрытие, чтобы узнать, был ли контекст отменен.</p><p>Важно всегда вызывать <code>cancel</code> в defer (или когда контекст больше не нужен), чтобы освободить ресурсы, связанные с контекстом. Если <code>cancel</code> не вызывается, то может произойти утечка ресурсов.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> cancel() <span class="comment">// Make sure to cancel when done with context</span></span><br></pre></td></tr></table></figure><h2 id="Перекидывали-логгер-в-контексте"><a href="#Перекидывали-логгер-в-контексте" class="headerlink" title="Перекидывали логгер в контексте?"></a>Перекидывали логгер в контексте?</h2><p>Передача логгера через контекст - это тема, которая вызывает много дискуссий в сообществе Go. Вот некоторые аргументы “за” и “против”:</p><p><strong>За:</strong></p><ol><li><p><strong>Простота</strong>: Передача логгера через контекст может упростить API, так как вам не нужно передавать логгер в каждую функцию.</p></li><li><p><strong>Передача метаданных</strong>: Если вы используете структурированное логирование, вы можете добавить метаданные (например, ID запроса) в логгер, который затем передается через контекст. Это позволяет автоматически включать эти метаданные во все сообщения лога.</p></li></ol><p><strong>Против:</strong></p><ol><li><p><strong>Неявность</strong>: Передача логгера через контекст делает его неявным. Это может затруднить понимание того, откуда идут сообщения лога.</p></li><li><p><strong>Неправильное использование контекста</strong>: Документация Go говорит, что контекст должен использоваться для передачи данных, которые должны быть доступны в течение жизненного цикла запроса, а не для передачи опциональных параметров функции. Некоторые люди считают, что передача логгера через контекст - это злоупотребление контекстом.</p></li><li><p><strong>Проблемы с производительностью</strong>: Создание нового контекста для каждого запроса с логгером может привести к увеличению накладных расходов и использованию памяти.</p></li></ol><p>В конечном итоге, решение о том, передавать ли логгер через контекст, зависит от конкретных требований вашего приложения и вашего стиля программирования.</p><p><img src="/images/golang_context.jpg" alt="Вот вам и context"></p>]]></content>
    
    
    <summary type="html">Вопросы по контексту</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Контекст" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82/"/>
    
    <category term="Контекст" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Путь от кооператива до вытеснения</title>
    <link href="https://goxpert.ru/2024/06/01/concurrency/stw/"/>
    <id>https://goxpert.ru/2024/06/01/concurrency/stw/</id>
    <published>2024-06-01T07:18:00.000Z</published>
    <updated>2024-06-03T11:05:45.760Z</updated>
    
    <content type="html"><![CDATA[<p>Для начала “терминология”:</p><p>Stop The World (STW) — это пауза в выполнении программы в Golang, необходимая для корректной работы сборщика мусора.</p><p>STW может негативно влиять на производительность приложений. Для уменьшения его влияния в языке используется алгоритм трёхцветной маркировки, который окрашивает объекты в чёрный, серый или белый цвет в стадии разметки.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SA:</span><br><span class="line">Добрый день, Дмитрий</span><br><span class="line">все еще интереснее</span><br><span class="line">до версии 1.14 у Го была чисто кооперативная многозадачность</span><br><span class="line">а с версии 1.14 она стала гибридная: кооперативная с элементом вытесняющей</span><br><span class="line"></span><br><span class="line">Dmitry Sigaev:</span><br><span class="line">Ясно, спасибо</span><br><span class="line"></span><br><span class="line">SA:</span><br><span class="line">и тут интересно соотношение кооперативности и вытестнения.</span><br><span class="line">В каких условиях начинает проявляться вытесняющий механизм, сколько он стоит, и насколько хорошо распределяет процессор между горутинами</span><br><span class="line">и особенно интересное: в каких условиях вытестняющий механизм НЕ применяется</span><br><span class="line"></span><br><span class="line">Dmitry Sigaev:</span><br><span class="line">Хорошо, разберусь и расскажу</span><br></pre></td></tr></table></figure><p>Что нужно изучить<br><a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md">Proposal: Non-cooperative goroutine preemption(Некооперативное вытеснение для goroutine)</a></p><ul><li>Статья обсуждает проблемы с небезопасными точками в Go и предлагает альтернативы для их решения.</li><li>Небезопасные точки могут вызывать проблемы с выживаемостью, перемещением стека и сложными альтернативами.</li><li>Предлагается отказаться от небезопасных точек и повторить попытку позже, когда программа будет готова.</li><li>Обсуждаются общие последствия использования сигналов для вытеснения запущенной программы.</li><li>Предлагаются альтернативы для сигнализируемого вытеснения, включая нацеливание на определенные потоки и возобновление выполнения.</li><li>Обсуждаются проблемы, связанные с одноступенчатыми переходами и переписыванием кода для перехода в безопасную точку.</li><li>Предлагаются альтернативные подходы, такие как использование аппаратной одноступенчатой поддержки и переписывание следующей инструкции по прыжку в безопасную точку.</li></ul><p><a href="https://github.com/golang/go/issues/36365">Устранение недостатков асинхронного вытеснения</a></p><p>В Go 1.14 введено асинхронное вытеснение, чтобы можно было вытеснять узкие циклы (# 10958). Однако все еще есть несколько незаконченных концов, которые нужно связать. Это общая ошибка для отслеживания оставшейся работы:</p><p><img src="/images/async_pre.png" alt="Устранение недостатков асинхронного вытеснения"></p><p><a href="https://github.com/golang/go/issues/31222">Длительные паузы STW (завершение этапа “подметания” sweep) при выделении массивного блока long pauses STW (sweep termination) on massive block allocation</a></p><hr><h1 id="Аннотация-Abstract"><a href="#Аннотация-Abstract" class="headerlink" title="Аннотация (Abstract)"></a>Аннотация (Abstract)</h1><p>В настоящее время Go использует вставленные компилятором точки вытеснения сотрудничества в прологах функций. В большинстве случаев этого достаточно, чтобы позволить разработчикам Go игнорировать preemption и сосредоточиться на написании четкого параллельного кода, но у него есть острые углы, которые, как мы видели, снова и снова ухудшают опыт разработчиков. Когда что-то идет не так, все идет совершенно неправильно, что приводит к загадочным проблемам с задержкой в системе, а иногда и к полному зависанию. И поскольку это проблема языковой реализации, которая существует вне языковой семантики Go, эти сбои неожиданны и их очень трудно отладить.</p><p>@dr2chase приложил значительные усилия для создания прототипов точек вытеснения кооперативов в циклах, что является одним из способов решения этой проблемы. Однако даже сложные подходы к этому приводили к неприемлемым замедлениям в узких циклах (где замедления, как правило, наименее приемлемы).</p><p>Я предлагаю, чтобы реализация Go переключилась на вытеснение без сотрудничества, что позволило бы вытеснять программы практически в любой момент без необходимости явных проверок вытеснения. Такой подход решит проблему отложенного вытеснения и сделает это с нулевыми затратами времени выполнения.</p><p>Некооперативное упреждение - это общая концепция с целым классом методов реализации. В этом документе описывается и мотивируется переход на некооперативное преимущественное использование и обсуждаются общие проблемы любого некооперативного подхода к преимущественному использованию в Go. Конкретные подходы к реализации подробно описаны во вложенных предложениях, связанных с этим документом.</p><h1 id="Справочная-информация-Background"><a href="#Справочная-информация-Background" class="headerlink" title="Справочная информация (Background)"></a>Справочная информация (Background)</h1><p>До Go 1.10 включительно Go использовала совместное вытеснение с безопасными точками только при вызовах функций (и даже тогда, если функция маленькая или встроена). Это означает, что Go может переключаться между программами, выполняющимися одновременно, только в определенных точках. Основное преимущество этого заключается в том, что компилятор может гарантировать полезные инварианты в этих безопасных точках. В частности, компилятор гарантирует, что все локальные корни сборки мусора известны во всех безопасных точках, что критически важно для точной сборки мусора. Он также может гарантировать, что никакие регистры не будут активированы в безопасных точках, что означает, что среда выполнения Go может переключать подпрограммы без необходимости сохранять и восстанавливать большой набор регистров.</p><p>Однако это может привести к нечастым безопасным точкам, что приводит ко многим проблемам:</p><ol><li><p>Наиболее распространенным в производственном коде является то, что это может задерживать операции STW, такие как запуск и завершение цикла GC. Это увеличивает задержку STW и при большом количестве ядер может существенно повлиять на пропускную способность (если, например, большинство потоков остановлено, пока среда выполнения ожидает отставшего в течение длительного времени). (#17831, #19241)</p></li><li><p>Это может задержать планирование, не позволяя конкурирующим программам выполняться своевременно.</p></li><li><p>Это может задержать сканирование стека, которое потребляет центральный процессор, пока среда выполнения ожидает точки вытеснения, и в конечном итоге может задержать завершение GC, что приводит к эффективному STW, когда в системе заканчивается куча и никакие программы не могут ее выделить.</p></li><li><p>В действительно экстремальных случаях это может привести к остановке программы, например, когда подпрограмма, работающая на атомной нагрузке, истощает подпрограмму, ответственную за настройку этой атомной нагрузки. Это часто указывает на плохой или глючный код, но, тем не менее, удивительно и явно отняло у разработчика много времени на отладку. (#543, #12553, #13546, #14561, #15442, #17174, #20793, #21053)</p></li></ol><p>Эти проблемы снижают производительность разработчиков и эффективность производства и знакомят пользователей Go с деталями реализации, о которых им не следует беспокоиться.</p><h1 id="Преимущественное-использование-кооперативного-цикла-Cooperative-loop-preemption"><a href="#Преимущественное-использование-кооперативного-цикла-Cooperative-loop-preemption" class="headerlink" title="Преимущественное использование кооперативного цикла (Cooperative loop preemption)"></a>Преимущественное использование кооперативного цикла (Cooperative loop preemption)</h1><p>@dr2chase приложил значительные усилия, пытаясь решить эти проблемы с помощью кооперативного вытеснения цикла (# 10958). Это стандартный подход для сред выполнения, использующих совместное вытеснение, при котором компилятор вставляет проверки вытеснения и безопасные точки на задних ребрах графа потока. Это значительно улучшает качество вытеснения, поскольку код почти никогда не выполняется без поддержки в течение какого-либо нетривиального периода времени.</p><p>Наш самый последний подход к вытеснению циклов, который мы называем вытеснение на основе сбоев, добавляет единую инструкцию, без ветвей и давления регистра на циклы на платформах x86 и UNIX (CL 43050). Несмотря на это, геометрическое замедление по большому набору тестов составляет 7,8%, с несколькими значительно худшими выбросами. Даже по сравнению с Go 1.9, где замедление составляет всего 1% благодаря другим улучшениям, в большинстве тестов наблюдается некоторое замедление, и все еще наблюдаются значительные отклонения.</p><p>Вытеснение на основе ошибок также имеет несколько недостатков реализации. Оно не может быть нацелено на определенные потоки или подпрограммы, поэтому плохо подходит для сканирования стека, неровных барьеров или вытеснения обычного планировщика. Это также “залипание” в том смысле, что мы не можем возобновить какие-либо циклы, пока не возобновим все циклы, поэтому безопасная точка не может просто возобновиться, если это происходит в небезопасном состоянии (например, когда удерживаются блокировки во время выполнения). Требуется больше инструкций (и больше накладных расходов) на платформах, отличных от x86 и UNIX. Наконец, это мешает работе отладчиков, которые предполагают, что плохие ссылки на память являются веской причиной для остановки программы. Неясно, может ли оно вообще работать во многих отладчиках OS X из-за ошибки ядра.</p><h1 id="Некооперативное-вытеснение-Non-cooperative-preemption"><a href="#Некооперативное-вытеснение-Non-cooperative-preemption" class="headerlink" title="Некооперативное вытеснение (Non-cooperative preemption)"></a>Некооперативное вытеснение (Non-cooperative preemption)</h1><p>Некооперативное вытеснение переключается между контекстами параллельного выполнения без явных проверок вытеснения или помощи со стороны этих контекстов. Это используется всеми современными настольными и серверными операционными системами для переключения между потоками. Без этого одно приложение с плохим поведением может заклинить всю систему, подобно тому, как одна программа с плохим поведением в настоящее время может заклинить приложение Go. Это также удобная абстракция: она позволяет нам программировать так, как будто доступно бесконечное количество процессоров, скрывая тот факт, что ОС выполняет временное мультиплексирование конечного числа процессоров.</p><p>Планировщики операционной системы используют поддержку аппаратных прерываний для переключения запущенного потока в планировщик ОС, который может сохранять состояние этого потока, например, его регистры процессора, чтобы его можно было возобновить позже. В Go мы бы использовали поддержку операционной системы, чтобы сделать то же самое. В UNIX-подобных операционных системах это можно сделать с помощью сигналов.</p><p>Однако из-за сборщика мусора у Go есть требования, которых нет у операционной системы: Go должен иметь возможность находить текущие указатели в стеке goroutine, где бы он ее ни останавливал. Большая часть сложности отказа от сотрудничества в Go проистекает из этого требования.</p><h2 id="Предложение"><a href="#Предложение" class="headerlink" title="Предложение"></a>Предложение</h2><p><a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md">В статье предлагается</a> в Go реализовать вытеснение некооперативной подпрограммы, отправив сигнал POSIX (или используя эквивалентный механизм операционной системы), чтобы остановить запущенную программу goroutine и зафиксировать состояние ее процессора. Если подпрограмма прерывается в точке, которая должна быть GC atomic, как подробно описано в <a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md#handling-unsafe-points">разделе “Обработка небезопасных точек”</a>, среда выполнения может просто возобновить работу подпрограммы и повторить попытку позже.</p><p>Основная сложность реализации вытеснения без сотрудничества для Go заключается в поиске активных указателей в стеке вытесняемой подпрограммы. Существует множество возможных способов сделать это, которые подробно описаны в этих подпредложениях:</p><p>В <a href="https://github.com/golang/proposal/blob/master/design/24543/safe-points-everywhere.md">предложении с безопасными точками везде</a> описывается реализация, в которой компилятор записывает карты стека и регистра практически для каждой инструкции. Это позволяет среде выполнения останавливать goroutine в любом месте и находить ее корни GC.</p><p>В <a href="https://github.com/golang/proposal/blob/master/design/24543/conservative-inner-frame.md">предложении по консервативному сканированию внутреннего фрейма</a> описывается реализация, которая использует консервативные методы GC для поиска указателей в самом внутреннем фрейме стека вытесняемой подпрограммы goroutine. Это можно сделать без каких-либо дополнительных метаданных безопасной точки.</p><h2 id="Обработка-небезопасных-точек-Handling-unsafe-points"><a href="#Обработка-небезопасных-точек-Handling-unsafe-points" class="headerlink" title="Обработка небезопасных точек (Handling unsafe-points)"></a>Обработка небезопасных точек (Handling unsafe-points)</h2><p>Любой некооперативный подход вытеснения в Go должен иметь дело с кодовыми последовательностями, которые должны быть атомарными по отношению к сборщику мусора. Мы называем их “небезопасными точками”, в отличие от безопасных точек GC. Несколько известных ситуаций:</p><ol><li><p>Выражения, включающие unsafe.Pointer, могут временно представлять единственный указатель на объект как uintptr. Следовательно, не должно быть безопасных точек, пока a uintptr производный от an unsafe.Pointer активен. Аналогично, мы должны распознавать преобразования reflect.Value.Pointer, reflect.Value.UnsafeAddr и reflect.Value.InterfaceData как unsafe.Pointerвuintptr. В качестве альтернативы, если компилятор может надежно обнаружить такие uintptrы, он может пометить их как указатели, но есть опасность, что промежуточное значение может не представлять допустимое значение указателя.</p></li><li><p>В барьере записи(write barrier) не должно быть безопасной точки между проверкой с включенным барьером записи и прямой записью. Например, предположим, что goroutine записывает указатель на B в объект A. Если проверка произойдет, то GC запустится и просканирует A, затем goroutine запишет B в A и удалит все ссылки на B из своего стека, сборщик мусора может не отметить B.</p></li><li><p>Есть места, где компилятор генерирует временные указатели, которые могут находиться за пределами конца выделения, например, в циклах диапазона над фрагментами и массивами. Этих действий следует либо избегать, либо запретить использование безопасных точек, пока они действуют.</p></li></ol><p>Во всех этих случаях уже должно быть исключено существенное изменение порядка, чтобы избежать разделения по вызову. Внутренне это достигается с помощью псевдозначения “mem”, которое должно последовательно передаваться через все значения SSA, которые манипулируют памятью. Mem также передается через значения, которые нельзя изменять, даже если они не затрагивают память. Например, преобразование между unsafe.Pointer и uintptr выполняется с помощью специальной операции “Преобразовать”, которая использует mem исключительно для ограничения изменения порядка.</p><p>Существует несколько возможных решений этой проблемы, некоторые из которых можно комбинировать:</p><ol><li><p>Мы могли бы отметить базовые блоки, которые не должны содержать точек вытеснения. Для unsafe.Pointer преобразований мы бы отказались от базового блока, содержащего преобразование. Для кода, соответствующего unsafe.Pointer правилам, этого должно быть достаточно, но это может привести к поломке кода, который является некорректным, но, как оказалось, работает сегодня способами, которые очень трудно отлаживать. Для барьеров записи этого также достаточно. Для циклов это слишком широко и потребует разделения некоторых базовых блоков.</p></li><li><p>Для unsafe.Pointer преобразований мы могли бы просто отказаться от целых функций, которые преобразуют из unsafe.Pointer в uintptr. Это было бы легко реализовать, и даже неисправный небезопасный код продолжал бы работать так же хорошо, как сегодня, но может иметь широкое влияние, особенно при наличии встраивания.</p></li><li><p>Простой комбинацией 1 и 2 было бы отказаться от любого базового блока, который достижим от преобразования unsafe.Pointer в uintptr, вплоть до вызова функции (что сегодня является безопасной точкой).</p></li><li><p>Для циклов диапазона компилятор мог бы скомпилировать их по-другому, чтобы он никогда не создавал указатель, выходящий за пределы (см. Ниже).</p></li><li><p>Гораздо более точным и общим подходом (благодаря @cherrymui) было бы создание новых операций SSA, которые “загрязняют” и “не загрязняют” память. Операция заражения возьмет mem и вернет новый поврежденный mem. Это заражение будет распространяться на любые значения, которые сами принимают поврежденное значение. Незапятнанная операция примет значение и mem и вернет незапятнанное значение и незапятнанный mem. Во время анализа жизнеспособности безопасные точки будут запрещены везде, где действовало испорченное значение. Это, вероятно, наиболее точное решение, которое, вероятно, сохранит даже неправильное использование unsafe working, но требует сложной реализации.</p></li></ol><p>В более широком смысле, стоит подумать о том, чтобы заставить компилятор проверять код, использующий unsafe.Pointer, и активно отклонять код, который не соответствует разрешенным шаблонам. Это можно было бы реализовать как простую систему типов, которая отличает указатель uintptr от числового uintptr. Но это выходит за рамки данного предложения.</p><h2 id="Циклы-диапазона-Range-loops"><a href="#Циклы-диапазона-Range-loops" class="headerlink" title="Циклы диапазона (Range loops)"></a>Циклы диапазона (Range loops)</h2><p>Начиная с версии 1.10, циклы диапазона составляются примерно так:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> s &#123; b &#125;</span><br><span class="line">  ⇓</span><br><span class="line"><span class="keyword">for</span> i, _n, _p := <span class="number">0</span>, <span class="built_in">len</span>(s), &amp;s[<span class="number">0</span>]; i &lt; _n; i, _p = i+<span class="number">1</span>, _p + unsafe.Sizeof(s[<span class="number">0</span>]) &#123; b &#125;</span><br><span class="line">  ⇓</span><br><span class="line">i, _n, _p := <span class="number">0</span>, <span class="built_in">len</span>(s), &amp;s[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">goto</span> cond</span><br><span class="line">body:</span><br><span class="line">&#123; b &#125;</span><br><span class="line">i, _p = i+<span class="number">1</span>, _p + unsafe.Sizeof(s[<span class="number">0</span>])</span><br><span class="line">cond:</span><br><span class="line"><span class="keyword">if</span> i &lt; _n &#123; <span class="keyword">goto</span> body &#125; <span class="keyword">else</span> &#123; <span class="keyword">goto</span> end &#125;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>Проблема с этим понижением заключается в том, что _p может временно превышать конец распределения за момент до завершения цикла. В настоящее время это безопасно, потому что никогда не существует безопасной точки, пока это значение _p действует.</p><p>Это уменьшение требует, чтобы компилятор пометил блоки increment и condition как небезопасные точки. Однако, если тело короткое, это может привести к нечастым безопасным точкам. Это также требует создания отдельного блока для приращения, который в настоящее время обычно добавляется в конец основного текста. Разделение этих блоков ограничило бы возможности изменения порядка.</p><p>При подготовке к вытеснению без сотрудничества в Go 1.11 была начата компиляция циклов диапазона следующим образом, чтобы избежать создания указателя, переходящего в конец:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i, _n, _p := <span class="number">0</span>, <span class="built_in">len</span>(s), &amp;s[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> i &gt;= _n &#123; <span class="keyword">goto</span> end &#125; <span class="keyword">else</span> &#123; <span class="keyword">goto</span> body &#125;</span><br><span class="line">top:</span><br><span class="line">_p += unsafe.Sizeof(s[<span class="number">0</span>])</span><br><span class="line">body:</span><br><span class="line">&#123; b &#125;</span><br><span class="line">i++</span><br><span class="line"><span class="keyword">if</span> i &gt;= _n &#123; <span class="keyword">goto</span> end &#125; <span class="keyword">else</span> &#123; <span class="keyword">goto</span> top &#125;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>Это позволяет использовать безопасные точки повсюду в цикле. По сравнению с исходной компиляцией цикла, он генерирует немного больше кода, но выполняет то же количество инструкций условного перехода (n + 1) и приводит к тому же количеству базовых блоков SSA (3).</p><p>Это снижение усложняет устранение проверки границ. В Go 1.10 устранение проверки границ знало об этом i &lt; _n в теле, потому что в блоке body доминирует блок cond. Однако в новом понижении для получения этого факта потребовалось определить, что i &lt; _n на обоих путях в тело и, следовательно, верно в теле.</p><h2 id="Безопасные-точки-выполнения-Runtime-safe-points"><a href="#Безопасные-точки-выполнения-Runtime-safe-points" class="headerlink" title="Безопасные точки выполнения (Runtime safe-points)"></a>Безопасные точки выполнения (Runtime safe-points)</h2><p>Помимо сгенерированного кода, среда выполнения в целом не предназначена для произвольного вытеснения, и есть много мест, которые не должны вытесняться. Следовательно, мы, вероятно, отключили бы безопасные точки по умолчанию во время выполнения, за исключением вызовов (где они происходят сейчас).</p><p>Хотя это имело бы небольшие недостатки для большей части среды выполнения, есть некоторые части среды выполнения, которые могли бы существенно выиграть от вытеснения без сотрудничества, например, функции памяти, такие как memmove. Вытеснение без сотрудничества - отличный способ сделать их вытесняемыми без замедления общего случая, поскольку нам нужно было бы только пометить их карты регистров (которые часто были бы пустыми для функций типа memmove, поскольку все указатели уже были бы защищены аргументами).</p><p>Со временем мы можем использовать больше времени выполнения.</p><h2 id="Небезопасный-код-стандартной-библиотеки-Unsafe-standard-library-code"><a href="#Небезопасный-код-стандартной-библиотеки-Unsafe-standard-library-code" class="headerlink" title="Небезопасный код стандартной библиотеки (Unsafe standard library code)"></a>Небезопасный код стандартной библиотеки (Unsafe standard library code)</h2><p>Пакет системного вызова Windows содержит множество unsafe.Pointer преобразований, которые не соответствуют unsafe.Pointer правилам. В целом он делает шаткие предположения о поведении безопасной точки, жизнеспособности и о том, когда может произойти перемещение стека. Вероятно, потребуется тщательный аудит или от него придется отказаться, как от среды выполнения.</p><p>Возможно, более тревожным является то, что некоторые типы пакетов системного вызова Windows имеют поля uintptr, которые на самом деле являются указателями, следовательно, вынуждая вызывающих выполнять небезопасные преобразования указателей. Например, смотрите Выпуск <a href="https://golang.org/issue/21376"> #21376 </a>.</p><h2 id="Обеспечение-прогресса-с-небезопасными-точками-Ensuring-progress-with-unsafe-points"><a href="#Обеспечение-прогресса-с-небезопасными-точками-Ensuring-progress-with-unsafe-points" class="headerlink" title="Обеспечение прогресса с небезопасными точками (Ensuring progress with unsafe-points)"></a>Обеспечение прогресса с небезопасными точками (Ensuring progress with unsafe-points)</h2><p>Мы предлагаем просто сдаться и повторить попытку позже, когда подпрограмма прерывается в небезопасной точке. Одна из опасностей этого заключается в том, что безопасные точки могут быть редкими в узких циклах. Однако во многих случаях существуют более сложные альтернативы этому подходу.</p><p>При прерываниях во время выполнения или в функциях без каких-либо безопасных точек (таких как сборка) обработчик сигналов может размотать стек и вставить возвратный трамплин при следующем возврате к функции с метаданными безопасных точек. В этом случае среда выполнения могла бы позволить goroutine продолжить работу, и trampoline приостановил бы ее как можно скорее.</p><p>Для барьеров записи и unsafe.Pointer последовательностей компилятор мог бы вставить дешевую, явную проверку вытеснения в конце последовательности. Например, среда выполнения может изменить некоторый регистр, который будет проверяться в конце последовательности, и позволить потоку продолжить выполнение. В последовательности с барьером записи это может быть даже регистр, в который был загружен флаг с барьером записи, и компилятор может вставить простой тестовый регистр и условную ветвь в конце последовательности. Чтобы еще больше сократить последовательность, среда выполнения могла бы поместить адрес функции stop в этот регистр, чтобы последовательность stop была просто вызовом регистра и переходом.</p><p>Альтернативы этой проверке включают прямое и обратное моделирование. Прямое моделирование сложно, потому что компилятор должен быть осторожен, чтобы генерировать только операции, которые среда выполнения знает, как имитировать. Обратное моделирование легко, если компилятор всегда может сгенерировать перезапускаемую последовательность (просто верните компьютер к проверке флага ограничения записи), но быстро усложняется, если в последовательности выполняется несколько операций записи или более сложные операции записи, такие как DUFFCOPY.</p><h2 id="Другие-соображения-Other-considerations"><a href="#Другие-соображения-Other-considerations" class="headerlink" title="Другие соображения (Other considerations)"></a>Другие соображения (Other considerations)</h2><p>Все предлагаемые подходы к вытеснению без сотрудничества включают остановку запущенной подпрограммы путем отправки ее потоку сигнала операционной системы. В этом разделе обсуждаются общие последствия этого.</p><p>Поддержка Windows. В отличие от вытеснения цикла на основе сбоя, сигнальное вытеснение довольно легко поддерживать в Windows, потому что оно предоставляет SuspendThread и GetThreadContext, которые упрощают получение набора регистров потока.</p><p>Выбор сигнала. Мы должны выбрать сигнал, который вряд ли будет мешать существующему использованию сигналов или отладчикам. Идеального выбора не существует, но есть некоторые эвристические приемы.</p><ol><li>Это должен быть сигнал, который по умолчанию передается отладчиками. В Linux это SIGALRM, SIGURG, SIGCHLD, SIGIO, SIGVTALRM, SIGPROF и SIGWINCH, плюс некоторые сигналы glibc-internal.</li><li>Он не должен использоваться libc внутри в смешанных двоичных файлах Go / C, потому что libc может предположить, что это единственное, что может обрабатывать эти сигналы. Например, SIGCANCEL или SIGSETXID .</li><li>Это должен быть сигнал, который может произойти непреднамеренно без последствий. Например, SIGALRM - плохой выбор, потому что обработчик сигнала не может определить, было ли это вызвано реальным сигналом тревоги процесса или нет (возможно, это означает, что сигнал нарушен, но я отвлекся). SIGUSR1 и SIGUSR2 также плохи, потому что они часто используются приложениями значимыми способами.</li><li>Нам нужно иметь дело с платформами без сигналов реального времени (например, macOS), поэтому они исключены.<br>Мы используем SIGURG, потому что он соответствует всем этим критериям, крайне маловероятно, что он будет использоваться приложением в его “реальном” значении (как потому, что внеполосные данные в основном не используются, так и потому, что SIGURG не сообщает, у какого сокета есть условие, что делает его довольно бесполезным), и даже если это так, приложение должно быть готово к ложному SIGURG. SIGIO тоже был бы неплохим выбором, но, скорее всего, его будут использовать по-настоящему.</li></ol><p>Преимущественное использование планировщика. Этот механизм хорошо подходит для временных вытеснений, когда одна и та же подпрограмма возобновляется после вытеснения, потому что нам не нужно сохранять полное состояние регистра и мы можем полагаться на существующий путь возврата сигнала для восстановления полного состояния регистра. Это применимо ко всем вытеснениям, связанным с GC, но не так хорошо подходит для постоянного вытеснения, выполняемого планировщиком. Тем не менее, мы все равно могли бы использовать этот механизм. Например, поскольку большую часть времени goroutines самостоятельно вытесняют сигнал, нам нужно сохранить полное состояние сигнала только в необычном случае, поэтому g может содержать указатель на его полное сохраненное состояние, которое используется только после принудительного вытеснения. Восстановление полного состояния сигнала может быть выполнено либо путем написания зависящего от архитектуры кода для восстановления полного набора регистров (усиленного runtime.gogo), либо путем самосигнализации, замены в желаемом контексте и предоставления ОС возможности восстановить полный набор регистров.</p><p>Нацеливание и возобновление. В отличие от прерывания цикла на основе сбоя, сигнальное прерывание может быть нацелено на определенный поток и может немедленно возобновиться. Нацеливание на потоки немного отличается от совместного вытеснения, которое ориентировано на горутины. Однако во многих случаях это на самом деле лучше, поскольку нацеливание программ на вытеснение является пикантным и, следовательно, требует циклов повторных попыток, которые могут значительно увеличить время STW. Использование этого для сканирования стека потребует некоторой реструктуризации того, как мы отслеживаем корни GC, но результат должен устранить блокирующий цикл повторных попыток, который мы используем в настоящее время.</p><p>Указатели без указателей. Это может привести к некорректному использованию unsafe.Pointer для временного хранения указателей без указателей. Такое использование является явным нарушением unsafe.Pointer правил, но оно может иметь место (особенно, например, в коде, использующем cgo).</p><h1 id="Альтернативы-Alternatives"><a href="#Альтернативы-Alternatives" class="headerlink" title="Альтернативы (Alternatives)"></a>Альтернативы (Alternatives)</h1><h2 id="Одноступенчатый-Single-stepping"><a href="#Одноступенчатый-Single-stepping" class="headerlink" title="Одноступенчатый (Single-stepping)"></a>Одноступенчатый (Single-stepping)</h2><p>Вместо того, чтобы прилагать усилия для остановки на любой инструкции, компилятор мог бы выдавать метаданные для безопасных точек только на обратных фронтах, а среда выполнения могла бы использовать аппаратную поддержку одношагового перехода для продвижения потока к безопасной точке (или точке, где компилятор предоставил ответвление для достижения безопасной точки, как в текущем подходе с вытеснением цикла). Это работает (несколько неожиданно), но полностью сбивает с толку отладчики, поскольку и отладчик, и операционная система предполагают, что отладчик владеет single-stepping , а не самим процессом. Это также потребовало бы от компилятора предоставления заглушек для очистки регистров для этих безопасных точек, что увеличивает размер кода (и, следовательно, объем кэша инструкций), а также размер стека, во многом подобно вытеснению кооперативного цикла. Однако, в отличие от вытеснения кооперативного цикла, этот подход никак не повлияет на размер или производительность основного кода.</p><h2 id="Быстрое-переписывание-Jump-rewriting"><a href="#Быстрое-переписывание-Jump-rewriting" class="headerlink" title="Быстрое переписывание (Jump rewriting)"></a>Быстрое переписывание (Jump rewriting)</h2><p>Мы можем решить проблемы одношагового выполнения, вместо этого переписав следующую инструкцию перехода к безопасной точке после точки прерывания, чтобы перейти к пути упреждающего выполнения и возобновить выполнение как обычно. Чтобы упростить это, компилятор мог бы оставить достаточно места (с помощью NOPS заполнения), поэтому необходимо изменить только цель перехода.</p><p>Этот подход имеет обычные недостатки изменяемого кода. Это угроза безопасности, он нарушает совместное использование текстовых страниц и просто не разрешен в iOS. Он также не может быть нацелен на отдельную подпрограмму (поскольку другая подпрограмма может выполнять тот же код) и может иметь странные взаимодействия с параллельным выполнением на других ядрах.</p><h2 id="Нестандартное-исполнение-Out-of-line-execution"><a href="#Нестандартное-исполнение-Out-of-line-execution" class="headerlink" title="Нестандартное исполнение (Out-of-line execution)"></a>Нестандартное исполнение (Out-of-line execution)</h2><p>Еще одна альтернатива в том же духе, но не требующая изменения существующего текста, - это выполнение вне строки. При таком подходе обработчик сигналов перемещает поток команд из точки прерывания в следующую безопасную точку перехода во временный буфер, исправляет его для перехода во время выполнения в конце и возобновляет выполнение в этой перемещенной последовательности.</p><p>Это решает большинство проблем с одношаговым и скачкообразным перезаписыванием, но довольно сложно реализовать и требует значительных усилий по внедрению для каждой платформы. Это также запрещено в iOS.</p><p>Прецедент такого подхода уже есть. Например, когда Linux uprobes вводит INT3, он перемещает перезаписанные инструкции в область “выполнить вне очереди”, чтобы избежать обычных проблем с возобновлением работы с инструкцией INT3. <a href="https://github.com/torvalds/linux/blob/v4.18/arch/x86/kernel/uprobes.c">Реализация</a> на удивление проста, учитывая сложность кодирования инструкций x86, но все еще довольно сложна.</p><p><img src="/images/golang_scheduler.jpg" alt="Вот вам и scheduler"></p>]]></content>
    
    
    <summary type="html">Вопросы по планировщику Golang и OS</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Планировщик" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"/>
    
    <category term="Планировщик" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Горутины</title>
    <link href="https://goxpert.ru/2024/06/01/concurrency/goroutines/"/>
    <id>https://goxpert.ru/2024/06/01/concurrency/goroutines/</id>
    <published>2024-06-01T07:17:00.000Z</published>
    <updated>2024-06-02T18:00:11.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-горутина"><a href="#Что-такое-горутина" class="headerlink" title="Что такое горутина?"></a>Что такое горутина?</h2><p>Горутина - это функция, которая может выполняться параллельно с другими функциями в одном адресном пространстве. Горутины - это особенность языка программирования Go, который позволяет создавать легковесные потоки исполнения. Горутины могут обмениваться данными с помощью каналов, которые являются потокобезопасными структурами данных.</p><p>Источники:</p><ul><li><a href="https://habr.com/ru/companies/otus/articles/527748/">Habr</a></li><li><a href="https://habr.com/ru/articles/141853/">Habr</a></li><li><a href="https://metanit.com/go/tutorial/7.1.php">Metanit</a></li></ul><h2 id="Чем-горутина-отличается-от-треда"><a href="#Чем-горутина-отличается-от-треда" class="headerlink" title="Чем горутина отличается от треда?"></a>Чем горутина отличается от треда?</h2><p>Горутина отличается от треда несколькими способами:</p><ul><li>Горутина имеет меньший размер стека, чем тред, и может динамически его расширять при необходимости.</li><li>Горутина не связана с конкретным системным потоком, а управляется планировщиком Go, который может переключать горутины между разными потоками.</li><li>Горутина может быть запущена с помощью ключевого слова go, в то время как тред требует вызова специальной функции или библиотеки.</li><li>Горутина может общаться с другими горутинами через каналы, которые обеспечивают синхронизацию и безопасность данных. Треды же обычно используют разделяемую память и механизмы блокировки.</li></ul><p>Источники: </p><ul><li><a href="https://habr.com/ru/articles/141853/">Habr</a></li><li><a href="https://medium.com/nuances-of-programming/%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%B8-%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D0%B8%D0%B7%D0%BC-%D0%B2-golang-go-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D1%8B-82bae0f92e81">Medium</a></li></ul><h2 id="В-чем-преимущества-горутин-над-тредами"><a href="#В-чем-преимущества-горутин-над-тредами" class="headerlink" title="В чем преимущества горутин над тредами?"></a>В чем преимущества горутин над тредами?</h2><p>Некоторые преимущества горутин над тредами включают:</p><ul><li>Более высокую производительность и меньшее потребление ресурсов, так как горутины занимают меньше памяти и переключаются быстрее.</li><li>Более простую и элегантную модель конкурентности, основанную на каналах, которые избегают проблем с блокировками и гонками данных.</li></ul><h2 id="Что-есть-в-Golang-для-многопоточности"><a href="#Что-есть-в-Golang-для-многопоточности" class="headerlink" title="Что есть в Golang для многопоточности?"></a>Что есть в Golang для многопоточности?</h2><p>В Golang для многопоточности есть горутины и каналы. Горутины - это легковесные потоки, которые можно запускать с помощью ключевого слова go. Каналы - это потокобезопасные структуры данных, которые позволяют обмениваться данными между горутинами. GOMAXPROCS - это параметр, который определяет, сколько ядер ЦП используется для одновременного выполнения горутин.</p><h2 id="Как-можно-остановить-горутину"><a href="#Как-можно-остановить-горутину" class="headerlink" title="Как можно остановить горутину?"></a>Как можно остановить горутину?</h2><p>Остановить горутину можно с помощью контекста, канала или таймаута. Контекст позволяет передавать сигналы о завершении работы между горутинами. Канал позволяет отправлять и получать значения между горутинами, в том числе команды на остановку. Таймаут позволяет ограничить время работы горутины и прервать ее, если она не успела выполниться. </p><p>Вот некоторые примеры использования этих механизмов:</p><p>С помощью контекста:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// создаем контекст с отменой</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">// запускаем горутину с этим контекстом</span></span><br><span class="line"><span class="keyword">go</span> worker(ctx)</span><br><span class="line"><span class="comment">// ждем 3 секунды</span></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// отменяем контекст</span></span><br><span class="line">cancel()</span><br><span class="line"><span class="comment">// ждем еще 2 секунды</span></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">// контекст отменен, выходим из горутины</span></span><br><span class="line">fmt.Println(<span class="string">&quot;worker stopped&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// продолжаем работать</span></span><br><span class="line">fmt.Println(<span class="string">&quot;worker working&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>С помощью канала:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// создаем канал для передачи сигнала остановки</span></span><br><span class="line">stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">// запускаем горутину с этим каналом</span></span><br><span class="line"><span class="keyword">go</span> worker(stop)</span><br><span class="line"><span class="comment">// ждем 3 секунды</span></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// отправляем сигнал остановки в канал</span></span><br><span class="line">stop &lt;- <span class="literal">true</span></span><br><span class="line"><span class="comment">// ждем еще 2 секунды</span></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(stop <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stop:</span><br><span class="line"><span class="comment">// получили сигнал остановки, выходим из горутины</span></span><br><span class="line">fmt.Println(<span class="string">&quot;worker stopped&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// продолжаем работать</span></span><br><span class="line">fmt.Println(<span class="string">&quot;worker working&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>С помощью таймаута:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// создаем канал для получения результата работы</span></span><br><span class="line">result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="comment">// запускаем горутину с этим каналом</span></span><br><span class="line"><span class="keyword">go</span> worker(result)</span><br><span class="line"><span class="comment">// устанавливаем таймаут в 3 секунды</span></span><br><span class="line">timeout := time.After(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> res := &lt;-result:</span><br><span class="line"><span class="comment">// получили результат работы до таймаута</span></span><br><span class="line">fmt.Println(<span class="string">&quot;worker finished:&quot;</span>, res)</span><br><span class="line"><span class="keyword">case</span> &lt;-timeout:</span><br><span class="line"><span class="comment">// время вышло, прерываем горутину</span></span><br><span class="line">fmt.Println(<span class="string">&quot;worker timeout&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(result <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// имитируем долгую работу</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="comment">// отправляем результат в канал</span></span><br><span class="line">result &lt;- <span class="string">&quot;success&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Когда-возникает-утечка-горутины"><a href="#Когда-возникает-утечка-горутины" class="headerlink" title="Когда возникает утечка горутины?"></a>Когда возникает утечка горутины?</h2><p>Утечка горутины возникает, когда горутина продолжает существовать и занимать ресурсы, хотя ее работа уже завершена или не требуется. Это может привести к замедлению работы системы или даже сбою. </p><p>Некоторые причины утечки горутин могут быть:</p><ul><li>Неправильное использование каналов, например, отправка или получение из закрытого или неполного канала, или блокировка канала без возможности выхода.</li><li>Неэффективное управление контекстами, например, отсутствие отмены или таймаута для контекстов, передаваемых в горутины.</li><li>Неожиданные ошибки или паники, которые прерывают работу горутины, не освобождая ресурсы.</li><li>Неоптимальный дизайн программы, например, создание избыточного количества горутин или недостаточный контроль над их жизненным циклом.</li></ul><p><img src="/images/golang_goroutine.jpg" alt="Вот вам и goroutine"></p>]]></content>
    
    
    <summary type="html">Вопросы по гонке данных</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Горутины" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/"/>
    
    <category term="Горутины" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Гонка данных</title>
    <link href="https://goxpert.ru/2024/06/01/concurrency/race-condition/"/>
    <id>https://goxpert.ru/2024/06/01/concurrency/race-condition/</id>
    <published>2024-06-01T07:16:00.000Z</published>
    <updated>2024-06-02T18:00:17.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-race-condition"><a href="#Что-такое-race-condition" class="headerlink" title="Что такое race condition?"></a>Что такое race condition?</h2><p>Состояние гонки (англ. race condition), также известное как конкуренция, - это ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.</p><p>Это может произойти, когда две или более операций должны выполняться в последовательности, но из-за неконтролируемых событий они выполняются в непредсказуемом порядке. В результате система или приложение может вести себя непредсказуемо или даже вызывать сбои.</p><p>Состояние гонки - это “плавающая” ошибка (гейзенбаг), проявляющаяся в случайные моменты времени и “пропадающая” при попытке её локализовать. Из-за неконтролируемого доступа к общей памяти состояние гонки может приводить к совершенно различным ошибкам, которые могут проявляться в непредсказуемые моменты времени, а попытка повторения ошибки в целях отладки со схожими условиями работы может оказаться безуспешной.</p><p>Основными последствиями могут быть: утечки памяти, ошибки сегментирования, порча данных, уязвимости, взаимные блокировки, утечки других ресурсов, например файловых дескрипторов.</p><p>Источники:</p><ul><li><a href="https://habr.com/ru/articles/764234/">Habr</a></li></ul><h2 id="Как-обнаружить-race-condition"><a href="#Как-обнаружить-race-condition" class="headerlink" title="Как обнаружить race condition?"></a>Как обнаружить race condition?</h2><p>В Go есть встроенный инструмент для обнаружения состояний гонки, который можно использовать при запуске или сборке вашего приложения. Вы можете использовать флаг <code>-race</code> для обнаружения состояний гонки. Например, если ваш файл называется <code>write.go</code>, команда будет выглядеть так: <code>go run -race write.go</code> или <code>go build -race write.go</code>.</p><p>При запуске этой команды Go выводит на стандартный вывод, который сообщает нам о наличии состояния гонки. Это очень полезный инструмент для обнаружения и исправления состояний гонки в ваших программах на Go.</p><p>Также стоит отметить, что состояния гонки могут быть сложными для обнаружения и воспроизведения, поскольку они могут проявляться только при определенных условиях выполнения и могут не проявляться при повторном запуске того же кода. Поэтому использование инструментов, таких как детектор состояний гонки в Go, может быть очень полезным.</p><h2 id="Какие-есть-способы-устранения-race-condition"><a href="#Какие-есть-способы-устранения-race-condition" class="headerlink" title="Какие есть способы устранения race condition?"></a>Какие есть способы устранения race condition?</h2><ul><li>Использование Mutex: (RW)Mutex предоставляет взаимоисключающую блокировку, которая позволяет только одной горутине в любой момент времени иметь доступ к защищенным данным.</li><li>Использование каналов: Каналы в Go обеспечивают синхронизацию между горутинами и могут быть использованы для предотвращения состояний гонки.</li><li>Использование атомарных операций: Пакет sync/atomic в Go предоставляет функции для атомарных операций, которые могут быть использованы для безопасного доступа к данным из нескольких горутин.</li></ul><h2 id="Есть-глобальный-слайс-и-я-в-разных-горутинах-присваиваю-ему-аппенд-к-нему-же-одного-элемента-Будет-ли-гонка"><a href="#Есть-глобальный-слайс-и-я-в-разных-горутинах-присваиваю-ему-аппенд-к-нему-же-одного-элемента-Будет-ли-гонка" class="headerlink" title="Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?"></a>Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?</h2><p>Да, будет состояние гонки. Функция append не является потокобезопасной, и если вы пытаетесь одновременно добавить элементы в слайс из разных горутин, это может привести к состоянию гонки.</p><p>В Go, когда вы вызываете append, он может изменить размер слайса. Если размер нового слайса больше текущей вместимости, Go создаст новый массив в памяти и скопирует в него все элементы. Если две горутины одновременно пытаются добавить элементы, они могут получить разные копии массива, что приведет к непредсказуемым результатам.</p><p>Чтобы избежать состояния гонки, вы можете использовать мьютекс (sync.Mutex или sync.RWMutex) для синхронизации доступа к слайсу.</p><h2 id="Есть-глобальный-слайс-и-я-в-разных-горутинах-присваиваю-ему-аппенд-к-нему-же-одного-элемента-Будет-ли-гонка-1"><a href="#Есть-глобальный-слайс-и-я-в-разных-горутинах-присваиваю-ему-аппенд-к-нему-же-одного-элемента-Будет-ли-гонка-1" class="headerlink" title="Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?"></a>Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?</h2><p>Да, будет гонка данных. В Go, горутины выполняются параллельно, и если они обе пытаются изменить одну и ту же переменную (в данном случае, глобальный слайс), это может привести к неопределенному поведению. Это известно как гонка данных.</p><p>Чтобы избежать этого, вы можете использовать мьютексы или каналы для синхронизации доступа к общим ресурсам.</p><p><img src="/images/golang_race.jpg" alt="Вот вам и race condition"></p>]]></content>
    
    
    <summary type="html">Вопросы по гонке данных</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Гонка данных" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D0%BD%D0%BA%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/"/>
    
    <category term="Гонка данных" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%93%D0%BE%D0%BD%D0%BA%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Примитивы синхронизации</title>
    <link href="https://goxpert.ru/2024/06/01/concurrency/sync-primitives/"/>
    <id>https://goxpert.ru/2024/06/01/concurrency/sync-primitives/</id>
    <published>2024-06-01T07:15:00.000Z</published>
    <updated>2024-06-02T18:00:31.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Какие-примитивы-синхронизации-есть-в-Golang"><a href="#Какие-примитивы-синхронизации-есть-в-Golang" class="headerlink" title="Какие примитивы синхронизации есть в Golang?"></a>Какие примитивы синхронизации есть в Golang?</h2><p>Примитивы синхронизации - это специальные конструкции, которые позволяют координировать и контролировать доступ к общим ресурсам в многопоточных или конкурентных программах. В Golang есть несколько пакетов, которые предоставляют различные примитивы синхронизации, такие как:</p><p>sync - содержит базовые примитивы, такие как мьютексы (mutexes), блокировки чтения-записи (read-write locks), группы ожидания (wait groups), однократные исполнители (once), условные переменные (condition variables) и другие.<br>sync/atomic - содержит функции для атомарных операций с примитивными типами данных, такими как целые числа, указатели, булевы значения и т.д.<br>context - содержит примитивы для управления жизненным циклом и отменой горутин (goroutines), а также для передачи метаданных между ними.<br>chan - является встроенным типом данных, который представляет собой канал для обмена данными между горутинами, который может быть использован как примитив синхронизации или коммуникации.</p><p>Источники:</p><ul><li><a href="https://medium.com/german-gorelkin/synchronization-primitives-go-8857747d9660">Medium</a></li><li><a href="https://medium.com/nuances-of-programming/%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%B2-go-403b163c49d5">Medium</a></li></ul><h2 id="Чем-мьютекс-отличается-от-семафора"><a href="#Чем-мьютекс-отличается-от-семафора" class="headerlink" title="Чем мьютекс отличается от семафора?"></a>Чем мьютекс отличается от семафора?</h2><p>Мьютекс и семафор - это два способа синхронизации доступа к общим ресурсам в многопоточных программах. Они имеют разные преимущества и недостатки, и их выбор зависит от конкретной задачи.</p><p>Вот некоторые основные различия между мьютексом и семафором:</p><p>Мьютекс - это объект, который позволяет блокировать и разблокировать доступ к одному ресурсу, тогда как семафор - это переменная, которая позволяет контролировать доступ к нескольким ресурсам.<br>Мьютекс может быть захвачен или освобожден только тем потоком, который его заблокировал, тогда как семафор может быть изменен любым потоком.<br>Мьютекс обычно используется для взаимного исключения, т.е. для предотвращения состояний гонки, тогда как семафор обычно используется для координации, т.е. для синхронизации действий между потоками.<br>Мьютекс имеет только два состояния: заблокирован или разблокирован, тогда как семафор имеет целочисленное значение, которое может быть больше нуля.</p><p>Источники:</p><ul><li><a href="https://www.guru99.com/ru/mutex-vs-semaphore.html">Guru99</a></li></ul><h2 id="Что-такое-atomic-и-чем-отличается-от-мьютекса"><a href="#Что-такое-atomic-и-чем-отличается-от-мьютекса" class="headerlink" title="Что такое atomic и чем отличается от мьютекса?"></a>Что такое atomic и чем отличается от мьютекса?</h2><p>Атомики (atomics) - это функции, которые позволяют выполнять простые операции с общим ресурсом, такие как чтение, запись, инкремент, декремент, обмен или сравнение и присваивание. Атомики гарантируют, что эти операции будут выполнены атомарно, то есть без вмешательства других горутин. Атомики реализованы в пакете sync/atomic, и для их использования нужно вызывать соответствующие функции с указателем на ресурс. Атомики подходят для ситуаций, когда требуется выполнить быстрые и простые операции с ресурсом, такие как увеличение или уменьшение счетчика, установка или сброс флага, или проверка или изменение состояния.<br>Все атомики реализованы через спецальные регистры процессора и в коде го они написаны на ассемблере<br>Атомики являются примитивами низкого уровня реализующими атомарные операции с памятью.</p><ul><li><a href="https://habr.com/ru/articles/744822/">Атомики в Go: особенности внутренней реализации</a></li></ul><p>В общем, мьютексы и атомики имеют следующие отличия:</p><ul><li>Мьютексы работают с любыми типами данных, а атомики - только с примитивными типами, такими как int, uint, bool, pointer и т.д.</li><li>Мьютексы требуют явной блокировки и разблокировки, а атомики - нет.</li><li>Мьютексы позволяют выполнять любые операции с ресурсом, а атомики - только ограниченный набор операций.</li><li>Мьютексы могут быть более медленными и затратными, чем атомики, из-за переключения контекста и ожидания блокировки.</li><li>Мьютексы могут приводить к взаимным блокировкам (deadlocks), если не использовать их правильно, а атомики - нет.</li></ul><p>Источники:</p><ul><li><a href="https://golangify.com/concurency">Golangify</a></li><li><a href="https://metanit.com/go/tutorial/7.6.php">Metanit</a></li></ul><h2 id="Что-можно-использовать-для-ожидания-выполнения-N-горутин"><a href="#Что-можно-использовать-для-ожидания-выполнения-N-горутин" class="headerlink" title="Что можно использовать для ожидания выполнения N горутин?"></a>Что можно использовать для ожидания выполнения N горутин?</h2><p>Один из способов сделать это - использовать встроенную конструкцию WaitGroup из пакета sync. WaitGroup позволяет организовать синхронизацию между несколькими горутинами, которые выполняют параллельные или конкурентные задачи. WaitGroup имеет счетчик, который увеличивается при добавлении новой горутины и уменьшается при ее завершении. Основная горутина может вызвать метод Wait, который блокирует ее до тех пор, пока счетчик не станет равным нулю, то есть пока все горутины не закончат свою работу.</p><p>Например, вы можете написать следующий код, который запускает N горутин, каждая из которых печатает свой номер и засыпает на случайное время, а затем ожидает их завершения с помощью WaitGroup:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">5</span> <span class="comment">// количество горутин</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// создаем WaitGroup</span></span><br><span class="line">wg.Add(N)  <span class="comment">// устанавливаем счетчик на N</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= N; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// запускаем горутину с номером n</span></span><br><span class="line"><span class="comment">// при выходе из горутины уменьшаем счетчик на 1</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Горутина&quot;</span>, n, <span class="string">&quot;начала работу&quot;</span>)</span><br><span class="line"><span class="comment">// засыпаем на случайное время от 0 до 10 секунд</span></span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">10</span>)) * time.Second)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Горутина&quot;</span>, n, <span class="string">&quot;закончила работу&quot;</span>)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Ожидаем завершения горутин&quot;</span>)</span><br><span class="line"> <span class="comment">// блокируем основную горутину, пока счетчик не станет равным нулю</span></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Все горутины завершились&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Есть-общий-ресурс-Хотим-чтобы-к-нему-одновременно-обращались-только-N-горутин-Как-это-сделать"><a href="#Есть-общий-ресурс-Хотим-чтобы-к-нему-одновременно-обращались-только-N-горутин-Как-это-сделать" class="headerlink" title="Есть общий ресурс. Хотим, чтобы к нему одновременно обращались только N горутин. Как это сделать?"></a>Есть общий ресурс. Хотим, чтобы к нему одновременно обращались только N горутин. Как это сделать?</h2><p>Один из способов сделать это - использовать семафор (semaphore), который представляет собой переменную, которая хранит количество доступных ресурсов. Семафор может быть реализован с помощью канала (channel) с буфером размера N, который будет заполнен пустыми значениями.</p><p>Каждая горутина, которая хочет получить доступ к ресурсу, должна сначала получить значение из канала, а затем вернуть его обратно после завершения работы. Таким образом, канал будет выступать в роли блокировки, которая разрешает доступ только N горутинам одновременно.</p><p>Например, вы можете написать следующий код, который запускает M горутин, каждая из которых печатает свой номер и засыпает на случайное время, а затем ожидает их завершения с помощью семафора:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">3</span> <span class="comment">// количество доступных ресурсов</span></span><br><span class="line"><span class="keyword">const</span> M = <span class="number">10</span> <span class="comment">// количество горутин</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, N) <span class="comment">// создаем канал с буфером размера N</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= N; i++ &#123;</span><br><span class="line">sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// заполняем канал пустыми значениями</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= M; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> work(i, sem) <span class="comment">// запускаем горутину с номером i и каналом sem</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">20</span> * time.Second) <span class="comment">// ждем 20 секунд, пока все горутины закончат работу</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(number <span class="keyword">int</span>, sem <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"> <span class="comment">// получаем значение из канала, блокируя доступ к ресурсу</span></span><br><span class="line">&lt;-sem</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Горутина&quot;</span>, number, <span class="string">&quot;начала работу&quot;</span>)</span><br><span class="line"><span class="comment">// засыпаем на случайное время от 0 до 10 секунд</span></span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">10</span>)) * time.Second)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Горутина&quot;</span>, number, <span class="string">&quot;закончила работу&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// возвращаем значение в канал, разблокируя доступ к ресурсу</span></span><br><span class="line">sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Запустим-1000-горутин-с-инкрементом-инта-Получим-в-конце-тысячу-Что-делать-чтобы-получить-тысячу"><a href="#Запустим-1000-горутин-с-инкрементом-инта-Получим-в-конце-тысячу-Что-делать-чтобы-получить-тысячу" class="headerlink" title="Запустим 1000 горутин с инкрементом инта. Получим в конце тысячу? Что делать, чтобы получить тысячу?"></a>Запустим 1000 горутин с инкрементом инта. Получим в конце тысячу? Что делать, чтобы получить тысячу?</h2><p>Если вы запустите 1000 горутин с инкрементом инта, то скорее всего вы не получите в конце тысячу. Это потому, что инкремент не является атомарной операцией, то есть он состоит из трех шагов: чтения, изменения и записи значения. Если несколько горутин одновременно пытаются выполнить инкремент, то может возникнуть состояние гонки (race condition), когда одна горутина перезаписывает значение, измененное другой горутиной, и тем самым теряет часть инкрементов.</p><p>Чтобы получить тысячу в конце, нужно синхронизировать доступ к общей переменной, которая хранит инт. Для этого можно использовать один из следующих способов:</p><ul><li>Использовать мьютекс (mutex) из пакета sync, который позволяет блокировать и разблокировать доступ к переменной. Каждая горутина должна вызвать метод Lock перед инкрементом и метод Unlock после него, чтобы гарантировать, что только одна горутина может работать с переменной в один момент времени.</li><li>Использовать атомик (atomic) из пакета sync/atomic, который позволяет выполнять атомарные операции с примитивными типами данных. Вместо обычного инкремента можно использовать функцию AddInt32 или AddInt64, которая атомарно увеличивает значение переменной на заданное число и возвращает новое значение.</li></ul><h2 id="Есть-глобальная-мапа-глобальный-мьютекс-Две-функции-Одна-блочит-мьютекс-а-вторая-нет-Что-произойдет"><a href="#Есть-глобальная-мапа-глобальный-мьютекс-Две-функции-Одна-блочит-мьютекс-а-вторая-нет-Что-произойдет" class="headerlink" title="Есть глобальная мапа, глобальный мьютекс. Две функции. Одна блочит мьютекс, а вторая нет. Что произойдет?"></a>Есть глобальная мапа, глобальный мьютекс. Две функции. Одна блочит мьютекс, а вторая нет. Что произойдет?</h2><p>Если одна функция блокирует мьютекс перед работой с глобальной мапой, а другая нет, то может возникнуть ситуация, когда две функции одновременно пытаются изменить мапу, что может привести к состоянию гонки (race condition) и неопределенному поведению программы. </p><p>Состояние гонки означает, что результат работы программы зависит от случайного порядка выполнения операций, и может быть непредсказуемым или некорректным. </p><p>Например, если одна функция пытается добавить элемент в мапу, а другая пытается удалить элемент из мапы, то может случиться, что элемент будет удален до того, как он будет добавлен, или наоборот, или что элемент будет добавлен или удален дважды, или что мапа будет повреждена.</p><h2 id="Сколько-нужно-ядер-чтобы-начать-использовать-sync-Map"><a href="#Сколько-нужно-ядер-чтобы-начать-использовать-sync-Map" class="headerlink" title="Сколько нужно ядер, чтобы начать использовать sync.Map?"></a>Сколько нужно ядер, чтобы начать использовать sync.Map?</h2><p>sync.Map может быть полезен, если у вас высоконагруженная система с большим количеством ядер процессора (32+), и вы сталкиваетесь с проблемой ложной разделяемости (false sharing), когда разные горутины конкурируют за доступ к одному и тому же кеш-линии (cache line). В этом случае sync.Map может снизить количество конфликтов и повысить скорость работы с картой.</p><p>Однако, если у вас небольшое количество ядер (меньше 8), и вы часто записываете в карту, то sync.Map может быть неэффективнее, чем обычная карта с мьютексом, так как он использует сложную внутреннюю структуру, которая требует дополнительных вычислений и памяти.</p><p>Таким образом, нет однозначного ответа на вопрос, сколько нужно ядер, чтобы начать использовать sync.Map. Это зависит от конкретной задачи, характера операций с картой, нагрузки на систему и других факторов. </p><blockquote><p>Ложная разделяемость - это проблема, которая может возникнуть в многопроцессорных системах,<br>когда разные процессоры или ядра конкурируют за доступ к одному и тому же кеш-линии (cache line), то есть блоку памяти,<br>который загружается в кеш процессора для ускорения работы с данными.<br>Если один процессор изменяет данные в кеш-линии, то другие процессоры<br>должны обновить свои копии этой кеш-линии, что приводит к дополнительным задержкам и снижению производительности.<br>Ложная разделяемость может возникать, когда разные процессоры работают с разными данными, которые случайно попадают в одну кеш-линию, или когда разные процессоры работают с одними и теми же данными, но не синхронизируют свой доступ к ним.<br>Ложная разделяемость может быть устранена с помощью различных методов, таких как:</p><ul><li>Изменение размера или выравнивания структур данных, чтобы избежать перекрытия кеш-линий.</li><li>Использование атомарных (atomic) операций, которые не требуют блокировки кеш-линии.</li><li>Использование специальных инструкций, которые позволяют указать процессору, что данные в кеш-линии не будут изменяться.</li><li>Использование разных уровней кеша для разных типов данных.</li></ul></blockquote><p>Источники: </p><ul><li><a href="https://habr.com/ru/articles/338718/">Habr</a></li><li><a href="https://habrparser.blogspot.com/2013/10/lock-free.html">Blogspot</a></li></ul><h2 id="Как-устроена-WaitGroup-под-капотом-и-как-ее-можно-реализовать-самому"><a href="#Как-устроена-WaitGroup-под-капотом-и-как-ее-можно-реализовать-самому" class="headerlink" title="Как устроена WaitGroup под капотом и как ее можно реализовать самому?"></a>Как устроена WaitGroup под капотом и как ее можно реализовать самому?</h2><p>Под капотом WaitGroup реализован с помощью атомарных операций, которые обеспечивают потокобезопасность и высокую производительность. WaitGroup использует 64-битное целое число, которое разделено на две части: старшие 32 бита хранят счетчик горутин, а младшие 32 бита хранят счетчик ожидающих горутин. </p><p>Каждый раз, когда вызывается метод Add, WaitGroup атомарно увеличивает счетчик горутин на заданное значение. Каждый раз, когда вызывается метод Done, WaitGroup атомарно уменьшает счетчик горутин на единицу и проверяет, не стал ли он равным нулю. Если да, то WaitGroup атомарно увеличивает счетчик ожидающих горутин на единицу и разблокирует одну из ожидающих горутин с помощью сигнальной переменной (signal variable). </p><p>Каждый раз, когда вызывается метод Wait, WaitGroup атомарно уменьшает счетчик ожидающих горутин на единицу и проверяет, не стал ли он отрицательным. Если да, то WaitGroup атомарно возвращает счетчик ожидающих горутин в исходное состояние и блокирует текущую горутину с помощью сигнальной переменной.</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyWaitGroup - собственная реализация WaitGroup</span></span><br><span class="line"><span class="keyword">type</span> MyWaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="keyword">int64</span>      <span class="comment">// счетчик горутин</span></span><br><span class="line">waiter  <span class="keyword">int64</span>      <span class="comment">// счетчик ожидающих горутин</span></span><br><span class="line">signal  sync.Cond  <span class="comment">// сигнальная переменная</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add - добавляет n горутин в группу</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *MyWaitGroup)</span> <span class="title">Add</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">atomic.AddInt64(&amp;wg.counter, <span class="keyword">int64</span>(n)) <span class="comment">// атомарно увеличиваем счетчик горутин на n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Done - уменьшает счетчик горутин на 1 и разблокирует одну ожидающую горутину, если счетчик стал равным 0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *MyWaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt64(&amp;wg.counter, <span class="number">-1</span>) == <span class="number">0</span> &#123; <span class="comment">// атомарно уменьшаем счетчик горутин на 1 и проверяем, не стал ли он равным 0</span></span><br><span class="line">wg.signal.L.Lock() <span class="comment">// блокируем сигнальную переменную</span></span><br><span class="line">atomic.AddInt64(&amp;wg.waiter, <span class="number">1</span>) <span class="comment">// атомарно увеличиваем счетчик ожидающих горутин на 1</span></span><br><span class="line">wg.signal.Broadcast() <span class="comment">// разблокируем все ожидающие горутины</span></span><br><span class="line">wg.signal.L.Unlock() <span class="comment">// разблокируем сигнальную переменную</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait - блокирует текущую горутину, пока счетчик горутин не станет равным 0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *MyWaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.signal.L.Lock() <span class="comment">// блокируем сигнальную переменную</span></span><br><span class="line"><span class="keyword">if</span> atomic.AddInt64(&amp;wg.waiter, <span class="number">-1</span>) &lt; <span class="number">0</span> &#123; <span class="comment">// атомарно уменьшаем счетчик ожидающих горутин на 1 и проверяем, не стал ли он отрицательным</span></span><br><span class="line">atomic.StoreInt64(&amp;wg.waiter, <span class="number">0</span>) <span class="comment">// атомарно возвращаем счетчик ожидающих горутин в исходное состояние</span></span><br><span class="line">wg.signal.Wait() <span class="comment">// блокируем текущую горутину</span></span><br><span class="line">&#125;</span><br><span class="line">wg.signal.L.Unlock() <span class="comment">// разблокируем сигнальную переменную</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg MyWaitGroup <span class="comment">// создаем экземпляр MyWaitGroup</span></span><br><span class="line">wg.Add(<span class="number">2</span>) <span class="comment">// добавляем две горутины в группу</span></span><br><span class="line">work := <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// при выходе из горутины вызываем метод Done</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Горутина %d начала работу\n&quot;</span>, id)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// имитируем работу горутины</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Горутина %d завершила работу\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// запускаем две горутины</span></span><br><span class="line"><span class="keyword">go</span> work(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> work(<span class="number">2</span>)</span><br><span class="line">wg.Wait() <span class="comment">// ожидаем завершения всех горутин в группе</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Горутины завершились&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Источники:</p><ul><li><a href="https://habr.com/ru/companies/timeweb/articles/712542/">Habr</a></li><li><a href="https://metanit.com/go/tutorial/7.7.php">Metanit</a></li><li><a href="https://medium.com/nuances-of-programming/%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%B2-go-403b163c49d5">Medium</a></li></ul><h2 id="В-чем-разница-между-Mutex-и-RWMutex"><a href="#В-чем-разница-между-Mutex-и-RWMutex" class="headerlink" title="В чем разница между Mutex и RWMutex?"></a>В чем разница между Mutex и RWMutex?</h2><p>Mutex и RWMutex в Go оба используются для синхронизации доступа к данным в многопоточной среде, но они работают немного по-разному:</p><p>Mutex:</p><ul><li>Mutex предоставляет взаимоисключающую блокировку, которая позволяет только одной горутине в любой момент времени иметь доступ к защищенным данным.</li><li>Если другая горутина пытается получить доступ к данным, когда Mutex заблокирован, она будет заблокирована до тех пор, пока Mutex не будет разблокирован.</li></ul><p>RWMutex:</p><ul><li>RWMutex (Reader-Writer Mutex) предоставляет более гибкую семантику блокировки.</li><li>RWMutex позволяет множеству горутин получить параллельный доступ для чтения (блокировка чтения), но только одной горутине получить эксклюзивный доступ на запись (блокировка записи).<br>Это означает, что несколько горутин могут одновременно читать данные, но запись данных может производить только одна горутина.</li></ul><h2 id="Когда-нужно-использовать-Mutex-а-когда-RWMutex"><a href="#Когда-нужно-использовать-Mutex-а-когда-RWMutex" class="headerlink" title="Когда нужно использовать Mutex, а когда RWMutex?"></a>Когда нужно использовать Mutex, а когда RWMutex?</h2><p>Использование Mutex:</p><ul><li>Mutex следует использовать, когда у вас есть данные, которые могут быть изменены одновременно несколькими горутинами.</li><li>Mutex обеспечивает взаимоисключающую блокировку, что позволяет только одной горутине в любой момент времени иметь доступ к защищенным данным.</li></ul><p>Использование RWMutex:</p><ul><li>RWMutex следует использовать, когда у вас есть данные, которые часто читаются, но редко обновляются.</li><li>RWMutex позволяет множеству горутин получить параллельный доступ для чтения, но только одной горутине получить эксклюзивный доступ на запись.<br>Это может улучшить производительность, если у вас есть данные, которые часто читаются, так как несколько горутин могут одновременно читать данные.</li></ul><p>Источники: </p><ul><li><a href="https://qna.habr.com/q/787559">Habr</a></li><li><a href="https://stackoverflow.com/questions/48861029/what-is-the-benefit-of-using-rwmutex-instead-of-mutex">Stackoverflow</a></li></ul><p><img src="/images/golang_sync.jpg" alt="Вот вам и sync primitives"></p>]]></content>
    
    
    <summary type="html">Вопросы по примитивам синхронизации</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Примитивы синхронизации" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/"/>
    
    <category term="Примитивы синхронизации" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Пример sync и async worker</title>
    <link href="https://goxpert.ru/2024/06/01/concurrency/sync-worker/"/>
    <id>https://goxpert.ru/2024/06/01/concurrency/sync-worker/</id>
    <published>2024-06-01T07:15:00.000Z</published>
    <updated>2024-06-03T07:14:40.271Z</updated>
    
    <content type="html"><![CDATA[<p>В этом примере мы собираемся создать рабочий пакет, который будет использоваться для синхронной и асинхронной обработки заданий.</p><p>Упаковка</p><p>Хотя этот пакет делает то, что обещает, ему нужны еще три бонусные функции.</p><ul><li>Возможность завершать длительные задания.</li><li>Возможность закрытия каналов.</li><li>Возможность убить всех рабочих.</li></ul><p>В этом примере для заданий используются «небуферизованные» каналы. Однако, если вы хотите ограничить количество заданий одновременно, вы можете обновить NewWorker()функцию, чтобы использовать «буферизованные» каналы, как показано ниже.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(workerTotal, jobTotal <span class="keyword">int</span>)</span> <span class="title">Worker</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Worker&#123;</span><br><span class="line">    total:      workerTotal,</span><br><span class="line">    jobChan:    <span class="built_in">make</span>(<span class="keyword">chan</span> Job, jobTotal),</span><br><span class="line">    resultChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, jobTotal),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>код</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> worker</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// id represents the job identifier.</span></span><br><span class="line">  <span class="comment">// id представляет идентификатор задания.</span></span><br><span class="line">  id <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// NewJob returns a `Job` instance.</span></span><br><span class="line"><span class="comment">// NewJob возвращает экземпляр Job.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewJob</span><span class="params">(id <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Job</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Job&#123;</span><br><span class="line">    id: id,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// total represents the amount of workers to be run at startup.</span></span><br><span class="line">  <span class="comment">// total представляет количество воркеров, которые будут запущены при запуске.</span></span><br><span class="line">  total <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// jobChan represents a two-way &quot;unbuffered&quot; channel that has unlimited</span></span><br><span class="line">  <span class="comment">// capacity for the jobs.</span></span><br><span class="line">  <span class="comment">// jobChan представляет собой двусторонний «небуферизованный» канал с неограниченной </span></span><br><span class="line">  <span class="comment">// пропускной способностью для заданий. </span></span><br><span class="line">  jobChan <span class="keyword">chan</span> Job</span><br><span class="line">  <span class="comment">// resultChan represents a two-way &quot;unbuffered&quot; channel that has unlimited</span></span><br><span class="line">  <span class="comment">// capacity for the job results.</span></span><br><span class="line">  <span class="comment">// resultChan представляет собой двусторонний «небуферизованный» канал, который имеет неограниченную </span></span><br><span class="line">  <span class="comment">// емкость для результатов задания.</span></span><br><span class="line">  resultChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// NewWorker returns a `Worker` instance.</span></span><br><span class="line"><span class="comment">// NewWorker возвращает экземпляр Worker.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(workerTotal <span class="keyword">int</span>)</span> <span class="title">Worker</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Worker&#123;</span><br><span class="line">    total:      workerTotal,</span><br><span class="line">    jobChan:    <span class="built_in">make</span>(<span class="keyword">chan</span> Job),</span><br><span class="line">    resultChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Start brings up certain amount of worker(s) so that they can pick up and work</span></span><br><span class="line"><span class="comment">// on the job(s).</span></span><br><span class="line"><span class="comment">// Start вызывает определенное количество рабочих(воркеров), чтобы они могли взять и работать </span></span><br><span class="line"><span class="comment">// на задании (джобе(ах)).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= w.total; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> w.run(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Add adds a job to a channel so that it could be picked up and worked on by</span></span><br><span class="line"><span class="comment">// the running worker(s).</span></span><br><span class="line"><span class="comment">// Add добавляет задание(джоб) в канал, чтобы его мог взять и обработать </span></span><br><span class="line"><span class="comment">// работающий работник(и)(воркер(ы)). </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">Add</span><span class="params">(job Job)</span></span> &#123;</span><br><span class="line">  w.jobChan &lt;- job</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Result returns a channel so that it could be ranged over in order to fetch</span></span><br><span class="line"><span class="comment">// job results from the running worker(s).</span></span><br><span class="line"><span class="comment">// Result возвращает канал, чтобы его можно было ранжировать для получения </span></span><br><span class="line"><span class="comment">// результатов задания от работающего работника(ов)(воркера).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">Result</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  <span class="keyword">return</span> w.resultChan</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// run runs a worker and works on the job(s).</span></span><br><span class="line"><span class="comment">// run запускает работника и работает над заданием(ями) джобами.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">run</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(id, <span class="string">&quot;running...&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> job := &lt;- w.jobChan:</span><br><span class="line">      fmt.Printf(<span class="string">&quot;%d выбрал задание %v @ %s\n&quot;</span>, id, job.id, time.Now().UTC())</span><br><span class="line">      <span class="comment">//fmt.Printf(&quot;%d picked up job %v @ %s\n&quot;, id, job.id, time.Now().UTC())</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Pretend like doing something.</span></span><br><span class="line">      <span class="comment">// Делаем вид, будто что-то делаем.</span></span><br><span class="line">      rand.Seed(time.Now().UnixNano())</span><br><span class="line">      time.Sleep(time.Duration(rand.Intn(<span class="built_in">len</span>([]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;))) * time.Second)</span><br><span class="line">      <span class="comment">// Done. (сделано)</span></span><br><span class="line"> </span><br><span class="line">      fmt.Printf(<span class="string">&quot;%d завершил задание %v @ %s\n&quot;</span>, id, job.id, time.Now().UTC())</span><br><span class="line">      <span class="comment">//fmt.Printf(&quot;%d completed job %v @ %s\n&quot;, id, job.id, time.Now().UTC())</span></span><br><span class="line">      w.resultChan &lt;- job.id</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">      <span class="comment">//fmt.Println(id, &quot;waiting...&quot;)</span></span><br><span class="line">      fmt.Println(id, <span class="string">&quot;ожидание...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Применение"><a href="#Применение" class="headerlink" title="Применение"></a>Применение</h1><h2 id="Асинхронный"><a href="#Асинхронный" class="headerlink" title="Асинхронный"></a>Асинхронный</h2><p>Это асинхронный (неблокирующий) пример, поэтому задания обрабатываются случайным образом и в произвольном порядке. Программа никогда не выходит. Результаты заданий печатаются независимо друг от друга. Важно иметь несколько работников.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line">  <span class="string">&quot;internal/worker&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// Create new worker(s) and start.</span></span><br><span class="line">   <span class="comment">// Создаем новых рабочих и запускаем.</span></span><br><span class="line">   w := worker.NewWorker(<span class="number">3</span>)</span><br><span class="line">   w.Start()</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="comment">// Add jobs.</span></span><br><span class="line">     <span class="comment">// Добовляем задания</span></span><br><span class="line">     <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">w.Add(worker.NewJob(i))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Print results.</span></span><br><span class="line">   <span class="comment">// Печать результатов.</span></span><br><span class="line">   <span class="keyword">for</span> v := <span class="keyword">range</span> w.Result() &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Result:&quot;</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="синхронный"><a href="#синхронный" class="headerlink" title="синхронный"></a>синхронный</h2><p>Это синхронный (блокирующий) пример, поэтому задания обрабатываются одно за другим по порядку. Программа завершает работу после завершения заданий. Результаты заданий печатаются один за другим по порядку. Иметь несколько работников бессмысленно, поскольку одновременно обрабатывается одно задание.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;internal/worker&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// Create new worker(s) and start.</span></span><br><span class="line">   <span class="comment">// Создаем новых рабочих и запускаем.</span></span><br><span class="line">   w := worker.NewWorker(<span class="number">3</span>)</span><br><span class="line">   w.Start()</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Add jobs.</span></span><br><span class="line">   <span class="comment">// Добавляем задания.</span></span><br><span class="line">   w.Add(worker.NewJob(<span class="number">1</span>))</span><br><span class="line">   <span class="comment">// Print results.</span></span><br><span class="line">   <span class="comment">// Распечатываем результаты.</span></span><br><span class="line">   v := &lt;- w.Result()</span><br><span class="line">   <span class="comment">//fmt.Println(&quot;Result:&quot;, v)</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;Результат:&quot;</span>, v)</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Add jobs.</span></span><br><span class="line">   <span class="comment">// Добавляем задания.</span></span><br><span class="line">   w.Add(worker.NewJob(<span class="number">2</span>))</span><br><span class="line">   <span class="comment">// Print results.</span></span><br><span class="line">   v = &lt;- w.Result()</span><br><span class="line">   fmt.Println(<span class="string">&quot;Result:&quot;</span>, v)</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Add jobs.</span></span><br><span class="line">   w.Add(worker.NewJob(<span class="number">3</span>))</span><br><span class="line">   <span class="comment">// Print results.</span></span><br><span class="line">   v = &lt;- w.Result()</span><br><span class="line">   fmt.Println(<span class="string">&quot;Result:&quot;</span>, v)</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Add jobs.</span></span><br><span class="line">   w.Add(worker.NewJob(<span class="number">4</span>))</span><br><span class="line">   <span class="comment">// Print results.</span></span><br><span class="line">   v = &lt;- w.Result()</span><br><span class="line">   fmt.Println(<span class="string">&quot;Result:&quot;</span>, v)</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Add jobs.</span></span><br><span class="line">   w.Add(worker.NewJob(<span class="number">5</span>))</span><br><span class="line">   <span class="comment">// Print results.</span></span><br><span class="line">   v = &lt;- w.Result()</span><br><span class="line">   fmt.Println(<span class="string">&quot;Result:&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/golang_sync.jpg" alt="Вот вам и пример синхронного и асинхронного воркера с Golang"></p>]]></content>
    
    
    <summary type="html">Пример синхронного и асинхронного воркера(рабочего процесса) с Golang</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Примитивы синхронизации" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/"/>
    
    <category term="Примитивы синхронизации" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Типы данных</title>
    <link href="https://goxpert.ru/2024/06/01/types/types-common/"/>
    <id>https://goxpert.ru/2024/06/01/types/types-common/</id>
    <published>2024-06-01T07:14:00.000Z</published>
    <updated>2024-06-02T11:10:01.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-type-switch"><a href="#Что-такое-type-switch" class="headerlink" title="Что такое type switch?"></a>Что такое type switch?</h2><blockquote><p><strong><code>Type switch</code></strong> в Go - это способ проверить, какого типа является значение, хранящееся в интерфейсе. Это похоже на обычный <strong><code>switch</code></strong>, но вместо значений в кейсах указываются типы.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do(<span class="number">21</span>)</span><br><span class="line">    do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Какие-типы-данных-есть-в-Golang"><a href="#Какие-типы-данных-есть-в-Golang" class="headerlink" title="Какие типы данных есть в Golang?"></a>Какие типы данных есть в Golang?</h2><ol><li><strong>Целочисленные типы</strong>: <strong><code>int8</code></strong>, <strong><code>int16</code></strong>, <strong><code>int32</code></strong>, <strong><code>int64</code></strong>, <strong><code>uint8</code></strong>, <strong><code>uint16</code></strong>, <strong><code>uint32</code></strong>, <strong><code>uint64</code></strong>, <strong><code>byte</code></strong> (синоним для <strong><code>uint8</code></strong>), <strong><code>rune</code></strong> (синоним для <strong><code>int32</code></strong>), <strong><code>int</code></strong> и <strong><code>uint</code>.</strong></li><li><strong>Числа с плавающей точкой</strong>: <strong><code>float32</code></strong> и <strong><code>float64</code>.</strong></li><li><strong>Строки</strong>: <strong><code>string</code></strong>.</li><li><strong>Булев тип</strong>: <strong><code>bool</code></strong>.</li><li><strong>Составные типы</strong>: Массивы, срезы, структуры, ассоциативные массивы</li></ol><h2 id="Какой-длины-руна"><a href="#Какой-длины-руна" class="headerlink" title="Какой длины руна?"></a>Какой длины руна?</h2><p><strong><code>rune</code></strong> - это алиас для <strong><code>int32</code></strong>. Это означает, что <strong><code>rune</code></strong> занимает 4 байта или 32 бита. Каждая <strong><code>rune</code></strong> представляет собой один Юникод символ. Например, строка может быть преобразована в срез <strong><code>rune</code></strong> (<strong><code>[]rune</code></strong>), и каждый элемент этого среза будет представлять собой один Юникод символ.</p><h2 id="Как-реализовать-Enum-в-Golang"><a href="#Как-реализовать-Enum-в-Golang" class="headerlink" title="Как реализовать Enum в Golang?"></a>Как реализовать Enum в Golang?</h2><p>В Go нет встроенной поддержки перечислений (enum), но их можно эмулировать с помощью констант. Вот пример реализации enum в Go:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Season <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Summer Season = <span class="literal">iota</span></span><br><span class="line">    Autumn</span><br><span class="line">    Winter</span><br><span class="line">    Spring</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Season)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...]<span class="keyword">string</span>&#123;<span class="string">&quot;Лето&quot;</span>, <span class="string">&quot;Осень&quot;</span>, <span class="string">&quot;Зима&quot;</span>, <span class="string">&quot;Весна&quot;</span>&#125;[s]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Winter</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Что-если-во-время-компиляции-переполним-тип-В-int8-запишем-256"><a href="#Что-если-во-время-компиляции-переполним-тип-В-int8-запишем-256" class="headerlink" title="Что если во время компиляции переполним тип? В int8 запишем 256?"></a>Что если во время компиляции переполним тип? В int8 запишем 256?</h2><p>Если вы попытаетесь записать значение, превышающее максимально допустимое для данного типа, в Go, то произойдет переполнение типа.</p><p>Например, <strong><code>int8</code></strong> может хранить значения от -128 до 127. Если вы попытаетесь записать 256 в переменную типа <strong><code>int8</code></strong>, то произойдет переполнение. В результате, вместо 256 будет записано значение, которое соответствует остатку от деления 256 на 256 (количество возможных значений для <strong><code>int8</code></strong>), то есть 01.</p><p>Важно отметить, что такое поведение может привести к неожиданным результатам, поэтому всегда следует убедиться, что значения, которые вы записываете в переменные, не превышают максимально допустимые для их типа</p><h2 id="Что-происходит-при-переполнении-числа-например-в-uint8-выйдем-за-границу-на-1"><a href="#Что-происходит-при-переполнении-числа-например-в-uint8-выйдем-за-границу-на-1" class="headerlink" title="Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?"></a>Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?</h2><p>Если вы попытаетесь записать значение, превышающее максимально допустимое для данного типа, в Go, то произойдет переполнение типа.</p><p>Например, <strong><code>uint8</code></strong> может хранить значения от 0 до 255. Если вы попытаетесь записать 256 в переменную типа <strong><code>uint8</code></strong>, то произойдет переполнение. В результате, вместо 256 будет записано значение, которое соответствует остатку от деления 256 на 256 (количество возможных значений для <strong><code>uint8</code></strong>), то есть 0.</p><p>Важно отметить, что такое поведение может привести к неожиданным результатам, поэтому всегда следует убедиться, что значения, которые вы записываете в переменные, не превышают максимально допустимые для их типа.</p><p><img src="/images/golang_types.jpg" alt="Вот вам и types"></p>]]></content>
    
    
    <summary type="html">Общие вопросы по типам данных в Golang</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Типы" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A2%D0%B8%D0%BF%D1%8B/"/>
    
    <category term="Типы" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A2%D0%B8%D0%BF%D1%8B/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Хеш-мапы (map)</title>
    <link href="https://goxpert.ru/2024/06/01/types/map/"/>
    <id>https://goxpert.ru/2024/06/01/types/map/</id>
    <published>2024-06-01T07:13:00.000Z</published>
    <updated>2024-06-02T10:55:48.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-мапа-map"><a href="#Что-такое-мапа-map" class="headerlink" title="Что такое мапа (map)??"></a>Что такое мапа (<a href="https://go.dev/tour/moretypes/19">map</a>)??</h2><p>Мапа в Go - это тип данных, который предназначен для хранения пар “ключ-значение”. Это структура данных, также известная как хэш-таблица, словарь или ассоциативный массив. Мапа позволяет получить значение по ключу. Ключами в мапе могут быть любые сравниваемые типы — все сравнимые типы.</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    m[<span class="string">&quot;apple&quot;</span>] = <span class="number">1</span></span><br><span class="line">    m[<span class="string">&quot;banana&quot;</span>] = <span class="number">2</span></span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Что-произойдет-при-конкурентной-записи-в-мапу"><a href="#Что-произойдет-при-конкурентной-записи-в-мапу" class="headerlink" title="Что произойдет при конкурентной записи в мапу?"></a>Что произойдет при конкурентной записи в мапу?</h2><p>Мапы в Go не являются потокобезопасными. Это означает, что если вы попытаетесь записать данные в мапу из нескольких горутин одновременно, это может привести к состоянию гонки. Если вам нужно работать с мапой из нескольких горутин, вы должны использовать механизмы синхронизации, такие как sync.Mutex или sync.RWMutex, чтобы гарантировать, что в любой момент времени только одна горутина может изменять мапу. Вот пример использования sync.Mutex для безопасной записи в мапу из нескольких горутин:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            mu.Lock()</span><br><span class="line">            m[i] = i * <span class="number">2</span></span><br><span class="line">            mu.Unlock()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Как-устроена-мапа-под-капотом"><a href="#Как-устроена-мапа-под-капотом" class="headerlink" title="Как устроена мапа под капотом?"></a>Как устроена мапа под капотом?</h2><p>Мапа в Go - это структура данных, которая хранит пары “ключ-значение”. Внутри мапы ключи и значения хранятся в выделенном участке памяти, последовательно. Для получения адресов ячеек конкретных ключей и значений используется хэширующая функция. </p><p>Вот некоторые детали о том, как устроена мапа в Go:</p><ul><li><a href="https://www.youtube.com/watch?v=P_SXTUiA-9Y">Мапа разбивается на бакеты для более эффективного поиска</a>.</li><li><a href="https://www.youtube.com/watch?v=P_SXTUiA-9Y">Хэш-функция используется для равномерного распределения ключей по бакетам</a>.</li><li><a href="https://www.youtube.com/watch?v=P_SXTUiA-9Y">При переполнении бакета происходит рост мапы</a>.</li><li><a href="https://www.youtube.com/watch?v=P_SXTUiA-9Y">Эвакуация данных происходит при заполнении мапы</a>.</li><li><a href="https://www.youtube.com/watch?v=P_SXTUiA-9Y">Порядок обхода мапы является случайным</a>.</li></ul><h2 id="Какие-ключи-могут-быть-у-мапы"><a href="#Какие-ключи-могут-быть-у-мапы" class="headerlink" title="Какие ключи могут быть у мапы?"></a>Какие ключи могут быть у мапы?</h2><p>Ключами в мапе могут быть любые сравниваемые типы — все простые скалярные типы, массивы. Несравниваемые типы — срезы, мапы, функции. Ключи и значения мапы будут храниться в выделенном участке памяти, последовательно.</p><h2 id="Какая-сложность-работы-с-мапой"><a href="#Какая-сложность-работы-с-мапой" class="headerlink" title="Какая сложность работы с мапой?"></a>Какая сложность работы с мапой?</h2><p>Операции вставки, удаления и поиска в мапе в Go обычно имеют сложность O(1), то есть они выполняются за постоянное время. Это достигается за счет использования хэш-таблицы внутри мапы. Однако в худшем случае, когда все ключи попадают в один и тот же бакет, эти операции могут иметь сложность O(n), где n - количество элементов в мапе</p><h2 id="Можно-ли-взять-адрес-элемента-мапы-и-почему"><a href="#Можно-ли-взять-адрес-элемента-мапы-и-почему" class="headerlink" title="Можно ли взять адрес элемента мапы и почему?"></a>Можно ли взять адрес элемента мапы и почему?</h2><p>Нет, нельзя взять адрес элемента мапы в Go. Это связано с тем, как устроена мапа внутри. Мапа разбита на бакеты, и при росте мапы элементы могут переходить из одного бакета в другой. Это означает, что адрес элемента в памяти может меняться, и поэтому Go не позволяет взять адрес элемента мапы. Если вы попытаетесь это сделать, компилятор выдаст ошибку.</p><h2 id="Как-работает-эвакуация-данных"><a href="#Как-работает-эвакуация-данных" class="headerlink" title="Как работает эвакуация данных?"></a>Как работает эвакуация данных?</h2><p>Эвакуация данных в мапе Go происходит при переполнении мапы. Когда количество элементов в мапе достигает определенного порога, мапа “растет” - создается новая, большая мапа, и все элементы из старой мапы копируются в новую. Этот процесс называется “эвакуацией”. Важно отметить, что в Go рост мапы происходит асинхронно. Это означает, что во время роста мапы могут возникать ситуации, когда при попытке доступа к данным часть бакетов уже переехала в новую мапу, а часть еще нет. Благодаря этому не происходит просадок во время роста большой мапы.</p><h2 id="Как-разрешаются-коллизии-в-мапе"><a href="#Как-разрешаются-коллизии-в-мапе" class="headerlink" title="Как разрешаются коллизии в мапе?"></a>Как разрешаются коллизии в мапе?</h2><p>В мапе Go коллизии разрешаются с помощью бакетов. Каждый бакет может содержать до восьми элементов. Если все ячейки в бакете заняты, то происходит переполнение и мапа “растет” - создается новая, большая мапа, и все элементы из старой мапы копируются в новую. Этот процесс называется “эвакуацией”. При этом, благодаря использованию хэш-функции, ключи равномерно распределяются по бакетам. Это позволяет минимизировать количество коллизий и обеспечивает быстрый доступ к данным.</p><h2 id="В-функции-make-для-мапы-мы-указываем-число-Что-оно-дает"><a href="#В-функции-make-для-мапы-мы-указываем-число-Что-оно-дает" class="headerlink" title="В функции make для мапы мы указываем число. Что оно дает?"></a>В функции make для мапы мы указываем число. Что оно дает?</h2><p>Число, указываемое в функции make для мапы в Go, определяет начальную вместимость мапы. Это число элементов, которые мапа сможет хранить без необходимости расширения. Если вы заранее знаете, сколько элементов будет в мапе, вы можете использовать это число при создании мапы, чтобы уменьшить количество операций реаллокации памяти, что может улучшить производительность. Вот пример создания мапы с начальной вместимостью 10:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="Стало-слишком-много-коллизий-в-мапе-как-решить-проблему"><a href="#Стало-слишком-много-коллизий-в-мапе-как-решить-проблему" class="headerlink" title="Стало слишком много коллизий в мапе, как решить проблему?"></a>Стало слишком много коллизий в мапе, как решить проблему?</h2><p>Если в мапе Go стало слишком много коллизий, вы можете использовать следующие подходы для решения проблемы:</p><p>Изменить размер мапы: Если мапа слишком мала, она может быстро заполняться, что приводит к большому количеству коллизий. В этом случае вы можете увеличить размер мапы, чтобы уменьшить вероятность коллизий.</p><p>Использовать метод раздельного связывания: Это метод, при котором внутри хеш-таблицы хранится массив фиксированного размера, элементы которого - связанные списки. По хешу ключа определяется элемент массива (bucket - корзину) и потом смотрится в списке, нет ли такого элемента и действуется соответствующее (добавляется/удаляется/модифицируется).</p><h2 id="Чем-мапа-отличается-от-sync-Map"><a href="#Чем-мапа-отличается-от-sync-Map" class="headerlink" title="Чем мапа отличается от sync.Map?"></a>Чем мапа отличается от sync.Map?</h2><p><strong>sync.Map</strong> и обычная мапа в Go имеют различия в использовании и производительности</p><ol><li><strong>Потокобезопасность</strong>: Обычная мапа в Go не является потокобезопасной, что означает, что одновременная запись в мапу из нескольких горутин может привести к состоянию гонки. В то время как <strong><code>sync.Map</code></strong> разработана для использования в многопоточных ситуациях и обеспечивает потокобезопасность.</li><li><strong>Производительность</strong> <strong><code>sync.Map</code></strong> обычно близка по скорости к обычной мапе с <strong><code>sync.RWMutex</code></strong>, но может быть лучше в случае чтения. Когда происходит чтение и обновление, <strong><code>sync.Map</code></strong> будет иметь элементы и в чтении, и в “грязном” состоянии.</li><li><strong>Использование</strong> <strong><code>sync.Map</code></strong> - это структура с методами, предоставляющими обычные операции с мапой. Вы не можете использовать синтаксис <strong><code>a_map[&quot;key&quot;]</code></strong> с <strong><code>sync.Map</code></strong>, вместо этого нужно использовать методы, такие как <strong><code>Load</code></strong>, <strong><code>Store</code></strong> и <strong><code>Delete</code></strong>.</li><li><strong>Структура</strong> <strong><code>sync.Map</code></strong> - это сложная структура, обычно состоящая из двух мап - одной для чтения и одной для новых элементов.</li></ol><p>Важно отметить, что <strong><code>sync.Map</code></strong> следует использовать только в тех случаях, когда большинство операций с мапой - это чтение, и когда ключи мапы меняются динамически.</p><h2 id="Какая-функция-используется-при-хешировании-ключа-в-мапе"><a href="#Какая-функция-используется-при-хешировании-ключа-в-мапе" class="headerlink" title="Какая функция используется при хешировании ключа в мапе?"></a>Какая функция используется при хешировании ключа в мапе?</h2><p>При хешировании ключа в мапе golang используется функция runtime.mapaccess1_faststr, которая принимает тип мапы, саму мапу и ключ в виде строки. Функция ищет ключ в мапе и возвращает указатель на соответствующее значение. Функция runtime.mapaccess1_faststr является специализированной версией функции runtime.mapaccess1, которая работает с любым типом ключа.</p><p>Хеширование ключа в мапе golang основано на алгоритме MurmurHash, который быстро и равномерно распределяет ключи по хеш-таблице. Хеш-таблица в golang состоит из массива корзин (buckets), каждая из которых содержит до восьми пар ключ-значение. Кроме того, каждая корзина имеет указатель на переполненную корзину, которая создается при коллизии хешей.</p><p>Если вы хотите узнать больше о реализации мапы в golang, вы можете почитать эту статью или эту статью на Хабре. Они объясняют детали работы мапы в golang с примерами кода и иллюстрациями. 😊</p><p>Источники:</p><ul><li><a href="https://habr.com/ru/articles/457728/">Habr</a></li><li><a href="https://habr.com/ru/articles/704796/">Habr</a></li><li><a href="https://golangforall.com/ru/post/map-principles-golang.html">GolangForAll</a></li></ul><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">  Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex) <span class="comment">// иначе паника</span></span><br><span class="line">  m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>,&#125;</span><br><span class="line">  m[<span class="string">&quot;A2&quot;</span>] = Vertex&#123;<span class="number">42</span>, <span class="number">-24</span>,&#125;</span><br><span class="line">  </span><br><span class="line">  fmt.Println(m)     <span class="comment">// реализовано так, что детерменированный вывод</span></span><br><span class="line">  <span class="keyword">for</span> _, val := <span class="keyword">range</span> m &#123;  <span class="comment">// произвольный обход</span></span><br><span class="line">    fmt.Println(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <a href="https://habr.com/ru/companies/avito/articles/774618/">Хорошая статья Pro Map</a><br><img src="/images/golang_map.jpg" alt="Вот вам и map"></p>]]></content>
    
    
    <summary type="html">Вопросы по хеш-мапам в Golang.</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Хеш-мапы" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A5%D0%B5%D1%88-%D0%BC%D0%B0%D0%BF%D1%8B/"/>
    
    <category term="Хеш-мапы" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A5%D0%B5%D1%88-%D0%BC%D0%B0%D0%BF%D1%8B/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Интерфейсы</title>
    <link href="https://goxpert.ru/2024/06/01/types/interface/"/>
    <id>https://goxpert.ru/2024/06/01/types/interface/</id>
    <published>2024-06-01T07:12:00.000Z</published>
    <updated>2024-06-02T09:51:46.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-интерфейс-interface"><a href="#Что-такое-интерфейс-interface" class="headerlink" title="Что такое интерфейс (interface)?"></a>Что такое интерфейс (<a href="https://go.dev/tour/methods/9">interface</a>)?</h2><p>Интерфейс в golang - это тип, который определяет набор сигнатур методов. Интерфейс позволяет абстрагироваться от конкретной реализации и работать с разными типами данных, которые реализуют один и тот же интерфейс. </p><p>Например, интерфейс Printer определяет метод Print(), который может быть реализован разными структурами, такими как User или Document. Для того, чтобы тип реализовывал интерфейс, он должен предоставить определения всех методов интерфейса. </p><p>В Go реализация интерфейса происходит неявно, то есть не требуется указывать, что тип реализует интерфейса.</p><h2 id="Для-чего-используется-интерфейс"><a href="#Для-чего-используется-интерфейс" class="headerlink" title="Для чего используется интерфейс?"></a>Для чего используется интерфейс?</h2><p>Интерфейс в golang используется для определения набора методов, которые должен реализовывать какой-либо тип данных.</p><p>Интерфейсы позволяют абстрагироваться от конкретных реализаций и работать с разными типами, имеющими общее поведение. Интерфейсы также способствуют модульности, гибкости и переиспользованию кода. </p><p>Например, интерфейс fmt.Stringer определяет метод String(), который возвращает строковое представление любого типа, реализующего этот интерфейс. </p><h2 id="Как-в-строго-типизированным-языке-сделать-функцию-которая-работает-с-разными-типами"><a href="#Как-в-строго-типизированным-языке-сделать-функцию-которая-работает-с-разными-типами" class="headerlink" title="Как в строго типизированным языке сделать функцию, которая работает с разными типами?"></a>Как в строго типизированным языке сделать функцию, которая работает с разными типами?</h2><p>Один из способов сделать это - использовать обобщения (generics), которые появились в Go 1.18. Обобщения позволяют объявлять и использовать функции или типы, которые написаны для работы с любым из набора типов, предоставляемых вызывающим кодом. Для этого в Go введены три новых элемента языка:</p><ul><li>Параметры типов для функций и типов. Это означает, что вы можете задать переменную типа T, которая может принимать разные конкретные типы при вызове функции или создании типа.</li><li>Определение интерфейсных типов как множеств типов, включая типы, не имеющие методов. Это означает, что вы можете задать ограничение (constraint) на параметр типа, указав, какие свойства должен иметь тип, чтобы его можно было использовать в обобщенной функции или типе.</li><li>Вывод типов, который позволяет опускать аргументы типов во многих случаях при вызове функции. Это означает, что вы можете не указывать конкретный тип при вызове обобщенной функции, если компилятор может сам его определить из контекста.</li></ul><h2 id="Есть-интерфейс-а-есть-указатель-на-структуру-который-nil-Кладем-указатель-в-интерфейс-Что-если-сравнить-интерфейс-с-nil"><a href="#Есть-интерфейс-а-есть-указатель-на-структуру-который-nil-Кладем-указатель-в-интерфейс-Что-если-сравнить-интерфейс-с-nil" class="headerlink" title="Есть интерфейс, а есть указатель на структуру, который nil. Кладем указатель в интерфейс. Что если сравнить интерфейс с nil?"></a>Есть интерфейс, а есть указатель на структуру, который nil. Кладем указатель в интерфейс. Что если сравнить интерфейс с nil?</h2><p>Интерфейс в Go является типом, который может хранить любые типы, удовлетворяющие ему.</p><p>Интерфейс, в котором лежит указатель на структуру, и nil интерфейс сравнимы между собой. Если вы сравните интерфейс, в котором лежит указатель на структуру, с nil, результат будет “false”, потому что интерфейс не пустой.</p><p>Однако, если вы сравните интерфейс с интерфейсом, содержащим nil указатель, результат будет “false”.</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SomeInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    SomeMethod()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SomeStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SomeStruct)</span> <span class="title">SomeMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s SomeStruct</span><br><span class="line">    <span class="keyword">var</span> i1 SomeInterface = &amp;s</span><br><span class="line">    <span class="keyword">var</span> i2 SomeInterface</span><br><span class="line"></span><br><span class="line">    fmt.Println(i1 == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">    fmt.Println(i2 == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В примере выше мы создаем интерфейс SomeInterface с методом SomeMethod. Внутри интерфейса i1 лежит указатель на структуру SomeStruct, а интерфейс i2 является пустым интерфейсом. Сравнивая i1 с nil, мы получаем “false”, так как интерфейс i1 не пустой. Сравнивая i2 с nil, мы получаем “true”, так как интерфейс i2 является пустым интерфейсом.</p><h2 id="Чем-any-отличается-от-пустого-интерфейса"><a href="#Чем-any-отличается-от-пустого-интерфейса" class="headerlink" title="Чем any отличается от пустого интерфейса?"></a>Чем <code>any</code> отличается от пустого интерфейса?</h2><p>Пустой интерфейс в Go (nil интерфейс) не хранит значение. Если интерфейс пустой, то его сравнение с nil будет всегда возвращать true.</p><p>Тип any (тоже известный как интерфейс <strong><code>interface&#123;&#125;</code></strong>) в Go - это специальный тип интерфейса, который может хранить значение любого типа. Тип any является универсальным типом и может быть использован, когда нужно написать обобщенный код, который будет работать с различными типами.</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i1 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = (*SomeStruct)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(i1 == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">    fmt.Println(i2 == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Чем-пустой-интерфейс-отличается-от-пустой-структуры"><a href="#Чем-пустой-интерфейс-отличается-от-пустой-структуры" class="headerlink" title="Чем пустой интерфейс отличается от пустой структуры?"></a>Чем пустой интерфейс отличается от пустой структуры?</h2><p>Пустой интерфейс (interface{}) и пустая структура (struct{}) являются двумя различными понятиями в Go.</p><p>Пустая структура (struct{}) не содержит никаких полей и не реализует никаких методов. Она используется в основном для создания переменных, которые не содержат никаких данных. Например:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>Пустой интерфейс (interface{}), с другой стороны, может указывать на любое значение любого типа. Он не имеет никаких методов и не содержит никаких данных. Он используется в основном для передачи значений различных типов в функции или методы. Например:</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyInterface <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">emptyInterface = <span class="number">10</span></span><br><span class="line">emptyInterface = <span class="string">&quot;hello&quot;</span></span><br><span class="line">emptyInterface = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure><p>Таким образом, основное отличие заключается в том, что пустая структура не может указывать на значения различных типов, в то время как пустой интерфейс может.</p><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">  Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a Abser</span><br><span class="line">  f := MyFloat(-math.Sqrt2)</span><br><span class="line">  v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">  </span><br><span class="line">  a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">  a = &amp;v <span class="comment">// a *Vertex implements Abser  реализует интерфейс</span></span><br><span class="line"></span><br><span class="line">  a = v  <span class="comment">// Ошибка! v - это Vertex (а не *Vertex) и НЕ реализует интерфейс</span></span><br><span class="line">  fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">  X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/golang_interface.jpg" alt="Вот вам и interface"></p>]]></content>
    
    
    <summary type="html">Вопросы по интерфейсам в Golang.</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Интерфейсы" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B/"/>
    
    <category term="Интерфейсы" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Указатели</title>
    <link href="https://goxpert.ru/2024/06/01/types/pointers/"/>
    <id>https://goxpert.ru/2024/06/01/types/pointers/</id>
    <published>2024-06-01T07:11:00.000Z</published>
    <updated>2024-06-02T09:11:50.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-указатель-pointer"><a href="#Что-такое-указатель-pointer" class="headerlink" title="Что такое указатель (pointer)?"></a>Что такое указатель (<a href="https://go.dev/tour/moretypes/1">pointer</a>)?</h2><p>Указатель в программировании - это переменная, которая хранит адрес другой переменной в памяти. В Go, указатели используются для того, чтобы иметь возможность изменять значение переменной напрямую или для оптимизации производительности при работе с большими структурами данных.</p><p>Вы можете получить адрес переменной с помощью оператора <code>&amp;</code>, а затем этот адрес можно сохранить в указателе. Для доступа к значению, на которое указывает указатель, используется оператор <code>*</code>.</p><p>Вот пример:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">    p = &amp;x <span class="comment">// Получаем адрес переменной x и сохраняем его в p</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(*p) <span class="comment">// Выводим значение переменной, на которую указывает p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере <code>p</code> является указателем на <code>x</code>, и <code>*p</code> дает нам доступ к значению <code>x</code>.</p><h2 id="Что-такое-ссылка-на-значение"><a href="#Что-такое-ссылка-на-значение" class="headerlink" title="Что такое ссылка на значение?"></a>Что такое ссылка на значение?</h2><p>В Go, ссылка на значение обычно означает использование указателей. Указатель - это переменная, которая хранит адрес другой переменной. </p><p>Вы можете получить адрес переменной с помощью оператора <code>&amp;</code>, а затем этот адрес можно сохранить в указателе. Для доступа к значению, на которое указывает указатель, используется оператор <code>*</code>.</p><p>Вот пример:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">    p = &amp;x <span class="comment">// Получаем адрес переменной x и сохраняем его в p</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(*p) <span class="comment">// Выводим значение переменной, на которую указывает p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере <code>p</code> является указателем на <code>x</code>, и <code>*p</code> дает нам доступ к значению <code>x</code>.</p><h2 id="Чем-отличается-ссылка-от-указателя"><a href="#Чем-отличается-ссылка-от-указателя" class="headerlink" title="Чем отличается ссылка от указателя?"></a>Чем отличается ссылка от указателя?</h2><p>В Go, термины “ссылка” и “указатель” часто используются взаимозаменяемо, но они имеют некоторые различия.</p><ol><li><strong>Указатель</strong> - это переменная, которая хранит адрес другой переменной. Указатели могут быть нулевыми, что означает, что они не указывают ни на одну переменную.</li><li><strong>Ссылка</strong> - это альтернативное имя для уже существующей переменной. В Go, ссылки как таковые не существуют, но аналогом являются указатели.</li></ol><p>Основное различие между ними заключается в том, что указатели могут быть переназначены для указания на разные переменные во время выполнения, в то время как ссылки, как правило, не могут быть изменены после их инициализации (хотя в Go это не применимо, так как нет ссылок в традиционном понимании этого термина).</p><h2 id="Чем-чревато-передавать-структуру-по-ссылке"><a href="#Чем-чревато-передавать-структуру-по-ссылке" class="headerlink" title="Чем чревато передавать структуру по ссылке?"></a>Чем чревато передавать структуру по ссылке?</h2><p>Передача структуры по ссылке в Go означает передачу указателя на структуру. Это может иметь следующие последствия:</p><ol><li><strong>Изменение оригинальной структуры</strong>: Поскольку вы передаете указатель, любые изменения, которые вы вносите в структуру внутри функции, будут отражаться на оригинальной структуре. Это может быть как полезным, так и опасным, в зависимости от того, ожидаете ли вы эти изменения.</li><li><strong>Производительность</strong>: Передача структуры по ссылке обычно быстрее, чем передача по значению, особенно для больших структур, поскольку не требуется копирование всей структуры.</li><li><strong>Nullability</strong>: Указатели могут быть <code>nil</code>, в то время как структуры - нет. Это значит, что если вы передаете структуру по ссылке, вам нужно быть уверенным, что она не <code>nil</code>, прежде чем обращаться к ее полям, иначе вы получите панику во время выполнения.</li></ol><p>В общем, передача структуры по ссылке может быть полезной для оптимизации производительности и для изменения оригинальной структуры, но требует более внимательного обращения, чтобы избежать ошибок во время выполнения.</p><h2 id="Для-чего-используются-указатели"><a href="#Для-чего-используются-указатели" class="headerlink" title="Для чего используются указатели?"></a>Для чего используются указатели?</h2><p>Указатели в Go используются по нескольким причинам:</p><ol><li><strong>Изменение значения в функции</strong>: Если вы хотите, чтобы функция изменяла значение переменной, вы можете передать указатель на эту переменную в функцию. Это позволяет функции напрямую изменять значение переменной, а не ее копию.</li><li><strong>Оптимизация производительности</strong>: Для больших структур данных передача указателей может быть более эффективной, чем передача значений, поскольку передача значений включает в себя копирование всей структуры данных.</li><li><strong>Работа с динамическими структурами данных</strong>: Указатели необходимы для создания сложных структур данных, таких как связанные списки, деревья, графы и т.д.</li><li><strong>Интерфейсы и полиморфизм</strong>: Указатели используются для реализации интерфейсов и полиморфизма. Если методы определены для указателя на тип, то только указатели этого типа могут использоваться для вызова этих методов.</li></ol><p>Вот пример использования указателей для изменения значения в функции:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *x = *x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    increment(&amp;x)</span><br><span class="line">    fmt.Println(x) <span class="comment">// Выводит 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере функция <code>increment</code> принимает указатель на <code>int</code> и увеличивает значение, на которое указывает этот указатель.</p><h2 id="Для-чего-в-практике-используешь-указатели"><a href="#Для-чего-в-практике-используешь-указатели" class="headerlink" title="Для чего в практике используешь указатели?"></a>Для чего в практике используешь указатели?</h2><p>В практическом программировании на Go указатели используются в следующих ситуациях:</p><ol><li><strong>Изменение значения переменной в функции</strong>: Если вы хотите изменить значение переменной внутри функции, вы передаете указатель на эту переменную в функцию. Это позволяет функции напрямую изменять значение переменной, а не ее копию.</li><li><strong>Оптимизация производительности</strong>: Для больших структур данных передача указателей может быть более эффективной, чем передача значений, поскольку передача значений включает в себя копирование всей структуры данных.</li><li><strong>Работа с динамическими структурами данных</strong>: Указатели необходимы для создания сложных структур данных, таких как связанные списки, деревья, графы и т.д.</li><li><strong>Интерфейсы и полиморфизм</strong>: Указатели используются для реализации интерфейсов и полиморфизма. Если методы определены для указателя на тип, то только указатели этого типа могут использоваться для вызова этих методов.</li><li><strong>Опциональные поля в структурах</strong>: В Go, указатели могут быть <code>nil</code>, что позволяет им использоваться для представления опциональных полей в структурах.</li><li><strong>Работа с внешними ресурсами</strong>: Указатели часто используются при работе с внешними ресурсами, такими как файлы или сетевые соединения. Это позволяет функциям и методам изменять состояние этих ресурсов.</li></ol><h2 id="Какие-есть-средства-для-работы-с-указателями"><a href="#Какие-есть-средства-для-работы-с-указателями" class="headerlink" title="Какие есть средства для работы с указателями?"></a>Какие есть средства для работы с указателями?</h2><p>В Go есть несколько ключевых средств для работы с указателями:</p><ol><li><strong>Оператор <code>&amp;</code></strong>: Этот оператор используется для получения адреса переменной. Например, если <code>x</code> - это переменная, то <code>&amp;x</code> - это адрес этой переменной.</li><li><strong>Оператор <code>*</code></strong>: Этот оператор используется для доступа к значению, на которое указывает указатель. Например, если <code>p</code> - это указатель на <code>int</code>, то <code>*p</code> - это <code>int</code>, на который указывает <code>p</code>.</li><li><strong>Функция <code>new</code></strong>: Эта функция создает новую переменную заданного типа, инициализирует ее нулем и возвращает указатель на нее.</li></ol><p>Вот пример использования этих средств:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    p := &amp;x <span class="comment">// Получаем адрес переменной x</span></span><br><span class="line">    fmt.Println(*p) <span class="comment">// Выводим значение, на которое указывает p</span></span><br><span class="line"></span><br><span class="line">    y := <span class="built_in">new</span>(<span class="keyword">int</span>) <span class="comment">// Создаем новую переменную типа int и получаем указатель на нее</span></span><br><span class="line">    fmt.Println(*y) <span class="comment">// Выводит 0, так как новые переменные инициализируются нулем</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере <code>p</code> - это указатель на <code>x</code>, и <code>*p</code> дает нам доступ к значению <code>x</code>. <code>y</code> - это указатель на новую переменную <code>int</code>, инициализированную нулем.</p><h2 id="Когда-лучше-использовать-не-использовать-указатели"><a href="#Когда-лучше-использовать-не-использовать-указатели" class="headerlink" title="Когда лучше использовать/не использовать указатели?"></a>Когда лучше использовать/не использовать указатели?</h2><p>Указатели в Go могут быть полезными, но их использование зависит от конкретной ситуации. Вот несколько рекомендаций:</p><p><strong>Используйте указатели, когда:</strong></p><ol><li><strong>Вы хотите изменить значение переменной внутри функции.</strong> Если вы передаете переменную по значению, функция получит копию этой переменной, и любые изменения, которые вы внесете, не повлияют на исходную переменную. Если вы передаете переменную по ссылке (т.е. передаете указатель на нее), функция сможет изменить исходную переменную.</li><li><strong>Вы работаете с большими структурами данных.</strong> Передача больших структур данных по значению может быть накладной с точки зрения производительности, поскольку это требует копирования всей структуры. Передача указателя на структуру вместо этого может быть более эффективной.</li><li><strong>Вы хотите иметь возможность присвоить переменной значение <code>nil</code>.</strong> В Go, только указатели могут иметь значение <code>nil</code>.</li></ol><p><strong>Избегайте использования указателей, когда:</strong></p><ol><li><strong>Вы работаете с небольшими структурами данных или простыми типами.</strong> Для небольших структур данных или простых типов, таких как <code>int</code> или <code>bool</code>, передача по значению обычно быстрее и безопаснее.</li><li><strong>Вы не хотите, чтобы функция изменяла исходную переменную.</strong> Если вы передаете переменную по значению, функция не сможет изменить исходную переменную, что может быть полезно для предотвращения неожиданных побочных эффектов.</li><li><strong>Вы хотите избежать ошибок во время выполнения, связанных с <code>nil</code>.</strong> Если вы используете указатель, вам нужно быть уверенным, что он не <code>nil</code>, прежде чем обращаться к его значению, иначе вы получите панику во время выполнения.</li></ol><p><img src="/images/golang_pointer.jpg" alt="Вот вам и pointer"></p>]]></content>
    
    
    <summary type="html">Вопросы по указателям в Golang.</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Указатели" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8/"/>
    
    <category term="Указатели" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Структуры</title>
    <link href="https://goxpert.ru/2024/06/01/types/structs/"/>
    <id>https://goxpert.ru/2024/06/01/types/structs/</id>
    <published>2024-06-01T07:10:00.000Z</published>
    <updated>2024-06-01T18:44:23.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Имеет-ли-значение-порядок-полей-в-структуре"><a href="#Имеет-ли-значение-порядок-полей-в-структуре" class="headerlink" title="Имеет ли значение порядок полей в структуре?"></a>Имеет ли значение порядок полей в структуре?</h2><p>Да, порядок полей в структуре Go может иметь значение в некоторых случаях.</p><p>Выравнивание памяти: Go размещает поля структур в соответствии с гарантиями выравнивания для типов полей. Это может влиять на общий размер структуры и использование памяти.</p><p>Источники: </p><ul><li><a href="https://ru.stackoverflow.com/questions/1541584/%d0%9f%d0%be%d1%80%d1%8f%d0%b4%d0%be%d0%ba-%d0%bf%d0%b5%d1%80%d0%b5%d0%bc%d0%bd%d0%bd%d1%8b%d1%85-%d0%b2-%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%82%d1%83%d1%80%d0%b5-go-golang">Stackoverflow</a></li></ul><h2 id="От-чего-зависит-размер-выравнивания-в-структуре"><a href="#От-чего-зависит-размер-выравнивания-в-структуре" class="headerlink" title="От чего зависит размер выравнивания в структуре?"></a>От чего зависит размер выравнивания в структуре?</h2><p>Размер выравнивания в структуре в Go зависит от нескольких факторов:</p><ul><li>Тип данных: Размер выравнивания обычно зависит от типа данных. Например, int32 требует выравнивания по 4 байтам.</li><li>Порядок полей: Порядок полей в структуре может влиять на размер выравнивания. Если поля структуры переставить, размер структуры может измениться.</li><li>Архитектура системы: Размер выравнивания также может зависеть от архитектуры системы. Например, на 32-битной архитектуре структуры выравниваются под 4 байта.</li></ul><p>Важно отметить, что выравнивание влияет на производительность и использование памяти, поэтому его следует учитывать при проектировании структур.</p><p><img src="/images/golang_struct.jpg" alt="Вот вам и struct"></p>]]></content>
    
    
    <summary type="html">Вопросы по структурам в Golang.</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Структуры" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B/"/>
    
    <category term="Структуры" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Строки</title>
    <link href="https://goxpert.ru/2024/06/01/types/strings/"/>
    <id>https://goxpert.ru/2024/06/01/types/strings/</id>
    <published>2024-06-01T07:09:00.000Z</published>
    <updated>2024-06-03T07:27:11.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-string-или-строки"><a href="#Что-такое-string-или-строки" class="headerlink" title="Что такое string или строки?"></a>Что такое string или строки?</h2><p>Строка в golang - это последовательность символов, которая представляет собой текстовые данные.<br>Строки в golang объявляются с типом string и заключаются в двойные кавычки, например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">// или сокращенная запись</span></span><br><span class="line">s := <span class="string">&quot;hey&quot;</span></span><br></pre></td></tr></table></figure><p>Строки в golang являются неизменяемыми(immutable), то есть их нельзя модифицировать после создания. Однако, можно создавать новые строки из существующих, используя различные операции и функции. </p><p>Например, можно склеивать строки с помощью оператора +, сравнивать строки с помощью оператора ==, или применять функции из пакета <code>strings</code> для поиска, замены, преобразования и других манипуляций со строками.</p><p>Строки в golang хранят символы в кодировке UTF-8, которая поддерживает множество языков и специальных символов.</p><p>Каждый символ в строке называется руной (<code>rune</code>), которая является псевдонимом для типа <code>int32</code>. Руны можно получать из строк с помощью цикла for-range или функции range, а также преобразовывать в строки с помощью функции <code>string</code>.</p><p>Источники: </p><ul><li><a href="https://www.programiz.com/golang/string">Programiz</a></li><li><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-the-strings-package-in-go-ru">DigitalOcean</a></li></ul><h2 id="Какие-особенности-есть-у-string"><a href="#Какие-особенности-есть-у-string" class="headerlink" title="Какие особенности есть у string?"></a>Какие особенности есть у string?</h2><p>Строка в golang - это неизменяемая последовательность символов в кодировке UTF-8, которая представляет собой текстовые данные. Строки в golang имеют тип <code>string</code> и заключаются в двойные кавычки или обратные апострофы. Строки в golang поддерживают множество языков и специальных символов, включая русские буквы и эмодзи. </p><p>Строки в golang можно объединять, сравнивать, искать, заменять, преобразовывать и выполнять другие манипуляции с помощью различных функций из пакета <code>strings</code>. Строки в golang также можно преобразовывать в руны (кодовые значения символов) и байты (единицы хранения данных) для более низкоуровневой работы с текстом</p><ul><li><a href="https://golangify.com/string">Golangify</a></li></ul><h2 id="Как-устроена-строка-внутри-а-точнее-reflect-String-и-reflect-StringHeader"><a href="#Как-устроена-строка-внутри-а-точнее-reflect-String-и-reflect-StringHeader" class="headerlink" title="Как устроена строка внутри, а точнее reflect.String и reflect.StringHeader?"></a>Как устроена строка внутри, а точнее reflect.String и reflect.StringHeader?</h2><p>reflect.String - это псевдоним для типа string, который является неизменяемой последовательностью символов в кодировке UTF-8. </p><p>reflect.StringHeader - это структура, которая содержит два поля: Data и Len. Data - это указатель на первый байт строки, а Len - это длина строки в байтах. Структура reflect.StringHeader может быть получена из строки с помощью функции unsafe.Pointer, которая преобразует любое значение в указатель безопасного типа. Например, можно использовать такой код:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">fmt.Println(sh.Data, sh.Len) <span class="comment">// выводит адрес и длину строки</span></span><br></pre></td></tr></table></figure><p>Структура reflect.StringHeader может быть также использована для создания новой строки из существующей, изменяя ее указатель или длину. Например, можно использовать такой код:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello, world!&quot;</span></span><br><span class="line">sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">sh.Data += <span class="number">7</span> <span class="comment">// сдвигаем указатель на 7 байтов</span></span><br><span class="line">sh.Len -= <span class="number">7</span> <span class="comment">// уменьшаем длину на 7 байтов</span></span><br><span class="line">fmt.Println(s) <span class="comment">// выводит &quot;world!&quot;</span></span><br></pre></td></tr></table></figure><p>Однако, такое использование reflect.StringHeader может быть опасным, так как оно нарушает неизменяемость строк и может привести к непредвиденным ошибкам или поведению. Например, если мы изменим длину строки больше, чем ее емкость, то мы можем получить доступ к памяти, которая не принадлежит строке, и вызвать панику или нарушение сегментации. Также, если мы изменим указатель на данные, то мы можем потерять ссылку на оригинальную строку и вызвать утечку памяти или сборку мусора.</p><p>Поэтому, reflect.String и reflect.StringHeader следует использовать с осторожностью и только в тех случаях, когда это необходимо для решения конкретной задачи. В большинстве случаев, можно обойтись стандартными функциями и методами для работы со строками в golang.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">&quot;Let&#x27;s&quot;</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line">t += <span class="string">&quot; Go&quot;</span>   <span class="comment">// выделяется новая память на стеке</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">smile := <span class="string">&quot;This is smile 😊&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;len %v, rune %v\n&quot;</span>, <span class="built_in">len</span>(smile), utf8.RuneCountInString(smile))</span><br><span class="line">fmt.Println(smile)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Напиши быструю инверсию строки(abc -&gt; cba)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package reverse can reverse things, particularly strings.</span></span><br><span class="line"><span class="keyword">package</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="comment">// String returns its argument string reversed rune-wise left to right.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">String</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">r := []<span class="keyword">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">r[i], r[j] = r[j], r[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Для-общего-развития-можно-посмотреть-и-на-Ускорение-конкатенации-строк-в-Go-своими-руками"><a href="#Для-общего-развития-можно-посмотреть-и-на-Ускорение-конкатенации-строк-в-Go-своими-руками" class="headerlink" title="Для общего развития можно посмотреть и на Ускорение конкатенации строк в Go своими руками"></a>Для общего развития можно посмотреть и на <a href="https://habr.com/ru/articles/417479/">Ускорение конкатенации строк в Go своими руками</a></h2><p><img src="/images/golang_string.jpg" alt="Вот вам и string"></p>]]></content>
    
    
    <summary type="html">Вопросы по строкам в Golang.</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Строки" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8/"/>
    
    <category term="Строки" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Массивы и слайсы</title>
    <link href="https://goxpert.ru/2024/06/01/types/array-slice/"/>
    <id>https://goxpert.ru/2024/06/01/types/array-slice/</id>
    <published>2024-06-01T07:08:00.000Z</published>
    <updated>2024-06-01T17:43:41.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-слайс"><a href="#Что-такое-слайс" class="headerlink" title="Что такое слайс?"></a>Что такое слайс?</h2><p>Слайс в golang - это динамический массив, который может хранить элементы одного типа. Слайс имеет нефиксированную длину, которая может изменяться в процессе работы с ним. Слайс также имеет вместимость, которая определяет, сколько элементов может поместиться в слайс без выделения новой памяти. Слайс можно создавать из массивов, с помощью функции make или литералов слайсов.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Слайс можно считать как ссылку на массив, который содержит элементы слайса.<br>Слайс состоит из трех полей: указателя на первый элемент массива, длины слайса и вместимости слайса.<br>Слайс можно передавать в функции по значению, но при этом изменение элементов слайса в функции отразится на исходном слайсе, так как они ссылаются на один и тот же массив.</p><p>Слайсом можно манипулировать с помощью различных операций и функций. Например, можно получать подслайсы с помощью оператора [:], добавлять элементы в конец слайса с помощью функции append, копировать элементы из одного слайса в другой с помощью функции copy, сортировать элементы слайса с помощью функции sort, и так далее.</p><h2 id="Чем-массив-отличается-от-слайса"><a href="#Чем-массив-отличается-от-слайса" class="headerlink" title="Чем массив отличается от слайса?"></a>Чем массив отличается от слайса?</h2><p>Массив и слайс в golang - это структуры данных, которые могут хранить элементы одного типа. Однако, между ними есть несколько отличий:</p><ul><li>Массив имеет фиксированный размер, который определяется при его создании. Слайс имеет переменную длину, которая может изменяться в процессе работы с ним.</li><li>Массив является значением, а слайс - ссылкой. При передаче массива в функцию или присваивании его другой переменной, происходит копирование всех его элементов. При передаче слайса в функцию или присваивании его другой переменной, происходит копирование только его заголовка, а не элементов.</li><li>Массив можно сравнивать с другим массивом того же размера и типа с помощью оператора ==. Слайс нельзя сравнивать с другим слайсом с помощью оператора ==, только с nil.</li><li>Массив можно инициализировать с помощью литерала массива, указав его размер и элементы в фигурных скобках. Слайс можно инициализировать с помощью литерала слайса, не указывая его размер, или с помощью функции make, указав его длину и вместимость</li></ul><h2 id="Как-работает-append"><a href="#Как-работает-append" class="headerlink" title="Как работает append?"></a>Как работает append?</h2><p>Функция append в golang позволяет добавлять элементы в конец слайса, увеличивая его длину и вместимость при необходимости. Функция append принимает слайс и один или несколько элементов того же типа, что и слайс, и возвращает новый слайс, содержащий все элементы исходного слайса и добавленные элементы. </p><p>Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создаем слайс из трех элементов</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// добавляем два элемента в конец слайса</span></span><br><span class="line">fmt.Println(s) <span class="comment">// выводит [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><p>Функция append может также принимать другой слайс в качестве аргумента, если он заключен в оператор … Это позволяет объединять два слайса в один. </p><p>Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создаем первый слайс</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// создаем второй слайс</span></span><br><span class="line">s3 := <span class="built_in">append</span>(s1, s2...) <span class="comment">// добавляем второй слайс в конец первого слайса</span></span><br><span class="line">fmt.Println(s3) <span class="comment">// выводит [1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure><p>Функция append работает таким образом, что если вместимость исходного слайса достаточна для добавления новых элементов, то она просто копирует их в свободное пространство массива, на который ссылается слайс. </p><p>Если же вместимость исходного слайса недостаточна, то функция append выделяет новый массив большего размера, копирует в него все элементы исходного слайса и добавляет новые элементы. Затем функция append возвращает новый слайс, который ссылается на новый массив.</p><h2 id="До-какого-размера-можно-увеличивать-слайс"><a href="#До-какого-размера-можно-увеличивать-слайс" class="headerlink" title="До какого размера можно увеличивать слайс?"></a>До какого размера можно увеличивать слайс?</h2><p>Размер слайса в golang ограничен только доступной памятью в системе. Однако, при увеличении размера слайса с помощью функции append, может происходить перевыделение памяти, если вместимость исходного слайса недостаточна для добавления новых элементов. При этом, функция append выделяет новый массив большего размера, копирует в него все элементы исходного слайса и добавляет новые элементы. Затем функция append возвращает новый слайс, который ссылается на новый массив.</p><p>При перевыделении памяти, функция append следует определенной стратегии, чтобы избежать частого копирования и минимизировать оверхед. При текущем размере слайса менее 256 элементов, размер памяти увеличивается вдвое (вне зависимости от запрашиваемой cap). При размере слайса больше 256 элементов, слайс увеличивается на четверть текущего размера.</p><p>Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// создаем слайс с длиной 0 и вместимостью 5</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// выводит 0 5</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// добавляем 5 элементов в слайс</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// выводит 5 5</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">6</span>) <span class="comment">// добавляем еще один элемент в слайс</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// выводит 6 10 - вместимость увеличилась вдвое</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) <span class="comment">// добавляем еще 4 элемента в слайс</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// выводит 10 10</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">11</span>) <span class="comment">// добавляем еще один элемент в слайс</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// выводит 11 20 - вместимость увеличилась вдвое</span></span><br></pre></td></tr></table></figure><h2 id="Берем-от-слайса-слайс-куда-будет-указывать-его-указатель"><a href="#Берем-от-слайса-слайс-куда-будет-указывать-его-указатель" class="headerlink" title="Берем от слайса слайс, куда будет указывать его указатель?"></a>Берем от слайса слайс, куда будет указывать его указатель?</h2><p>Если мы берем от слайса слайс, то его указатель будет указывать на тот же массив, что и указатель исходного слайса, но с другим смещением. Например, если мы имеем слайс s, который ссылается на массив [1, 2, 3, 4, 5], и мы берем от него подслайс s[1:3], то его указатель будет указывать на тот же массив, но с элемента 2. То есть, подслайс будет содержать элементы [2, 3] из исходного массива.</p><p>Это означает, что если мы изменим элементы подслайса, то это отразится на исходном слайсе и наоборот, так как они ссылаются на один и тот же массив. Однако, если мы добавим элементы в подслайс с помощью функции append, то это может привести к перевыделению памяти и созданию нового массива, если вместимость подслайса недостаточна. В этом случае, подслайс будет ссылаться на новый массив, а исходный слайс - на старый.</p><h2 id="В-чем-разница-между-слайсом-указателей-и-слайсом-значений-с-точки-зрения-вызова-функции"><a href="#В-чем-разница-между-слайсом-указателей-и-слайсом-значений-с-точки-зрения-вызова-функции" class="headerlink" title="В чем разница между слайсом указателей и слайсом значений с точки зрения вызова функции?"></a>В чем разница между слайсом указателей и слайсом значений с точки зрения вызова функции?</h2><p>Разница между слайсом указателей и слайсом значений с точки зрения вызова функции заключается в том, как они передаются и изменяются внутри функции. </p><p>Слайс указателей - это слайс, который содержит указатели на элементы другого типа, например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sp []*<span class="keyword">int</span> <span class="comment">// слайс указателей на int</span></span><br></pre></td></tr></table></figure><p>Слайс значений - это слайс, который содержит элементы другого типа, например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sv []<span class="keyword">int</span> <span class="comment">// слайс значений int</span></span><br></pre></td></tr></table></figure><p>Когда мы передаем слайс указателей в функцию, мы копируем только заголовок слайса, который содержит указатель на первый элемент, длину и вместимость.</p><p>Однако, сами элементы слайса, на которые указывают указатели, не копируются. Это означает, что если мы изменяем элементы слайса в функции, то это отразится на исходном слайсе, так как они ссылаются на одни и те же значения. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x := <span class="number">1</span></span><br><span class="line">  y := <span class="number">2</span></span><br><span class="line">  z := <span class="number">3</span></span><br><span class="line">  sp := []*<span class="keyword">int</span>&#123;&amp;x, &amp;y, &amp;z&#125; <span class="comment">// создаем слайс указателей</span></span><br><span class="line">  fmt.Println(*sp[<span class="number">0</span>], *sp[<span class="number">1</span>], *sp[<span class="number">2</span>]) <span class="comment">// выводит 1 2 3</span></span><br><span class="line">  modifySlicePointers(sp) <span class="comment">// передаем слайс в функцию</span></span><br><span class="line">  fmt.Println(*sp[<span class="number">0</span>], *sp[<span class="number">1</span>], *sp[<span class="number">2</span>]) <span class="comment">// выводит 10 20 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlicePointers</span><span class="params">(sp []*<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  *sp[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// изменяем значение, на которое указывает первый элемент слайса</span></span><br><span class="line">  *sp[<span class="number">1</span>] = <span class="number">20</span> <span class="comment">// изменяем значение, на которое указывает второй элемент слайса</span></span><br><span class="line">  *sp[<span class="number">2</span>] = <span class="number">30</span> <span class="comment">// изменяем значение, на которое указывает третий элемент слайса</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Когда мы передаем слайс значений в функцию, мы также копируем только заголовок слайса, который содержит указатель на первый элемент, длину и вместимость. Однако, сами элементы слайса, на которые указывает указатель, также не копируются. Это означает, что если мы изменяем элементы слайса в функции, то это также отразится на исходном слайсе, так как они ссылаются на одни и те же значения. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sv := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создаем слайс значений</span></span><br><span class="line">  fmt.Println(sv[<span class="number">0</span>], sv[<span class="number">1</span>], sv[<span class="number">2</span>]) <span class="comment">// выводит 1 2 3</span></span><br><span class="line">  modifySliceValues(sv) <span class="comment">// передаем слайс в функцию</span></span><br><span class="line">  fmt.Println(sv[<span class="number">0</span>], sv[<span class="number">1</span>], sv[<span class="number">2</span>]) <span class="comment">// выводит 10 20 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySliceValues</span><span class="params">(sv []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  sv[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// изменяем значение первого элемента слайса</span></span><br><span class="line">  sv[<span class="number">1</span>] = <span class="number">20</span> <span class="comment">// изменяем значение второго элемента слайса</span></span><br><span class="line">  sv[<span class="number">2</span>] = <span class="number">30</span> <span class="comment">// изменяем значение третьего элемента слайса</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Стоит быть внимательным при добавлении элементов в слайс в функции с помощью <code>append</code>, так как мы изменяем копию структуры слайса. В этом случае, слайс в функции будет иметь другие значния len, cap и, возможно, ссылки на массив. Это означает, что добавленные элементы не будут видны в исходном слайсе. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sv := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создаем слайс значений</span></span><br><span class="line">  appendSliceValues(sv) <span class="comment">// передаем слайс в функцию</span></span><br><span class="line">  fmt.Println(sv) <span class="comment">// выводит [1 2 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSliceValues</span><span class="params">(sv []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  sv = <span class="built_in">append</span>(sv, <span class="number">4</span>) <span class="comment">// добавляем элемент в слайс</span></span><br><span class="line">  fmt.Println(sv) <span class="comment">// выводит [1 2 3 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Если мы хотим, чтобы добавленные элементы сохранялись в исходном слайсе, мы должны возвращать слайс из функции и присваивать его исходному слайсу. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sv := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создаем слайс значений</span></span><br><span class="line">  sv = appendSliceValues(sv) <span class="comment">// передаем слайс в функцию и присваиваем его исходному слайсу</span></span><br><span class="line">  fmt.Println(sv) <span class="comment">// выводит [1 2 3 4]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSliceValues</span><span class="params">(sv []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  sv = <span class="built_in">append</span>(sv, <span class="number">4</span>) <span class="comment">// добавляем элемент в слайс</span></span><br><span class="line">  <span class="keyword">return</span> sv <span class="comment">// возвращаем слайс из функции</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Какие-есть-ограничения-при-работе-со-слайсом"><a href="#Какие-есть-ограничения-при-работе-со-слайсом" class="headerlink" title="Какие есть ограничения при работе со слайсом?"></a>Какие есть ограничения при работе со слайсом?</h2><p>При работе со слайсом есть некоторые ограничения, которые нужно учитывать:</p><ul><li>Слайс не может содержать элементы разных типов, только одного. Для хранения элементов разных типов нужно использовать структуры, интерфейсы или пустые интерфейсы (interface{}).</li><li>Слайс не может быть сравнен с другим слайсом с помощью оператора ==, только с nil. Для сравнения двух слайсов нужно использовать цикл или функцию reflect.DeepEqual.</li><li>Слайс не может быть использован в качестве ключа мапы, так как он не является хешируемым типом. Для использования слайса в качестве ключа мапы нужно преобразовать его в строку или другой хешируемый тип.</li><li>Слайс не может быть константой, так как он является ссылочным типом. Для объявления слайса нужно использовать var, := или make.</li><li>Слайс не может быть безопасно передан в функцию или возвращен из функции, так как он ссылается на массив, который может быть изменен в другом месте. Для безопасной передачи или возврата слайса нужно копировать его элементы в новый слайс с помощью функции copy или среза [:].</li></ul><h2 id="С-какой-скоростью-идет-поиск-в-массиве-и-почему"><a href="#С-какой-скоростью-идет-поиск-в-массиве-и-почему" class="headerlink" title="С какой скоростью идет поиск в массиве и почему?"></a>С какой скоростью идет поиск в массиве и почему?</h2><p>Самый простой алгоритм поиска в массиве - это линейный поиск, который перебирает все элементы массива по порядку, пока не найдет искомый элемент или не дойдет до конца массива.</p><p>Скорость линейного поиска пропорциональна длине массива, то есть чем больше элементов в массиве, тем дольше будет идти поиск. Сложность линейного поиска в худшем случае составляет O(n), где n - это количество элементов в массиве.</p><h2 id="Какая-есть-функции-для-создания-слайса-с-длиной-отличной-от-нуля"><a href="#Какая-есть-функции-для-создания-слайса-с-длиной-отличной-от-нуля" class="headerlink" title="Какая есть функции для создания слайса с длиной отличной от нуля?"></a>Какая есть функции для создания слайса с длиной отличной от нуля?</h2><p>Для создания слайса с длиной отличной от нуля в golang, можно использовать одну из следующих функций:</p><p>Функция make, которая принимает тип слайса, длину и вместимость, и возвращает слайс с заданными параметрами. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">// создает слайс из трех целых чисел с вместимостью пять</span></span><br></pre></td></tr></table></figure><p>Функция append, которая принимает слайс и один или несколько элементов того же типа, что и слайс, и возвращает новый слайс, содержащий все элементы исходного слайса и добавленные элементы. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;&#125; <span class="comment">// создает пустой слайс</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// добавляет три элемента в слайс</span></span><br></pre></td></tr></table></figure><p>Литерал слайса, который позволяет инициализировать слайс с помощью фигурных скобок и перечисления элементов. Например:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// создает слайс из трех целых чисел</span></span><br></pre></td></tr></table></figure><h2 id="Допустима-ли-конкуррентная-работа-со-слайсом"><a href="#Допустима-ли-конкуррентная-работа-со-слайсом" class="headerlink" title="Допустима ли конкуррентная работа со слайсом?"></a>Допустима ли конкуррентная работа со слайсом?</h2><p>Такая работа может быть допустима, если соблюдены определенные условия и предосторожности:</p><ul><li>Во-первых, конкуррентное чтение слайса не представляет опасности, если никто не пишет в слайс в то же время. То есть, можно безопасно читать слайс из нескольких горутин, если слайс не изменяется.</li><li>Во-вторых, конкуррентная запись в слайс может привести к гонке данных (data race), если не использовать синхронизацию или атомарные операции.</li></ul><p>Для предотвращения гонки данных, можно использовать один из следующих способов:</p><ul><li>Использовать мьютекс sync.Mutex или sync.RWMutex для защиты слайса от одновременного доступа. </li><li>Использовать атомарные операции (sync/atomic) для изменения отдельных элементов слайса.</li><li>Использовать каналы для передачи слайса между горутинами.</li></ul><p><img src="/images/golang_slices.jpg" alt="Вот вам и slices"></p>]]></content>
    
    
    <summary type="html">Вопросы по массивам и слайсам.</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Массивы и слайсы" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%B8-%D1%81%D0%BB%D0%B0%D0%B9%D1%81%D1%8B/"/>
    
    <category term="Массивы и слайсы" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%B8-%D1%81%D0%BB%D0%B0%D0%B9%D1%81%D1%8B/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Дженерики</title>
    <link href="https://goxpert.ru/2024/06/01/common/generics/"/>
    <id>https://goxpert.ru/2024/06/01/common/generics/</id>
    <published>2024-06-01T07:07:00.000Z</published>
    <updated>2024-06-01T17:09:22.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Чем-кодогенерация-отличается-от-дженериков"><a href="#Чем-кодогенерация-отличается-от-дженериков" class="headerlink" title="Чем кодогенерация отличается от дженериков?"></a>Чем кодогенерация отличается от дженериков?</h2><p>Кодогенерация и дженерики - это два способа написания кода, который не зависит от конкретных типов данных. Однако, они отличаются по тому, когда и как происходит привязка к типам.</p><p>Кодогенерация - это процесс создания кода из другого кода или данных с помощью специальных инструментов или команд. Кодогенерация позволяет писать обобщенный код, который затем преобразуется в конкретный код для каждого типа данных. Кодогенерация происходит на этапе компиляции или до него, то есть до выполнения программы. Кодогенерация может быть полезна для увеличения производительности, избежания дублирования кода или реализации сложной логики.</p><p>Дженерики - это способ написания кода, который параметризован по типам данных. Дженерики позволяют писать функции и типы, которые работают с любыми типами данных, передавая их в качестве аргументов. Дженерики происходят на этапе выполнения, то есть во время работы программы. Дженерики могут быть полезны для повышения выразительности, уменьшения количества кода или поддержки полиморфизма.</p><h2 id="В-какой-версии-появились-дженерики"><a href="#В-какой-версии-появились-дженерики" class="headerlink" title="В какой версии появились дженерики?"></a>В какой версии появились дженерики?</h2><p>В языке Go до версии 1.18 не было поддержки дженериков, поэтому разработчики часто использовали кодогенерацию или рефлексию для написания обобщенного кода. </p><p>В версии 1.18 добавлена поддержка дженериков с помощью параметров типов (type parameters), которые позволяют определять функции и типы, которые принимают любые типы данных в качестве аргументов.</p><h2 id="Как-работают-дженерики-под-капотом"><a href="#Как-работают-дженерики-под-капотом" class="headerlink" title="Как работают дженерики под капотом?"></a>Как работают дженерики под капотом?</h2><p>Дженерики под капотом в golang работают с помощью механизма, который называется type substitution (подстановка типов). Это означает, что при компиляции программы, компилятор заменяет параметры типов в дженерических функциях и типах на конкретные типы, которые передаются в качестве аргументов. </p><p>Например, если мы имеем такую дженерическую функцию:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span>[<span class="title">F</span>, <span class="title">T</span> <span class="title">any</span>]<span class="params">(s T, f F)</span> []<span class="title">T</span></span> &#123;</span><br><span class="line">  r := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    r[i] = f(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>И мы вызываем ее так:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> strconv.Itoa(x) &#125;</span><br><span class="line">t := Map(s, f)</span><br></pre></td></tr></table></figure><p>То компилятор преобразует ее в такую функцию:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map_int_string</span><span class="params">(s []<span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">string</span>) []<span class="title">string</span></span> &#123;</span><br><span class="line">  r := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    r[i] = f(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>И вызывает ее так:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> strconv.Itoa(x) &#125;</span><br><span class="line">t := Map_int_string(s, f)</span><br></pre></td></tr></table></figure><pre><code>                                                                          2</code></pre><p>Таким образом, дженерики под капотом в golang не требуют дополнительной памяти или рефлексии, так как они превращаются в обычный код для каждого типа данных. </p><p>Однако, это также означает, что дженерики под капотом в golang могут привести к увеличению размера исполняемого файла, так как для каждого типа данных создается своя версия дженерической функции или типа</p><p>Источники: </p><ul><li><a href="https://habr.com/ru/companies/karuna/articles/552944/">Habr</a></li><li><a href="https://habr.com/ru/companies/skillfactory/articles/657853/">Habr</a></li></ul><p><img src="/images/golang_generics.jpg" alt="Вот вам и дженерик"></p>]]></content>
    
    
    <summary type="html">Вопросы по дженерикам.</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Generics" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Generics/"/>
    
    <category term="Generics" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Generics/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Конструкции</title>
    <link href="https://goxpert.ru/2024/06/01/common/constructions/"/>
    <id>https://goxpert.ru/2024/06/01/common/constructions/</id>
    <published>2024-06-01T07:06:00.000Z</published>
    <updated>2024-06-01T17:08:54.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Гарантирует-ли-порядок-выполнения-конструкция-select-case"><a href="#Гарантирует-ли-порядок-выполнения-конструкция-select-case" class="headerlink" title="Гарантирует ли порядок выполнения конструкция select-case?"></a>Гарантирует ли порядок выполнения конструкция select-case?</h2><p>В Go, порядок выполнения операторов в конструкции select-case не гарантируется.</p><p>Когда у вас есть несколько операторов case в конструкции select, и они все готовы для выполнения (то есть каналы готовы для чтения/записи), Go выбирает один из них случайным образом.</p><p>Это означает, что вы не можете предсказать или контролировать, какой оператор case будет выполнен первым, если у вас есть несколько готовых для выполнения операторов case. Это помогает предотвратить блокировку и гарантировать, что все горутины имеют равные шансы на выполнение.</p><p>Источники: </p><ul><li><a href="https://advicemama.ru/primenenie-operatora-select-v-yazyke-golang-osnovnye-principy-i-sposoby-ispolzovaniya/">Advicemama</a></li></ul><h2 id="Как-выглядит-конструкция-утверждения-типа-switch"><a href="#Как-выглядит-конструкция-утверждения-типа-switch" class="headerlink" title="Как выглядит конструкция утверждения типа switch?"></a>Как выглядит конструкция утверждения типа switch?</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> Type2:</span><br><span class="line"><span class="keyword">case</span> SomeType:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Нужно-ли-в-switch-case-проставлять-break"><a href="#Нужно-ли-в-switch-case-проставлять-break" class="headerlink" title="Нужно ли в switch-case проставлять break?"></a>Нужно ли в switch-case проставлять break?</h2><p>В языке программирования Go, вам не нужно использовать break в конструкции switch-case. В отличие от некоторых других языков программирования, таких как C++ или Java, каждый case в Go автоматически прерывается, и выполнение программы продолжается после конструкции switch-case. Это означает, что после каждого case не нужно явно указывать break.</p><p>Однако, если вы хотите, чтобы выполнение продолжилось и в следующем case, вы можете использовать ключевое слово fallthrough.</p><p>Надеюсь, это помогло вам лучше понять, как работает конструкция switch-case в Go! Если у вас есть еще вопросы, не стесняйтесь задавать.</p><p><img src="/images/golang_constructions.jpg" alt="Вот вам и конструкции"></p>]]></content>
    
    
    <summary type="html">Вопросы по конструкциям языка select-case, switch</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Select-case" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Select-case/"/>
    
    <category term="Select-case" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Select-case/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Ошибки / Panic</title>
    <link href="https://goxpert.ru/2024/06/01/common/errors-panics/"/>
    <id>https://goxpert.ru/2024/06/01/common/errors-panics/</id>
    <published>2024-06-01T07:05:00.000Z</published>
    <updated>2024-06-01T17:08:04.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-паника"><a href="#Что-такое-паника" class="headerlink" title="Что такое паника?"></a>Что такое паника?</h2><p>Паника в программировании на Go обозначает серьезную ошибку, которая обычно приводит к немедленному завершению программы. Паника вызывает немедленное прекращение выполнения функции и начинает раскрутку стека Вы можете использовать функции defer и recover для перехвата и обработки паники.</p><h2 id="Что-используется-для-обработки-паники-Куда-нужно-помещать-recover"><a href="#Что-используется-для-обработки-паники-Куда-нужно-помещать-recover" class="headerlink" title="Что используется для обработки паники / Куда нужно помещать recover??"></a>Что используется для обработки паники / Куда нужно помещать recover??</h2><p>В Go для обработки паники используются функции <code>defer</code> и <code>recover</code>:</p><ul><li>Defer: Функция <code>defer</code> в Go позволяет отложить выполнение функции до того, как окружающая функция завершит свое выполнение. Это полезно для обработки ошибок и очистки ресурсов.</li><li>Recover: Функция <code>recover</code> используется для перехвата и обработки паник. Она должна вызываться внутри отложенной функции.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered from&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// Код, который может вызвать панику</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Какая-парадигма-в-Golang-с-точки-зрения-обработки-исключений-и-ошибок"><a href="#Какая-парадигма-в-Golang-с-точки-зрения-обработки-исключений-и-ошибок" class="headerlink" title="Какая парадигма в Golang с точки зрения обработки исключений и ошибок?"></a>Какая парадигма в Golang с точки зрения обработки исключений и ошибок?</h2><ul><li><p>Явная обработка ошибок: В Go ошибки считаются обычной частью работы программы и должны быть явно обработаны. Если функция может вызвать ошибку, она обычно возвращает значение ошибки в качестве одного из своих возвращаемых значений.</p></li><li><p>Нет исключений: В отличие от некоторых других языков, в Go нет встроенной поддержки исключений. Вместо этого функции возвращают ошибки, которые затем проверяются и обрабатываются.</p></li><li><p>Panic и recover: Go предоставляет функции <code>panic</code> и <code>recover</code> для обработки серьезных ошибок, которые обычно приводят к завершению программы. Однако эти функции обычно используются только в случае критических ошибок, и их использование для обычной обработки ошибок не рекомендуется.</p></li><li><p>Defer: Go также предоставляет ключевое слово <code>defer</code>, которое позволяет отложить выполнение функции до того, как окружающая функция завершит свое выполнение. Это полезно для обработки ошибок и очистки ресурсов.</p></li></ul><h2 id="Какие-есть-функции-для-оборачивания-и-сравнения-ошибок"><a href="#Какие-есть-функции-для-оборачивания-и-сравнения-ошибок" class="headerlink" title="Какие есть функции для оборачивания и сравнения ошибок?"></a>Какие есть функции для оборачивания и сравнения ошибок?</h2><p>В Go есть несколько функций, которые можно использовать для оборачивания и сравнения ошибок:</p><p>Оборачивание ошибок:</p><ul><li><p><code>fmt.Errorf</code>: Эта функция используется для создания новой ошибки, которая включает в себя сообщение об ошибке и другую ошибку в качестве причины. Начиная с Go 1.13, <code>fmt.Errorf</code> поддерживает оборачивание ошибок с помощью нового модификатора формата <code>%w</code>.</p></li><li><p>Сравнение ошибок:</p><ul><li><code>errors.Is</code>: Эта функция используется для проверки, является ли одна ошибка другой ошибкой. Она выполняет проверку на равенство ошибок и учитывает обернутые ошибки.</li><li><code>errors.As</code>: Эта функция используется для проверки, является ли ошибка или обернутая ошибка определенным типом. Если это так, она присваивает эту ошибку указанному значению.<br>Эти функции позволяют более эффективно работать с ошибками в Go, обеспечивая больше информации об ошибках и делая код более читаемым.</li></ul></li></ul><h2 id="Для-чего-используются-ошибки-а-для-чего-паника"><a href="#Для-чего-используются-ошибки-а-для-чего-паника" class="headerlink" title="Для чего используются ошибки, а для чего паника?"></a>Для чего используются ошибки, а для чего паника?</h2><p>В Go ошибки и паника используются для разных целей:</p><p>Ошибки:</p><ul><li>Ошибки в Go обычно используются для обработки ожидаемых проблем, которые могут возникнуть во время выполнения программы.</li><li>Если функция может вызвать ошибку, она обычно возвращает значение ошибки в качестве одного из своих возвращаемых значений.</li><li>Эти ошибки затем проверяются и обрабатываются явно в коде.</li></ul><p>Паника:</p><ul><li>Паника в Go обычно используется для обработки неожиданных ошибок, которые не могут быть обработаны или которые должны привести к немедленному завершению программы.</li><li>Паника вызывает немедленное прекращение выполнения функции и начинает раскрутку стека.</li><li>Вы можете использовать функции <code>defer</code> и <code>recover</code> для перехвата и обработки паники.</li><li>Важно отметить, что хотя паника может казаться похожей на исключения в некоторых других языках, в Go предпочитают явную обработку ошибок, и паника обычно используется только в случае серьезных ошибок.</li></ul><p><img src="/images/golang_panic.jpg" alt="Вот вам и паника!"></p>]]></content>
    
    
    <summary type="html">Вопросы по ошибкам и паникам</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Panic" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Panic/"/>
    
    <category term="Panic" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Panic/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Defer</title>
    <link href="https://goxpert.ru/2024/06/01/common/defer/"/>
    <id>https://goxpert.ru/2024/06/01/common/defer/</id>
    <published>2024-06-01T07:04:00.000Z</published>
    <updated>2024-06-01T17:07:32.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-defer-как-работает-зачем-нужен"><a href="#Что-такое-defer-как-работает-зачем-нужен" class="headerlink" title="Что такое defer, как работает, зачем нужен?"></a>Что такое defer, как работает, зачем нужен?</h2><p>defer - это ключевое слово в языке программирования Go, которое используется для определения функции, которая должна быть выполнена после возвращения текущей функции, но до возвращения вызвавшей ее функции. Это позволяет очистить ресурсы или выполнить другие задачи, которые необходимо выполнить после завершения основной работы функции.</p><p>Когда вызывается функция с ключевым словом defer, она не выполняется немедленно. Вместо этого она добавляется в список функций, которые будут выполняться в обратном порядке после возвращения текущей функции. Это означает, что последняя функция, вызванная с ключевым словом defer, будет выполнена первой после возврата текущей функции.</p><p>Ключевое слово defer полезно для обеспечения правильной очистки ресурсов, например, для закрытия файлов или сетевых соединений. Его также можно использовать для упрощения обработки ошибок, позволяя функции возвращать значение ошибки, а затем обрабатывать эту ошибку в одном месте после возврата функции.</p><p>Источники: </p><ul><li><a href="https://habr.com/ru/articles/492948/">Habr</a></li><li><a href="https://www.digitalocean.com/community/tutorials/understanding-defer-in-go-ru">DigitalOcean</a></li></ul><h2 id="Код-в-defer-выполняется-до-return-или-после"><a href="#Код-в-defer-выполняется-до-return-или-после" class="headerlink" title="Код в defer выполняется до return или после?"></a>Код в defer выполняется до return или после?</h2><p>Оператор defer в Go выполняется перед оператором return. Это позволяет удобно управлять ресурсами, такими как закрытие файлов или освобождение памяти, перед тем как функция завершится. </p><p>defer выполняется после того, как оператор return вычислит возвращаемые значения, но перед фактическим возвращением управления из функции.</p><p>Пример:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(changePointer())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Third&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changePointer</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;First&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Fourth&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Где-инициализируется-defer-в-стеке-или-куче"><a href="#Где-инициализируется-defer-в-стеке-или-куче" class="headerlink" title="Где инициализируется defer, в стеке или куче?"></a>Где инициализируется defer, в стеке или куче?</h2><p>Дефер-вызовы в Go инициализируются в стеке, а не в куче. Когда функция, содержащая дефер-вызовы, начинает выполняться, эти вызовы помещаются в стек. Затем, когда функция завершается, стек разворачивается, и дефер-вызовы выполняются в обратном порядке, в котором они были помещены в стек. Это позволяет гарантировать, что ресурсы, такие как файлы или соединения, будут освобождены в правильном порядке, даже если в функции произойдет ошибка.</p><h2 id="Задача-1"><a href="#Задача-1" class="headerlink" title="Задача #1"></a>Задача #1</h2><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tmp := <span class="number">101</span></span><br><span class="line">fmt.Println(tmp)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(tmp)</span><br><span class="line">&#125;()</span><br><span class="line">tmp = <span class="number">202</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Этот код использует концепцию “замыкания”. Замыкание - это функция, которая имеет доступ к переменным из своего внешнего контекста.<br>В данном случае, анонимная функция, которая откладывается с помощью defer, имеет доступ к переменной tmp из внешнего контекста.</p><p>Когда вы вызываете <code>defer func() &#123; fmt.Println(tmp) &#125;()</code>, функция “захватывает” текущее значение tmp на момент вызова. </p><p>Однако в этом случае tmp является ссылкой на переменную во внешнем контексте. Это значит, что если tmp изменяется после вызова defer, то измененное значение будет использоваться в отложенной функции.</p><p>tmp сначала устанавливается в 101, затем выводится, затем откладывается функция, которая выводит tmp, и наконец tmp изменяется на 202.<br>Когда функция main завершается, отложенная функция вызывается и выводит текущее значение tmp, которое теперь равно 202.<br>В результате, вывод программы будет 101 и 202.</p><h2 id="Задача-2"><a href="#Задача-2" class="headerlink" title="Задача #2"></a>Задача #2</h2><figure class="highlight go"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tmp := <span class="number">101</span></span><br><span class="line">fmt.Println(tmp)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(tmpx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(tmpx)</span><br><span class="line">&#125;(tmp)</span><br><span class="line">tmp = <span class="number">202</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере мы передаем tmp в отложенную функцию как аргумент. Это означает, что значение tmp будет скопировано в отложенную функцию, а не ссылаться на переменную во внешнем контексте.</p><p>В результате, вывод программы будет 101 и 101.</p><p><img src="/images/golang_defer.jpg" alt="Вот вам и defer"></p>]]></content>
    
    
    <summary type="html">Вопросы по работе с defer в Golang</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Defer" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/Defer/"/>
    
    <category term="Defer" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/Defer/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://goxpert.ru/2024/06/01/grpc/grpc/"/>
    <id>https://goxpert.ru/2024/06/01/grpc/grpc/</id>
    <published>2024-06-01T07:04:00.000Z</published>
    <updated>2024-10-11T14:30:16.564Z</updated>
    
    <content type="html"><![CDATA[<p>$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</p>]]></content>
    
    
    <summary type="html">Сортировка за константное время</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="GRPC" scheme="https://goxpert.ru/categories/Golang/GRPC/"/>
    
    <category term="Sort" scheme="https://goxpert.ru/categories/Golang/GRPC/Sort/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://goxpert.ru/2024/06/01/algorithms/sort/constsort/"/>
    <id>https://goxpert.ru/2024/06/01/algorithms/sort/constsort/</id>
    <published>2024-06-01T07:04:00.000Z</published>
    <updated>2024-10-11T14:25:24.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Сортировка-за-константное-время"><a href="#Сортировка-за-константное-время" class="headerlink" title="Сортировка за константное время"></a>Сортировка за константное время</h2><p>Такой вопрос я задал одному из наших Российских AI-ассистент разработчика, который ускоряет создание ПО<br>ответ был такой:</p><p>Вот пример кода на Golang для сортировки подсчетом:</p><p>package main</p><p>import (<br>    “fmt”<br>)</p><p>// countingSort сортирует массив с использованием алгоритма сортировки подсчетом.<br>func countingSort(arr []int) {<br>    minValue := arr[0]<br>    maxValue := arr[len(arr)-1]<br>    count := make([]int, maxValue-minValue+1)</p><pre><code>for _, num := range arr &#123;    count[num-minValue]++&#125;for i := 1; i &lt; len(count); i++ &#123;    count[i] += count[i-1]&#125;index := 0for _, num := range arr &#123;    for count[num-minValue] &gt; 0 &#123;        arr[index] = num        index++        count[num-minValue]--    &#125;&#125;</code></pre><p>}</p><p>func main() {<br>    inputArray := []int{5, 2, 3, 4, 1, 6, 7, 8, 9}<br>    sortedArray := make([]int, len(inputArray))</p><pre><code>copy(sortedArray, inputArray) // Копируем исходный массив в новый для сохранения результатовcountingSort(sortedArray)for _, num := range sortedArray &#123;    fmt.Printf(&quot;%d &quot;, num)&#125;fmt.Println()</code></pre><p>}</p><p>Этот код сначала определяет минимальное и максимальное значения в массиве, затем создает массив count, который будет использоваться для подсчета количества каждого элемента. После этого он проходит по массиву и увеличивает счетчик для каждого элемента. Затем он проходит по счетчику и добавляет к нему предыдущее значение, чтобы определить индекс для каждого элемента после сортировки. В конце он проходит по массиву и заменяет элементы на их индексы.</p><p>Далее я задал вопрос: Что делает данных код, подробней можешь описать?</p><p>Этот код выполняет сортировку подсчетом на слайсе arr.<br>Алгоритм сортировки подсчетом заключается в следующем:</p><ol><li>Подсчитываем количество каждого элемента в массиве. Для этого мы используем счетчики count.</li><li>Используем эти подсчеты для определения индекса каждого элемента после сортировки. Мы создаем массив count и заполняем его нулями. Затем проходим по каждому элементу массива и увеличиваем счетчик для соответствующего элемента.</li><li>После того как мы подсчитали количество каждого элемента, мы проходим по счетчикам и добавляем к ним предыдущее значение, чтобы определить индекс для каждого элемента после сортировки.</li><li>Наконец, мы проходим по массиву и заменяем каждый элемент на его индекс.</li><li>В результате мы получаем отсортированный массив.</li></ol><p>Следующим вопросом был: Какая сложность данного алгоритма в нотации O?</p><p>Сложность алгоритма сортировки подсчетом в нотации O равна O(n). Это означает, что время выполнения алгоритма пропорционально количеству элементов в массиве.</p><p>Далее я спросил: А есть более быстрые алгоритмы сортировки?</p><p>Да, есть более быстрые алгоритмы сортировки. Например, сортировка выбором (selection sort), которая имеет сложность O(n^2), или сортировка вставками (insertion sort), которая имеет сложность O(n^2) для массивов с неравномерным распределением элементов. Однако, если распределение элементов близко к равномерному, то сортировка подсчетом может быть быстрее.</p><p>Но на самом деле не стоит спрашивать у AI-ассистента разработчика, а лучше разобраться самому.<br>Поехали….</p><p><a href="https://habr.com/ru/articles/335920/">https://habr.com/ru/articles/335920/</a></p><h1 id="Вступление"><a href="#Вступление" class="headerlink" title="Вступление"></a>Вступление</h1><p>На эту тему написано уже немало статей. Однако я еще не видел статьи, в которой сравниваются все основные сортировки на большом числе тестов разного типа и размера. Кроме того, далеко не везде выложены реализации и описание набора тестов. Это приводит к тому, что могут возникнуть сомнения в правильности исследования. Однако цель моей работы состоит не только в том, чтобы определить, какие сортировки работают быстрее всего (в целом это и так известно). В первую очередь мне было интересно исследовать алгоритмы, оптимизировать их, чтобы они работали как можно быстрее. Работая над этим, мне удалось придумать эффективную формулу для сортировки Шелла.</p><p>Во многом статья посвящена тому, как написать все алгоритмы и протестировать их. Если говорить о самом программировании, то иногда могут возникнуть совершенно неожиданные трудности (во многом благодаря оптимизатору C++). Однако не менее трудно решить, какие именно тесты и в каких количествах нужно сделать. Коды всех алгоритмов, которые выложены в данной статье, написаны мной. Доступны и результаты запусков на всех тестах. Единственное, что я не могу показать — это сами тесты, поскольку они весят почти 140 ГБ. При малейшем подозрении я проверял и код, соответствующий тесту, и сам тест. Надеюсь, что статья Вам понравится.</p><p>Описание основных сортировок и их реализация</p><p>Я постараюсь кратко и понятно описать сортировки и указать асимптотику, хотя последнее в рамках данной статьи не очень важно (интересно же узнать реальное время работы). О потреблении памяти в дальнейшем ничего писать не буду, замечу только, что сортировки, использующие непростые структуры данных (как, например, сортировка деревом), обычно потребляют ее в больших количествах, а остальные сортировки в худшем случае только создают вспомогательный массив. Также существует понятие стабильности (устойчивости) сортировки. Это значит, что относительный порядок элементов при их равенстве не меняется. Это тоже в рамках данной статьи неважно (в конце концов, можно просто прицепить к элементу его индекс), однако в одном месте пригодится.</p><p>Сортировка пузырьком / Bubble sort</p><p>Будем идти по массиву слева направо. Если текущий элемент больше следующего, меняем их местами. Делаем так, пока массив не будет отсортирован. Заметим, что после первой итерации самый большой элемент будет находиться в конце массива, на правильном месте. После двух итераций на правильном месте будут стоять два наибольших элемента, и так далее. Очевидно, не более чем после n итераций массив будет отсортирован. Таким образом, асимптотика в худшем и среднем случае – O(n2), в лучшем случае – O(n).</p><p>Реализация:<br>void bubblesort(int* l, int* r) {<br>    int sz = r - l;<br>    if (sz &lt;= 1) return;<br>    bool b = true;<br>    while (b) {<br>        b = false;<br>        for (int* i = l; i + 1 &lt; r; i++) {<br>            if (*i &gt; *(i + 1)) {<br>                swap(*i, *(i + 1));<br>                b = true;<br>            }<br>        }<br>        r–;<br>    }<br>}</p><p>Шейкерная сортировка / Shaker sort</p><p>(также известна как сортировка перемешиванием и коктейльная сортировка). Заметим, что сортировка пузырьком работает медленно на тестах, в которых маленькие элементы стоят в конце (их еще называют «черепахами»). Такой элемент на каждом шаге алгоритма будет сдвигаться всего на одну позицию влево. Поэтому будем идти не только слева направо, но и справа налево. Будем поддерживать два указателя begin и end, обозначающих, какой отрезок массива еще не отсортирован. На очередной итерации при достижении end вычитаем из него единицу и движемся справа налево, аналогично, при достижении begin прибавляем единицу и двигаемся слева направо. Асимптотика у алгоритма такая же, как и у сортировки пузырьком, однако реальное время работы лучше.</p><p>Реализация:<br>void shakersort(int* l, int* r) {<br>    int sz = r - l;<br>    if (sz &lt;= 1) return;<br>    bool b = true;<br>    int* beg = l - 1;<br>    int* end = r - 1;<br>    while (b) {<br>        b = false;<br>        beg++;<br>        for (int* i = beg; i &lt; end; i++) {<br>            if (*i &gt; *(i + 1)) {<br>                swap(*i, <em>(i + 1));<br>                b = true;<br>            }<br>        }<br>        if (!b) break;<br>        end–;<br>        for (int</em> i = end; i &gt; beg; i–) {<br>            if (*i &lt; *(i - 1)) {<br>                swap(*i, *(i - 1));<br>                b = true;<br>            }<br>        }<br>    }<br>}</p><p>Сортировка расческой / Comb sort</p><p>Еще одна модификация сортировки пузырьком. Для того, чтобы избавиться от «черепах», будем переставлять элементы, стоящие на расстоянии. Зафиксируем его и будем идти слева направо, сравнивая элементы, стоящие на этом расстоянии, переставляя их, если необходимо. Очевидно, это позволит «черепахам» быстро добраться в начало массива. Оптимально изначально взять расстояние равным длине массива, а далее делить его на некоторый коэффициент, равный примерно 1.247. Когда расстояние станет равно единице, выполняется сортировка пузырьком. В лучшем случае асимптотика равна O(nlogn), в худшем – O(n2). Какая асимптотика в среднем мне не очень понятно, на практике похоже на O(nlogn).</p><p>Реализация:<br>void combsort(int* l, int* r) {<br>    int sz = r - l;<br>    if (sz &lt;= 1) return;<br>    double k = 1.2473309;<br>    int step = sz - 1;<br>    while (step &gt; 1) {<br>        for (int* i = l; i + step &lt; r; i++) {<br>            if (*i &gt; *(i + step))<br>                swap(*i, <em>(i + step));<br>        }<br>        step /= k;<br>    }<br>    bool b = true;<br>    while (b) {<br>        b = false;<br>        for (int</em> i = l; i + 1 &lt; r; i++) {<br>            if (*i &gt; *(i + 1)) {<br>                swap(*i, *(i + 1));<br>                b = true;<br>            }<br>        }<br>    }<br>}</p><p>Об этих сортировках (пузырьком, шейкерной и расческой) также можно почитать здесь.</p><p>Сортировка вставками / Insertion sort</p><p>Создадим массив, в котором после завершения алгоритма будет лежать ответ. Будем поочередно вставлять элементы из исходного массива так, чтобы элементы в массиве-ответе всегда были отсортированы. Асимптотика в среднем и худшем случае – O(n2), в лучшем – O(n). Реализовывать алгоритм удобнее по-другому (создавать новый массив и реально что-то вставлять в него относительно сложно): просто сделаем так, чтобы отсортирован был некоторый префикс исходного массива, вместо вставки будем менять текущий элемент с предыдущим, пока они стоят в неправильном порядке.</p><p>Реализация:<br>void insertionsort(int* l, int* r) {<br>    for (int *i = l + 1; i &lt; r; i++) {<br>        int* j = i;<br>        while (j &gt; l &amp;&amp; *(j - 1) &gt; <em>j) {<br>            swap(</em>(j - 1), *j);<br>            j–;<br>        }<br>    }<br>}</p><p>Сортировка Шелла / Shellsort</p><p>Используем ту же идею, что и сортировка с расческой, и применим к сортировке вставками. Зафиксируем некоторое расстояние. Тогда элементы массива разобьются на классы – в один класс попадают элементы, расстояние между которыми кратно зафиксированному расстоянию. Отсортируем сортировкой вставками каждый класс. В отличие от сортировки расческой, неизвестен оптимальный набор расстояний. Существует довольно много последовательностей с разными оценками. Последовательность Шелла – первый элемент равен длине массива, каждый следующий вдвое меньше предыдущего. Асимптотика в худшем случае – O(n2). Последовательность Хиббарда – 2n — 1, асимптотика в худшем случае – O(n1,5), последовательность Седжвика (формула нетривиальна, можете ее посмотреть по ссылке ниже) — O(n4/3), Пратта (все произведения степеней двойки и тройки) — O(nlog2n). Отмечу, что все эти последовательности нужно рассчитать только до размера массива и запускать от большего от меньшему (иначе получится просто сортировка вставками). Также я провел дополнительное исследование и протестировал разные последовательности вида si = a * si — 1 + k * si — 1 (отчасти это было навеяно эмпирической последовательностью Циура – одной из лучших последовательностей расстояний для небольшого количества элементов). Наилучшими оказались последовательности с коэффициентами a = 3, k = 1/3; a = 4, k = 1/4 и a = 4, k = -1/5.</p><p>Несколько полезных ссылок:</p><p>Сортировка Шелла в русскоязычной Википедии<br>Сортировка Шелла в англоязычной Википедии<br>Статья на Хабре</p><p>Реализации:<br>void shellsort(int* l, int* r) {<br>    int sz = r - l;<br>    int step = sz / 2;<br>    while (step &gt;= 1) {<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>        step /= 2;<br>    }<br>}<br>void shellsorthib(int</em> l, int</em> r) {<br>    int sz = r - l;<br>    if (sz &lt;= 1) return;<br>    int step = 1;<br>    while (step &lt; sz) step &lt;&lt;= 1;<br>    step &gt;&gt;= 1;<br>    step–;<br>    while (step &gt;= 1) {<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>        step /= 2;<br>    }<br>}<br>int steps[100];<br>void shellsortsedgwick(int</em> l, int</em> r) {<br>    int sz = r - l;<br>    steps[0] = 1;<br>    int q = 1;<br>    while (steps[q - 1] * 3 &lt; sz) {<br>        if (q % 2 == 0)<br>            steps[q] = 9 * (1 &lt;&lt; q) - 9 * (1 &lt;&lt; (q / 2)) + 1;<br>        else<br>            steps[q] = 8 * (1 &lt;&lt; q) - 6 * (1 &lt;&lt; ((q + 1) / 2)) + 1;<br>        q++;<br>    }<br>    q–;<br>    for (; q &gt;= 0; q–) {<br>        int step = steps[q];<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>    }<br>}<br>void shellsortpratt(int</em> l, int</em> r) {<br>    int sz = r - l;<br>    steps[0] = 1;<br>    int cur = 1, q = 1;<br>    for (int i = 1; i &lt; sz; i++) {<br>        int cur = 1 &lt;&lt; i;<br>        if (cur &gt; sz / 2) break;<br>        for (int j = 1; j &lt; sz; j++) {<br>            cur *= 3;<br>            if (cur &gt; sz / 2) break;<br>            steps[q++] = cur;<br>        }<br>    }<br>    insertionsort(steps, steps + q);<br>    q–;<br>    for (; q &gt;= 0; q–) {<br>        int step = steps[q];<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>    }<br>}<br>void myshell1(int</em> l, int</em> r) {<br>    int sz = r - l, q = 1;<br>    steps[0] = 1;<br>    while (steps[q - 1] &lt; sz) {<br>        int s = steps[q - 1];<br>        steps[q++] = s * 4 + s / 4;<br>    }<br>    q–;<br>    for (; q &gt;= 0; q–) {<br>        int step = steps[q];<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>    }<br>}<br>void myshell2(int</em> l, int</em> r) {<br>    int sz = r - l, q = 1;<br>    steps[0] = 1;<br>    while (steps[q - 1] &lt; sz) {<br>        int s = steps[q - 1];<br>        steps[q++] = s * 3 + s / 3;<br>    }<br>    q–;<br>    for (; q &gt;= 0; q–) {<br>        int step = steps[q];<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(<em>diff, <em>j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>    }<br>}<br>void myshell3(int</em> l, int</em> r) {<br>    int sz = r - l, q = 1;<br>    steps[0] = 1;<br>    while (steps[q - 1] &lt; sz) {<br>        int s = steps[q - 1];<br>        steps[q++] = s * 4 - s / 5;<br>    }<br>    q–;<br>    for (; q &gt;= 0; q–) {<br>        int step = steps[q];<br>        for (int *i = l + step; i &lt; r; i++) {<br>            int *j = i;<br>            int *diff = j - step;<br>            while (diff &gt;= l &amp;&amp; *diff &gt; *j) {<br>                swap(*diff, *j);<br>                j = diff;<br>                diff = j - step;<br>            }<br>        }<br>    }<br>}</p><p>Сортировка деревом / Tree sort</p><p>Будем вставлять элементы в двоичное дерево поиска. После того, как все элементы вставлены достаточно обойти дерево в глубину и получить отсортированный массив. Если использовать сбалансированное дерево, например красно-черное, асимптотика будет равна O(nlogn) в худшем, среднем и лучшем случае. В реализации использован контейнер multiset.</p><p>Здесь можно почитать про деревья поиска:</p><p>Википедия<br>Статья на Хабре<br>И ещё статья на Хабре</p><p>Реализация:<br>void treesort(int* l, int* r) {<br>    multiset<int> m;<br>    for (int *i = l; i &lt; r; i++)<br>        m.insert(*i);<br>    for (int q : m)<br>        *l = q, l++;<br>}</p><p>Гномья сортировка / Gnome sort</p><p>Алгоритм похож на сортировку вставками. Поддерживаем указатель на текущий элемент, если он больше предыдущего или он первый — смещаем указатель на позицию вправо, иначе меняем текущий и предыдущий элементы местами и смещаемся влево.</p><p>Реализация:<br>void gnomesort(int* l, int* r) {<br>    int *i = l;<br>    while (i &lt; r) {<br>        if (i == l || *(i - 1) &lt;= <em>i) i++;<br>        else swap(</em>(i - 1), *i), i–;<br>    }<br>}</p><p>Сортировка выбором / Selection sort</p><p>На очередной итерации будем находить минимум в массиве после текущего элемента и менять его с ним, если надо. Таким образом, после i-ой итерации первые i элементов будут стоять на своих местах. Асимптотика: O(n2) в лучшем, среднем и худшем случае. Нужно отметить, что эту сортировку можно реализовать двумя способами – сохраняя минимум и его индекс или просто переставляя текущий элемент с рассматриваемым, если они стоят в неправильном порядке. Первый способ оказался немного быстрее, поэтому он и реализован.</p><p>Реализация:<br>void selectionsort(int* l, int* r) {<br>    for (int *i = l; i &lt; r; i++) {<br>        int minz = *i, *ind = i;<br>        for (int *j = i + 1; j &lt; r; j++) {<br>            if (*j &lt; minz) minz = *j, ind = j;<br>        }<br>        swap(*i, *ind);<br>    }<br>}</p><p>Пирамидальная сортировка / Heapsort</p><p>Развитие идеи сортировки выбором. Воспользуемся структурой данных «куча» (или «пирамида», откуда и название алгоритма). Она позволяет получать минимум за O(1), добавляя элементы и извлекая минимум за O(logn). Таким образом, асимптотика O(nlogn) в худшем, среднем и лучшем случае. Реализовывал кучу я сам, хотя в С++ и есть контейнер priority_queue, поскольку этот контейнер довольно медленный.</p><p>Почитать про кучу можно здесь:</p><p>Википедия<br>Статья на Хабре</p><p>Реализация:<br>template <class T><br>class heap {<br>public:<br>    int size() {<br>        return n;<br>    }<br>    int top() {<br>        return h[0];<br>    }<br>    bool empty() {<br>        return n == 0;<br>    }<br>    void push(T a) {<br>        h.push_back(a);<br>        SiftUp(n);<br>        n++;<br>    }<br>    void pop() {<br>        n–;<br>        swap(h[n], h[0]);<br>        h.pop_back();<br>        SiftDown(0);<br>    }<br>    void clear() {<br>        h.clear();<br>        n = 0;<br>    }<br>    T operator [] (int a) {<br>        return h[a];<br>    }<br>private:<br>    vector<T> h;<br>    int n = 0;<br>    void SiftUp(int a) {<br>        while (a) {<br>            int p = (a - 1) / 2;<br>            if (h[p] &gt; h[a]) swap(h[p], h[a]);<br>            else break;<br>            a–; a /= 2;<br>        }<br>    }<br>    void SiftDown(int a) {<br>        while (2 * a + 1 &lt; n) {<br>            int l = 2 * a + 1, r = 2 * a + 2;<br>            if (r == n) {<br>                if (h[l] &lt; h[a]) swap(h[l], h[a]);<br>                break;<br>            }<br>            else if (h[l] &lt;= h[r]) {<br>                if (h[l] &lt; h[a]) {<br>                    swap(h[l], h[a]);<br>                    a = l;<br>                }<br>                else break;<br>            }<br>            else if (h[r] &lt; h[a]) {<br>                swap(h[r], h[a]);<br>                a = r;<br>            }<br>            else break;<br>        }<br>    }<br>};<br>void heapsort(int* l, int* r) {<br>    heap<int> h;<br>    for (int *i = l; i &lt; r; i++) h.push(*i);<br>    for (int *i = l; i &lt; r; i++) {<br>        *i = h.top();<br>        h.pop();<br>    }<br>}</p><p>Быстрая сортировка / Quicksort</p><p>Выберем некоторый опорный элемент. После этого перекинем все элементы, меньшие его, налево, а большие – направо. Рекурсивно вызовемся от каждой из частей. В итоге получим отсортированный массив, так как каждый элемент меньше опорного стоял раньше каждого большего опорного. Асимптотика: O(nlogn) в среднем и лучшем случае, O(n2). Наихудшая оценка достигается при неудачном выборе опорного элемента. Моя реализация этого алгоритма совершенно стандартна, идем одновременно слева и справа, находим пару элементов, таких, что левый элемент больше опорного, а правый меньше, и меняем их местами. Помимо чистой быстрой сортировки, участвовала в сравнении и сортировка, переходящая при малом количестве элементов на сортировку вставками. Константа подобрана тестированием, а сортировка вставками — наилучшая сортировка, подходящая для этой задачи (хотя не стоит из-за этого думать, что она самая быстрая из квадратичных).</p><p>Реализация:<br>void quicksort(int* l, int* r) {<br>    if (r - l &lt;= 1) return;<br>    int z = *(l + (r - l) / 2);<br>    int* ll = l, *rr = r - 1;<br>    while (ll &lt;= rr) {<br>        while (*ll &lt; z) ll++;<br>        while (*rr &gt; z) rr–;<br>        if (ll &lt;= rr) {<br>            swap(*ll, *rr);<br>            ll++;<br>            rr–;<br>        }<br>    }<br>    if (l &lt; rr) quicksort(l, rr + 1);<br>    if (ll &lt; r) quicksort(ll, r);<br>}<br>void quickinssort(int* l, int* r) {<br>    if (r - l &lt;= 32) {<br>        insertionsort(l, r);<br>        return;<br>    }<br>    int z = *(l + (r - l) / 2);<br>    int* ll = l, *rr = r - 1;<br>    while (ll &lt;= rr) {<br>        while (*ll &lt; z) ll++;<br>        while (*rr &gt; z) rr–;<br>        if (ll &lt;= rr) {<br>            swap(*ll, *rr);<br>            ll++;<br>            rr–;<br>        }<br>    }<br>    if (l &lt; rr) quickinssort(l, rr + 1);<br>    if (ll &lt; r) quickinssort(ll, r);<br>}</p><p>Сортировка слиянием / Merge sort</p><p>Сортировка, основанная на парадигме «разделяй и властвуй». Разделим массив пополам, рекурсивно отсортируем части, после чего выполним процедуру слияния: поддерживаем два указателя, один на текущий элемент первой части, второй – на текущий элемент второй части. Из этих двух элементов выбираем минимальный, вставляем в ответ и сдвигаем указатель, соответствующий минимуму. Слияние работает за O(n), уровней всего logn, поэтому асимптотика O(nlogn). Эффективно заранее создать временный массив и передать его в качестве аргумента функции. Эта сортировка рекурсивна, как и быстрая, а потому возможен переход на квадратичную при небольшом числе элементов.</p><p>Реализация:<br>void merge(int* l, int* m, int* r, int* temp) {<br>    int <em>cl = l, <em>cr = m, cur = 0;<br>    while (cl &lt; m &amp;&amp; cr &lt; r) {<br>        if (<em>cl &lt; <em>cr) temp[cur++] = <em>cl, cl++;<br>        else temp[cur++] = <em>cr, cr++;<br>    }<br>    while (cl &lt; m) temp[cur++] = <em>cl, cl++;<br>    while (cr &lt; r) temp[cur++] = <em>cr, cr++;<br>    cur = 0;<br>    for (int</em> i = l; i &lt; r; i++)<br>         <em>i = temp[cur++];<br>}<br>void _mergesort(int</em> l, int</em> r, int</em> temp) {<br>    if (r - l &lt;= 1) return;<br>    int <em>m = l + (r - l) / 2;<br>    _mergesort(l, m, temp);<br>    _mergesort(m, r, temp);<br>    merge(l, m, r, temp);<br>}<br>void mergesort(int</em> l, int</em> r) {<br>    int</em> temp = new int[r - l];<br>    _mergesort(l, r, temp);<br>    delete temp;<br>}<br>void _mergeinssort(int</em> l, int</em> r, int</em> temp) {<br>    if (r - l &lt;= 32) {<br>        insertionsort(l, r);<br>        return;<br>    }<br>    int <em>m = l + (r - l) / 2;<br>    _mergeinssort(l, m, temp);<br>    _mergeinssort(m, r, temp);<br>    merge(l, m, r, temp);<br>}<br>void mergeinssort(int</em> l, int* r) {<br>    int* temp = new int[r - l];<br>    _mergeinssort(l, r, temp);<br>    delete temp;<br>}</p><p>Сортировка подсчетом / Counting sort</p><p>Создадим массив размера r – l, где l – минимальный, а r – максимальный элемент массива. После этого пройдем по массиву и подсчитаем количество вхождений каждого элемента. Теперь можно пройти по массиву значений и выписать каждое число столько раз, сколько нужно. Асимптотика – O(n + r — l). Можно модифицировать этот алгоритм, чтобы он стал стабильным: для этого определим место, где должно стоять очередное число (это просто префиксные суммы в массиве значений) и будем идти по исходному массиву слева направо, ставя элемент на правильное место и увеличивая позицию на 1. Эта сортировка не тестировалась, поскольку большинство тестов содержало достаточно большие числа, не позволяющие создать массив требуемого размера. Однако она, тем не менее, пригодилась.</p><p>Блочная сортировка / Bucket sort</p><p>(также известна как корзинная и карманная сортировка). Пусть l – минимальный, а r – максимальный элемент массива. Разобьем элементы на блоки, в первом будут элементы от l до l + k, во втором – от l + k до l + 2k и т.д., где k = (r – l) / количество блоков. В общем-то, если количество блоков равно двум, то данный алгоритм превращается в разновидность быстрой сортировки. Асимптотика этого алгоритма неясна, время работы зависит и от входных данных, и от количества блоков. Утверждается, что на удачных данных время работы линейно. Реализация этого алгоритма оказалась одной из самых трудных задач. Можно сделать это так: просто создавать новые массивы, рекурсивно их сортировать и склеивать. Однако такой подход все же довольно медленный и меня не устроил. В эффективной реализации используется несколько идей:</p><ol><li><p>Не будем создавать новых массивов. Для этого воспользуемся техникой сортировки подсчетом – подсчитаем количество элементов в каждом блоке, префиксные суммы и, таким образом, позицию каждого элемента в массиве.</p></li><li><p>Не будем запускаться из пустых блоков. Занесем индексы непустых блоков в отдельный массив и запустимся только от них.</p></li><li><p>Проверим, отсортирован ли массив. Это не ухудшит время работы, так как все равно нужно сделать проход с целью нахождения минимума и максимума, однако позволит алгоритму ускориться на частично отсортированных данных, ведь элементы вставляются в новые блоки в том же порядке, что и в исходном массиве.</p></li><li><p>Поскольку алгоритм получился довольно громоздким, при небольшом количестве элементов он крайне неэффективен. До такой степени, что переход на сортировку вставками ускоряет работу примерно в 10 раз.</p></li></ol><p>Осталось только понять, какое количество блоков нужно выбрать. На рандомизированных тестах мне удалось получить следующую оценку: 1500 блоков для 107 элементов и 3000 для 108. Подобрать формулу не удалось – время работы ухудшалось в несколько раз.</p><p>Реализация:<br>void _newbucketsort(int* l, int* r, int* temp) {<br>    if (r - l &lt;= 64) {<br>        insertionsort(l, r);<br>        return;<br>    }<br>    int minz = *l, maxz = *l;<br>    bool is_sorted = true;<br>    for (int *i = l + 1; i &lt; r; i++) {<br>        minz = min(minz, *i);<br>        maxz = max(maxz, *i);<br>        if (<em>i &lt; <em>(i - 1)) is_sorted = false;<br>    }<br>    if (is_sorted) return;<br>    int diff = maxz - minz + 1;<br>    int numbuckets;<br>    if (r - l &lt;= 1e7) numbuckets = 1500;<br>    else numbuckets = 3000;<br>    int range = (diff + numbuckets - 1) / numbuckets;<br>    int</em> cnt = new int[numbuckets + 1];<br>    for (int i = 0; i &lt;= numbuckets; i++)<br>        cnt[i] = 0;<br>    int cur = 0;<br>    for (int</em> i = l; i &lt; r; i++) {<br>        temp[cur++] = *i;<br>        int ind = (<em>i - minz) / range;<br>        cnt[ind + 1]++;<br>    }<br>    int sz = 0;<br>    for (int i = 1; i &lt;= numbuckets; i++)<br>        if (cnt[i]) sz++;<br>    int</em> run = new int[sz];<br>    cur = 0;<br>    for (int i = 1; i &lt;= numbuckets; i++)<br>        if (cnt[i]) run[cur++] = i - 1;<br>    for (int i = 1; i &lt;= numbuckets; i++)<br>        cnt[i] += cnt[i - 1];<br>    cur = 0;<br>    for (int <em>i = l; i &lt; r; i++) {<br>        int ind = (temp[cur] - minz) / range;<br>        <em>(l + cnt[ind]) = temp[cur];<br>        cur++;<br>        cnt[ind]++;<br>    }<br>    for (int i = 0; i &lt; sz; i++) {<br>        int r = run[i];<br>        if (r != 0) _newbucketsort(l + cnt[r - 1], l + cnt[r], temp);<br>        else _newbucketsort(l, l + cnt[r], temp);<br>    }<br>    delete run;<br>    delete cnt;<br>}<br>void newbucketsort(int</em> l, int</em> r) {<br>    int *temp = new int[r - l];<br>    _newbucketsort(l, r, temp);<br>    delete temp;<br>}</p><p>Поразрядная сортировка / Radix sort</p><p>(также известна как цифровая сортировка). Существует две версии этой сортировки, в которых, на мой взгляд, мало общего, кроме идеи воспользоваться представлением числа в какой-либо системе счисления (например, двоичной).</p><p>LSD (least significant digit):</p><p>Представим каждое число в двоичном виде. На каждом шаге алгоритма будем сортировать числа таким образом, чтобы они были отсортированы по первым k * i битам, где k – некоторая константа. Из данного определения следует, что на каждом шаге достаточно стабильно сортировать элементы по новым k битам. Для этого идеально подходит сортировка подсчетом (необходимо 2k памяти и времени, что немного при удачном выборе константы). Асимптотика: O(n), если считать, что числа фиксированного размера (а в противном случае нельзя было бы считать, что сравнение двух чисел выполняется за единицу времени). Реализация довольно проста.</p><p>Реализация:<br>int digit(int n, int k, int N, int M) {<br>    return (n &gt;&gt; (N * k) &amp; (M - 1));<br>}<br>void _radixsort(int* l, int* r, int N) {<br>    int k = (32 + N - 1) / N;<br>    int M = 1 &lt;&lt; N;<br>    int sz = r - l;<br>    int* b = new int[sz];<br>    int* c = new int[M];<br>    for (int i = 0; i &lt; k; i++) {<br>        for (int j = 0; j &lt; M; j++)<br>            c[j] = 0;<br>        for (int* j = l; j &lt; r; j++)<br>            c[digit(*j, i, N, M)]++;<br>        for (int j = 1; j &lt; M; j++)<br>            c[j] += c[j - 1];<br>        for (int* j = r - 1; j &gt;= l; j–)<br>            b[–c[digit(<em>j, i, N, M)]] = <em>j;<br>        int cur = 0;<br>        for (int</em> j = l; j &lt; r; j++)<br>            <em>j = b[cur++];<br>    }<br>    delete b;<br>    delete c;<br>}<br>void radixsort(int</em> l, int</em> r) {<br>    _radixsort(l, r, 8);<br>}</p><p>MSD (most significant digit):</p><p>На самом деле, некоторая разновидность блочной сортировки. В один блок будут попадать числа с равными k битами. Асимптотика такая же, как и у LSD версии. Реализация очень похожа на блочную сортировку, но проще. В ней используется функция digit, определенная в реализации LSD версии.</p><p>Реализация:<br>void _radixsortmsd(int* l, int* r, int N, int d, int* temp) {<br>    if (d == -1) return;<br>    if (r - l &lt;= 32) {<br>        insertionsort(l, r);<br>        return;<br>    }<br>    int M = 1 &lt;&lt; N;<br>    int* cnt = new int[M + 1];<br>    for (int i = 0; i &lt;= M; i++)<br>        cnt[i] = 0;<br>    int cur = 0;<br>    for (int* i = l; i &lt; r; i++) {<br>        temp[cur++] = <em>i;<br>        cnt[digit(<em>i, d, N, M) + 1]++;<br>    }<br>    int sz = 0;<br>    for (int i = 1; i &lt;= M; i++)<br>        if (cnt[i]) sz++;<br>    int</em> run = new int[sz];<br>    cur = 0;<br>    for (int i = 1; i &lt;= M; i++)<br>        if (cnt[i]) run[cur++] = i - 1;<br>    for (int i = 1; i &lt;= M; i++)<br>        cnt[i] += cnt[i - 1];<br>    cur = 0;<br>    for (int <em>i = l; i &lt; r; i++) {<br>        int ind = digit(temp[cur], d, N, M);<br>        <em>(l + cnt[ind]) = temp[cur];<br>        cur++;<br>        cnt[ind]++;<br>    }<br>    for (int i = 0; i &lt; sz; i++) {<br>        int r = run[i];<br>        if (r != 0) _radixsortmsd(l + cnt[r - 1], l + cnt[r], N, d - 1, temp);<br>        else _radixsortmsd(l, l + cnt[r], N, d - 1, temp);<br>    }<br>    delete run;<br>    delete cnt;<br>}<br>void radixsortmsd(int</em> l, int</em> r) {<br>    int</em> temp = new int[r - l];<br>    _radixsortmsd(l, r, 8, 3, temp);<br>    delete temp;<br>}</p><p>Битонная сортировка / Bitonic sort:</p><p>Идея данного алгоритма заключается в том, что исходный массив преобразуется в битонную последовательность – последовательность, которая сначала возрастает, а потом убывает. Ее можно эффективно отсортировать следующим образом: разобьем массив на две части, создадим два массива, в первый добавим все элементы, равные минимуму из соответственных элементов каждой из двух частей, а во второй – равные максимуму. Утверждается, что получатся две битонные последовательности, каждую из которых можно рекурсивно отсортировать тем же образом, после чего можно склеить два массива (так как любой элемент первого меньше или равен любого элемента второго). Для того, чтобы преобразовать исходный массив в битонную последовательность, сделаем следующее: если массив состоит из двух элементов, можно просто завершиться, иначе разделим массив пополам, рекурсивно вызовем от половинок алгоритм, после чего отсортируем первую часть по порядку, вторую в обратном порядке и склеим. Очевидно, получится битонная последовательность. Асимптотика: O(nlog2n), поскольку при построении битонной последовательности мы использовали сортировку, работающую за O(nlogn), а всего уровней было logn. Также заметим, что размер массива должен быть равен степени двойки, так что, возможно, придется его дополнять фиктивными элементами (что не влияет на асимптотику).</p><p>Реализация:<br>void bitseqsort(int* l, int* r, bool inv) {<br>    if (r - l &lt;= 1) return;<br>    int *m = l + (r - l) / 2;<br>    for (int *i = l, *j = m; i &lt; m &amp;&amp; j &lt; r; i++, j++) {<br>        if (inv ^ (*i &gt; <em>j)) swap(<em>i, <em>j);<br>    }<br>    bitseqsort(l, m, inv);<br>    bitseqsort(m, r, inv);<br>}<br>void makebitonic(int</em> l, int</em> r) {<br>    if (r - l &lt;= 1) return;<br>    int <em>m = l + (r - l) / 2;<br>    makebitonic(l, m);<br>    bitseqsort(l, m, 0);<br>    makebitonic(m, r);<br>    bitseqsort(m, r, 1);<br>}<br>void bitonicsort(int</em> l, int</em> r) {<br>    int n = 1;<br>    int inf = *max_element(l, r) + 1;<br>    while (n &lt; r - l) n <em>= 2;<br>    int</em> a = new int[n];<br>    int cur = 0;<br>    for (int *i = l; i &lt; r; i++)<br>        a[cur++] = *i;<br>    while (cur &lt; n) a[cur++] = inf;<br>    makebitonic(a, a + n);<br>    bitseqsort(a, a + n, 0);<br>    cur = 0;<br>    for (int *i = l; i &lt; r; i++)<br>        *i = a[cur++];<br>    delete a;<br>}</p><p>Timsort</p><p>Гибридная сортировка, совмещающая сортировку вставками и сортировку слиянием. Разобьем элементы массива на несколько подмассивов небольшого размера, при этом будем расширять подмассив, пока элементы в нем отсортированы. Отсортируем подмассивы сортировкой вставками, пользуясь тем, что она эффективно работает на отсортированных массивах. Далее будем сливать подмассивы как в сортировке слиянием, беря их примерно равного размера (иначе время работы приблизится к квадратичному). Для этого удобного хранить подмассивы в стеке, поддерживая инвариант — чем дальше от вершины, тем больше размер, и сливать подмассивы на верхушке только тогда, когда размер третьего по отдаленности от вершины подмассива больше или равен сумме их размеров. Асимптотика: O(n) в лучшем случае и O(nlogn) в среднем и худшем случае. Реализация нетривиальна, твердой уверенности в ней у меня нет, однако время работы она показала довольно неплохое и согласующееся с моими представлениями о том, как должна работать эта сортировка.</p><p>Подробнее timsort описан здесь:</p><p>Здесь<br>Здесь</p><p>Реализация:<br>void _timsort(int* l, int* r, int* temp) {<br>    int sz = r - l;<br>    if (sz &lt;= 64) {<br>        insertionsort(l, r);<br>        return;<br>    }<br>    int minrun = sz, f = 0;<br>    while (minrun &gt;= 64) {<br>        f |= minrun &amp; 1;<br>        minrun &gt;&gt;= 1;<br>    }<br>    minrun += f;<br>    int* cur = l;<br>    stack&lt;pair&lt;int, int*&gt;&gt; s;<br>    while (cur &lt; r) {<br>        int* c1 = cur;<br>        while (c1 &lt; r - 1 &amp;&amp; <em>c1 &lt;= *(c1 + 1)) c1++;<br>        int* c2 = cur;<br>        while (c2 &lt; r - 1 &amp;&amp; *c2 &gt;= <em>(c2 + 1)) c2++;<br>        if (c1 &gt;= c2) {<br>            c1 = max(c1, cur + minrun - 1);<br>            c1 = min(c1, r - 1);<br>            insertionsort(cur, c1 + 1);<br>            s.push({ c1 - cur + 1, cur });<br>            cur = c1 + 1;<br>        }<br>        else {<br>            c2 = max(c2, cur + minrun - 1);<br>            c2 = min(c2, r - 1);<br>            reverse(cur, c2 + 1);<br>            insertionsort(cur, c2 + 1);<br>            s.push({ c2 - cur + 1, cur });<br>            cur = c2 + 1;<br>        }<br>        while (s.size() &gt;= 3) {<br>            pair&lt;int, int*&gt; x = s.top();<br>            s.pop();<br>            pair&lt;int, int*&gt; y = s.top();<br>            s.pop();<br>            pair&lt;int, int*&gt; z = s.top();<br>            s.pop();<br>            if (z.first &gt;= x.first + y.first &amp;&amp; y.first &gt;= x.first) {<br>                s.push(z);<br>                s.push(y);<br>                s.push(x);<br>                break;<br>            }<br>            else if (z.first &gt;= x.first + y.first) {<br>                merge(y.second, x.second, x.second + x.first, temp);<br>                s.push(z);<br>                s.push({ x.first + y.first, y.second });<br>            }<br>            else {<br>                merge(z.second, y.second, y.second + y.first, temp);<br>                s.push({ z.first + y.first, z.second });<br>                s.push(x);<br>            }<br>        }<br>    }<br>    while (s.size() != 1) {<br>        pair&lt;int, int*&gt; x = s.top();<br>        s.pop();<br>        pair&lt;int, int*&gt; y = s.top();<br>        s.pop();<br>        if (x.second &lt; y.second) swap(x, y);<br>        merge(y.second, x.second, x.second + x.first, temp);<br>        s.push({ y.first + x.first, y.second });<br>    }<br>}<br>void timsort(int</em> l, int</em> r) {<br>    int* temp = new int[r - l];<br>    _timsort(l, r, temp);<br>    delete temp;<br>}</p><p>Тестирование</p><p>Железо и система</p><p>Процессор: Intel Core i7-3770 CPU 3.40 GHz<br>ОЗУ: 8 ГБ<br>Тестирование проводилось на почти чистой системе Windows 10 x64, установленной за несколько дней до запуска. Использованная IDE – Microsoft Visual Studio 2015.</p><p>Тесты</p><p>Все тесты поделены на четыре группы. Первая группа – массив случайных чисел по разным модулям (10, 1000, 105, 107 и 109). Вторая группа – массив, разбивающийся на несколько отсортированных подмассивов. Фактически брался массив случайных чисел по модулю 109, а далее отсортировывались подмассивы размера, равного минимуму из длины оставшегося суффикса и случайного числа по модулю некоторой константы. Последовательность констант – 10, 100, 1000 и т.д. вплоть до размера массива. Третья группа – изначально отсортированный массив случайных чисел с некоторым числом «свопов» — перестановок двух случайных элементов. Последовательность количеств свопов такая же, как и в предыдущей группе. Наконец, последняя группа состоит из нескольких тестов с полностью отсортированным массивом (в прямом и обратном порядке), нескольких тестов с исходным массивом натуральных чисел от 1 до n, в котором несколько чисел заменены на случайное, и тестов с большим количеством повторений одного элемента (10%, 25%, 50%, 75% и 90%). Таким образом, тесты позволяют посмотреть, как сортировки работают на случайных и частично отсортированных массивах, что выглядит наиболее существенным. Четвертая группа во многом направлена против сортировок с линейным временем работы, которые любят последовательности случайных чисел. В конце статьи есть ссылка на файл, в котором подробно описаны все тесты.</p><p>Размер входных данных</p><p>Было бы довольно глупо сравнивать, например, сортировку с линейным временем работы и квадратичную, и запускать их на тестах одного размера. Поэтому каждая из групп тестов делится еще на четыре группы, размера 105, 106, 107и 108 элементов. Сортировки были разбиты на три группы, в первой – квадратичные (сортировка пузырьком, вставками, выбором, шейкерная и гномья), во второй – нечто среднее между логарифмическим временем и квадратом, (битонная, несколько видов сортировки Шелла и сортировка деревом), в третьей все остальные. Кого-то, возможно, удивит, что сортировка деревом попала не в третью группу, хотя ее асимптотика и O(nlogn), но, к сожалению, ее константа очень велика. Сортировки первой группы тестировались на тестах с 105элементов, второй группы – на тестах с 106и 107, третьей – на тестах с 107и 108. Именно такие размеры данных позволяют как-то увидеть рост времени работы, при меньших размерах слишком велика погрешность, при больших алгоритм работает слишком долго (или же недостаток оперативной памяти). С первой группой я не стал заморачиваться, чтобы не нарушать десятикратное увеличение (104 элементов для квадратичных сортировок слишком мало), в конце концов, сами по себе они представляют мало интереса.</p><p>Как проводилось тестирование</p><p>На каждом тесте было производилось 20 запусков, итоговое время работы – среднее по получившимся значениям. Почти все результаты были получены после одного запуска программы, однако из-за нескольких ошибок в коде и системных глюков (все же тестирование продолжалось почти неделю чистого времени) некоторые сортировки и тесты пришлось впоследствии перетестировать.</p><p>Тонкости реализации</p><p>Возможно, кого-то удивит, что в реализации самого процесса тестирования я не использовал указатели на функции, что сильно сократило бы код. Оказалось, что это заметно замедляет работу алгоритма (примерно на 5-10%). Поэтому я использовал отдельный вызов каждой функции (это, конечно, не отразилось бы на относительной скорости, но… все же хочется улучшить и абсолютную). По той же причине были заменены векторы на обычные массивы, не были использованы шаблоны и функции-компараторы. Все это более актуально для промышленного использования алгоритма, нежели его тестирования.</p>]]></content>
    
    
    <summary type="html">Сортировка за константное время</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Algorithms" scheme="https://goxpert.ru/categories/Golang/Algorithms/"/>
    
    <category term="Sort" scheme="https://goxpert.ru/categories/Golang/Algorithms/Sort/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Пакеты</title>
    <link href="https://goxpert.ru/2024/06/01/common/package/"/>
    <id>https://goxpert.ru/2024/06/01/common/package/</id>
    <published>2024-06-01T07:03:00.000Z</published>
    <updated>2024-06-01T17:06:56.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Что-такое-пакет"><a href="#Что-такое-пакет" class="headerlink" title="Что такое пакет?"></a>Что такое пакет?</h2><p>В языке программирования Go, пакет (package) - это коллекция исходных файлов Go, которые находятся в одной и той же директории. Все файлы в одном пакете должны иметь одно и то же имя пакета в начале файла.</p><p>Пакеты в Go используются для организации и повторного использования кода. Они представляют собой удобный способ разделения кода на отдельные модули. Это позволяет определить пакет с нужной функциональностью один раз и затем использовать его многократно в различных программах.</p><p>В Go есть два типа пакетов: исполняемые (executable) и библиотеки (reusable). Исполняемые пакеты должны иметь имя <strong><code>main</code></strong> и содержать функцию <strong><code>main</code></strong>, которая является входной точкой в приложение. Все остальные пакеты являются библиотеками и не могут быть напрямую выполнены.</p><h2 id="Расскажи-про-папку-internal"><a href="#Расскажи-про-папку-internal" class="headerlink" title="Расскажи про папку internal"></a>Расскажи про папку internal</h2><p>В Go, папка <strong><code>internal</code></strong> используется для хранения кода, который не должен быть доступен за пределами текущего модуля. Это означает, что любой код, который находится в папке <strong><code>internal</code></strong> (или в подпапках этой папки), может быть импортирован и использован только внутри того же модуля. Это полезно, когда вы хотите скрыть определенные части вашего кода от внешнего мира, чтобы предотвратить его неправильное использование.</p><figure class="highlight plaintext"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">├─ go.mod</span><br><span class="line">├─ internal</span><br><span class="line">│ └─ handler</span><br><span class="line">│   └─ opkg.go</span><br><span class="line">├─ main.go</span><br></pre></td></tr></table></figure><p><img src="/images/golang_packege.jpg" alt="Вот вам и пакет!"></p>]]></content>
    
    
    <summary type="html">Вопросы по пакетам в Golang</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Пакеты" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9F%D0%B0%D0%BA%D0%B5%D1%82%D1%8B/"/>
    
    <category term="Пакеты" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9F%D0%B0%D0%BA%D0%B5%D1%82%D1%8B/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>Общие вопросы</title>
    <link href="https://goxpert.ru/2024/06/01/overall-questions/"/>
    <id>https://goxpert.ru/2024/06/01/overall-questions/</id>
    <published>2024-06-01T07:02:00.000Z</published>
    <updated>2024-06-01T17:05:33.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Какие-технологические-преимущества-экосистемы-Go-вы-можете-назвать"><a href="#Какие-технологические-преимущества-экосистемы-Go-вы-можете-назвать" class="headerlink" title="Какие технологические преимущества экосистемы Go вы можете назвать?"></a>Какие технологические преимущества экосистемы Go вы можете назвать?</h2><p>В случае с экосистемой Go к потенциальным преимуществам можно отнести:</p><ul><li>Большое и активное сообщество разработчиков, которые вносят свой вклад в развитие языка Go и его экосистемы.</li><li>Богатый набор библиотек и инструментов, облегчающих разработку, тестирование и развертывание приложений на Go.</li><li>Совместимость с широким спектром платформ и систем, что делает его универсальным выбором для создания приложений.</li><li>Сильная поддержка конкурентного и параллельного программирования, что позволяет повысить производительность и масштабируемость приложений.</li><li>Упор на простоту и читабельность, что облегчает изучение и использование языка разработчиками и способствует развитию экосистемы.</li></ul><h2 id="Go-императивный-или-декларативный-А-в-чем-разница"><a href="#Go-императивный-или-декларативный-А-в-чем-разница" class="headerlink" title="Go - императивный или декларативный? А в чем разница?"></a>Go - императивный или декларативный? А в чем разница?</h2><p>Go - императивный язык программирования. Это означает, что в нем используются инструкции, которые описывают, как выполнять задачу. В декларативных языках программирования, например, SQL, описывается, что должно быть сделано, а не как это сделать.</p><h2 id="Какие-особенности-Go-вы-можете-назвать"><a href="#Какие-особенности-Go-вы-можете-назвать" class="headerlink" title="Какие особенности Go вы можете назвать?"></a>Какие особенности Go вы можете назвать?</h2><ul><li>Статическая типизация</li><li>Сборка мусора</li><li>Конкурентность</li><li>Параллелизм</li><li>Отсутствие исключений</li><li>Строгая типизация</li><li>Строгая проверка ошибок</li></ul><h2 id="Почему-треды-в-Go-легковесные"><a href="#Почему-треды-в-Go-легковесные" class="headerlink" title="Почему треды в Go - легковесные"></a>Почему треды в Go - легковесные</h2><p>В Go горутины - это легковесные потоки, управляемые средой выполнения Go. Они более легковесны, чем потоки операционной системы, потому что занимают меньше места в памяти, обычно около 2 килобайт, по сравнению с памятью потока операционной системы, которая может составлять несколько мегабайт. Такой меньший объем памяти позволяет среде выполнения Go создавать большое количество горутин, часто тысячи или даже миллионы, не исчерпывая системных ресурсов.</p><p>Кроме того, среда выполнения Go использует планировщик, чтобы мультиплексировать горутины на меньшее число потоков операционной системы, что позволяет снизить накладные расходы на создание и управление потоками. Планировщик также может выполнять контекстные переключения между горутинами без участия операционной системы, что может быть быстрее, чем полное контекстное переключение между потоками операционной системы.</p><p>В целом, сочетание меньшего объема памяти и планировщика пользовательского пространства делает горутины легким и эффективным механизмом для параллельного выполнения в программах на Go.</p><h2 id="Какие-средства-обобщенного-программирования-есть-в-Go"><a href="#Какие-средства-обобщенного-программирования-есть-в-Go" class="headerlink" title="Какие средства обобщенного программирования есть в Go?"></a>Какие средства обобщенного программирования есть в Go?</h2><p>В Go 1.18 появилась поддержка обобщенного программирования. Обобщенное программирование - это способность писать функции и типы, которые работают с любыми типами данных, а не только с конкретными типами данных. В Go 1.18 обобщенное программирование реализовано с помощью параметризованных типов и функций.</p><h2 id="Какие-средства-метапрограммирования-есть-в-Go"><a href="#Какие-средства-метапрограммирования-есть-в-Go" class="headerlink" title="Какие средства метапрограммирования есть в Go?"></a>Какие средства метапрограммирования есть в Go?</h2><p>В Go нет средств метапрограммирования, таких как макросы, шаблоны. Вместо этого Go предоставляет мощную систему интерфейсов, которая позволяет писать гибкий и расширяемый код, который может быть легко адаптирован к различным типам данных.</p><h2 id="Какая-сортировка-используется-в-Golang"><a href="#Какая-сортировка-используется-в-Golang" class="headerlink" title="Какая сортировка используется в Golang?"></a>Какая сортировка используется в Golang?</h2><p>В Go используется алгоритм сортировки “Quicksort”, который является эффективным алгоритмом сортировки с асимптотической сложностью O(n log n). Этот алгоритм используется в стандартной библиотеке “sort” для сортировки слайсов и пользовательских коллекций данных.</p><h2 id="Какая-кодировка-используется-в-Golang"><a href="#Какая-кодировка-используется-в-Golang" class="headerlink" title="Какая кодировка используется в Golang?"></a>Какая кодировка используется в Golang?</h2><p>Go поддерживает UTF-8 кодировку по умолчанию для всех строковых типов. Это означает, что вы можете безопасно использовать Unicode символы в строках в Go. Библиотека “unicode/utf8” предоставляет функции для работы с UTF-8 кодированными строками.</p><h2 id="Можно-ли-в-Golang-создать-статический-метод"><a href="#Можно-ли-в-Golang-создать-статический-метод" class="headerlink" title="Можно ли в Golang создать статический метод?"></a>Можно ли в Golang создать статический метод?</h2><p>В Go нет классов и, следовательно, нет статических методов в традиционном понимании этого термина, как в языках, таких как Java или C++. Однако, вы можете создать функции, которые привязаны к определенному типу данных, что близко к понятию статического метода.</p><p>Вот пример:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t MyType)</span> <span class="title">StaticMethod</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.value * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>В этом примере <code>StaticMethod</code> является функцией, которая привязана к типу <code>MyType</code>. Вы можете вызвать эту функцию на экземпляре <code>MyType</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := MyType&#123;value: <span class="number">5</span>&#125;</span><br><span class="line">result := t.StaticMethod() <span class="comment">// result is 10</span></span><br></pre></td></tr></table></figure><p>Это не совсем то же самое, что статический метод в языках с классами, но это ближайший аналог в Go.</p><p><img src="/images/common_questions.jpg" alt="С первым полетом!"></p>]]></content>
    
    
    <summary type="html">Вопросы по Golang не относящиеся к конкретным темам</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Общие" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%9E%D0%B1%D1%89%D0%B8%D0%B5/"/>
    
    <category term="Общие" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%9E%D0%B1%D1%89%D0%B8%D0%B5/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
  <entry>
    <title>С 1 Июня 2024!</title>
    <link href="https://goxpert.ru/2024/06/01/helloworld/"/>
    <id>https://goxpert.ru/2024/06/01/helloworld/</id>
    <published>2024-06-01T07:00:00.000Z</published>
    <updated>2024-06-02T07:43:20.347Z</updated>
    
    <content type="html"><![CDATA[<p>Добрый день! Сегодня родился сайт GoXpert. </p><p>Для чего нужен этот сайт:</p><ul><li>Во-первых, для меня. Да, меня зовут Дмитрий Сигаев. Это сайт, на мой взгляд, поможет мне структурировать свои знания в разных областях, но в основном в экосистеме GO. Я много, что умею, но не могу в нужный для меня момент вынуть из своей головы нужной информации. Данный сайт — это так называемое хранилище моего опыта и якорей для быстрой настройки кратковременной памяти :) </li><li>Во-вторых, если это полезно для меня, то, на мой взгляд, найдется тот, кому это сайт тоже поможет в чем-то разобраться…</li><li>В-третьих, хочу выразить благодарность Сергею Артамонову. Спасибо за второй шанс и последствие в виде данного сайта. Надеюсь, быть его падаваном и соавтором публикаций на данном сайта.</li></ul><p>Ладно, не будем терять времени… поехали…</p><p>Let’s GO!</p><p><img src="/images/lets_go_with_goxpert.jpg" alt="С первым полетом!"></p><div id="aplayer-LMBIqxFh" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"><pre class="aplayer-lrc-content">Небо мой дом...</pre></div><script>var ap = new APlayer({element: document.getElementById("aplayer-LMBIqxFh"),narrow: false,autoplay: false,showlrc: 2,music: {title: "Лови Момент",author: "Machete",url: "/audio/MacheteTakeIt.mp3",pic: "",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><p><img src="/images/okko_2024_05.jpg" alt="Цель есть и она за окном... возможностей"></p>]]></content>
    
    
      
      
      
    <summary type="html">&lt;p&gt;Добрый день! Сегодня родился сайт GoXpert. &lt;/p&gt;
&lt;p&gt;Для чего нужен этот сайт:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Во-первых, для меня. Да, меня зовут Дмитрий Сигаев. Это сайт, на мой взгляд, поможет мне структурировать св</summary>
      
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    
    <category term="Golang" scheme="https://goxpert.ru/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Горутины что было</title>
    <link href="https://goxpert.ru/2024/06/01/concurrency/goroutines_old/"/>
    <id>https://goxpert.ru/2024/06/01/concurrency/goroutines_old/</id>
    <published>2024-06-01T06:17:00.000Z</published>
    <updated>2024-06-03T08:08:17.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Горутины-всё-что-вы-хотели-знать-но-боялись-спросить"><a href="#Горутины-всё-что-вы-хотели-знать-но-боялись-спросить" class="headerlink" title="Горутины: всё, что вы хотели знать, но боялись спросить"></a>Горутины: всё, что вы хотели знать, но боялись спросить</h2><p>Кратко:</p><ul><li>Горутины выполняются в порядке очереди, то есть FIFO (First In, First Out).</li><li>Исполнение горутины прерывается<ol><li>уже не может выполняться: то есть из-за системного вызова</li><li>при использования синхронизирующих объектов (операции с каналами, мьютексами и т.п.).</li></ol></li><li>Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась в очередь.</li><li>Самостоятельно вызвать runtime.Gosched() чтобы позволить планировщику вызывать goroutine</li></ul><p>В этой статье я постараюсь кратко и емко рассказать что такое горутины, когда стоит их использовать, какое отношение они имеют к системным потокам, а так же как работает планировщик.</p><h3 id="Что-за-горутины"><a href="#Что-за-горутины" class="headerlink" title="Что за горутины?"></a>Что за горутины?</h3><p>Горутина (goroutine) — это функция, выполняющаяся конкурентно с другими горутинами в том же адресном пространстве.</p><p>Запустить горутину очень просто:<br>go normalFunc(args…)</p><p>Функция normalFunc(args…) начнет выполняться асинхронно с вызвавшим ее кодом.</p><p>Обратите внимание, горутины очень легковесны. Практически все расходы — это создание стека, который очень невелик, хотя при необходимости может расти.</p><h3 id="Сколько-вешать-в-граммах"><a href="#Сколько-вешать-в-граммах" class="headerlink" title="Сколько вешать в граммах?"></a>Сколько вешать в граммах?</h3><p>Чтобы было проще ориентироваться, рассмотрим цифры полученные опытным путем.</p><p>В среднем можно рассчитывать примерно на 4,5kb на горутину. То есть, например, имея 4Gb оперативной памяти, вы сможете содержать около 800 тысяч работающих горутин. Может этого и недостаточно, чтобы впечатлить любителей Erlang, но мне кажется, что цифра весьма достойная :)</p><p>И все же не стоит бездумно выделять функцию в горутину где только можно. Пользу это принесет в следующих случаях:</p><p>Если нужна асинхронность. Например когда мы работаем с сетью, диском, базой данных, защищенным мьютексом ресурсом и т.п.<br>Если время выполнения функции достаточно велико и можно получить выигрыш, нагрузив другие ядра.</p><p>«Достаточно велико» — это сколько? Сложный вопрос. Скорее всего решать придется в зависимости от конкретной ситуации. Скажу только, что из моего опыта на моем железе (atom d525 64bit) это ~50мкс. А вообще, тестируйте и развивайте чутье ;)</p><h3 id="Системные-потоки"><a href="#Системные-потоки" class="headerlink" title="Системные потоки"></a>Системные потоки</h3><p>В исходном коде <a href="src/pkg/runtime/proc.c">src/pkg/runtime/proc.c</a> приняты такие термины:<br>G (Goroutine) — Горутина<br>M (Machine) — Машина</p><p>Каждая Машина работает в отдельном потоке и способна выполнять только одну Горутину в момент времени. Планировщик операционной системы, в которой работает программа, переключает Машины. Число работающих Машин ограничено переменной среды GOMAXPROCS или функцией runtime.GOMAXPROCS(n int). По умолчанию оно равно 1. Обычно имеет смысл сделать его равным числу ядер.</p><h3 id="Планировщик-Go"><a href="#Планировщик-Go" class="headerlink" title="Планировщик Go"></a>Планировщик Go</h3><p>Цель планировщика (scheduler) в том, чтобы распределять готовые к выполнению горутины (G) по свободным машинам (M).</p><p><img src="/images/sched1.png" alt="Рисунок и описание планировщика взяты из работы Sindre Myren"></p><p><a href="https://insomnia.ed.ntnu.no/code/p/p2011/downloads/">Sindre Myren RT Capabillites of Google Go.</a></p><p>Готовые к исполнению горутины выполняются в порядке очереди, то есть FIFO (First In, First Out). Исполнение горутины прерывается только тогда, когда она уже не может выполняться: то есть из-за системного вызова или использования синхронизирующих объектов (операции с каналами, мьютексами и т.п.). Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась в очередь. Чтобы позволить планировщику сделать это, нужно самостоятельно вызвать runtime.Gosched().</p><p>Как только функция вновь готова к выполнению, она снова попадает в очередь.</p><h3 id="Выводы"><a href="#Выводы" class="headerlink" title="Выводы"></a>Выводы</h3><p>Скажу сразу, что меня текущее положение дел сильно удивило. Почему-то подсознательно я ожидал большей «параллельности», наверное потому что воспринимал горутины как легковесные системные потоки. Как видите, это не совсем так.</p><p>На практике это в первую очередь означает, что иногда стоит использовать runtime.Gosched(), чтобы несколько долгоживущих горутин не остановили на существенное время работу всех других. С другой стороны, такие ситуации встречаются на практике довольно редко.</p><p>Так же хочу отметить, что на данный момент планировщик отнюдь не совершенен, о чем упоминается в документации и официальном FAQ. В будущем планируются серьезные улучшения. Лично я в первую очередь ожидаю возможность задания горутинам приоритета.</p><p><img src="/images/golang_goroutine.jpg" alt="Вот вам и goroutine"></p>]]></content>
    
    
    <summary type="html">Горутины - всё, что вы хотели знать, но боялись спросить</summary>
    
    
    
    <category term="Golang" scheme="https://goxpert.ru/categories/Golang/"/>
    
    <category term="Старт" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/"/>
    
    <category term="Вопрос-Ответ" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/"/>
    
    <category term="Горутины" scheme="https://goxpert.ru/categories/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%9E%D1%82%D0%B2%D0%B5%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/"/>
    
    <category term="Горутины" scheme="https://goxpert.ru/categories/Golang/%D0%A1%D1%82%D0%B0%D1%80%D1%82/%D0%93%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B/"/>
    
    
    <category term="Golang, Q&amp;A" scheme="https://goxpert.ru/tags/Golang-Q-A/"/>
    
  </entry>
  
</feed>
